<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#f5b8d5"><meta name="author" content="l1pmoluy,1392181761@qq.com"><meta name="copyright" content="l1pmoluy"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>WindowsStudy01-保护机制&amp;段检测 | l1pmoluy</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#f5b8d5"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"l1pmoluy.github.io","root":"/","title":"踏着梦走过时光","version":"1.10.11","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"hits":{"per_page":8}},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="l1pmoluy" type="application/atom+xml"><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="保护机制、段、页">
<meta property="og:type" content="article">
<meta property="og:title" content="WindowsStudy01-保护机制&amp;段检测">
<meta property="og:url" content="https://l1pmoluy.github.io/2025/04/06/WindowsStudy01-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&%E6%AE%B5%E6%A3%80%E6%B5%8B/index.html">
<meta property="og:site_name" content="l1pmoluy">
<meta property="og:description" content="保护机制、段、页">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/1.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/2.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/3.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/4.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/5.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/6.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/7.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/8.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/9.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/10.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/11.png">
<meta property="og:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/12.png">
<meta property="article:published_time" content="2025-04-06T11:12:42.000Z">
<meta property="article:modified_time" content="2025-10-08T07:27:44.285Z">
<meta property="article:author" content="l1pmoluy">
<meta property="article:tag" content="windows深度学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://l1pmoluy.github.io/.io//tool/blog/source/postpic/windows1/1.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="l1pmoluy"><img width="96" loading="lazy" src="/images/rika.jpg" alt="l1pmoluy"><span class="site-author-status" title="Looking for dawn.">🥰</span></a><div class="site-author-name"><a href="/about/">l1pmoluy</a></div><span class="site-name">l1pmoluy</span><sub class="site-subtitle">Dawing...</sub><div class="site-description">l1pmoluy's blog</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" title="1392181761" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://blog.csdn.net/dawn_ing_" title="csdn" target="_blank" style="color:#e83b07"><span class="icon iconify" data-icon="ri:terminal-box-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://bbs.kanxue.com/user-home-1012312.htm" title="看雪" target="_blank" style="color:#e83b07"><span class="icon iconify" data-icon="ri:snowflake-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="1392181761@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.yuque.com/hututu-mknzl" title="语雀" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:yuque-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="友链" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:user-community-line"></span></a><a class="links-item hty-icon-button" href="/girl/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">保护机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windbg%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">windbg的一些指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#idt%E5%92%8Cgdt"><span class="toc-number">3.</span> <span class="toc-text">idt和gdt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#idt%E5%92%8Cgdt%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">idt和gdt的指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%A8%E7%AC%A6%E6%A1%86%E6%9E%B6"><span class="toc-number">5.</span> <span class="toc-text">门符框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%A8%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">门符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#s-1-%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">s&#x3D;1-段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#t"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">t&lt;8-数据段 GDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#t-7-%E4%BB%A3%E7%A0%81%E6%AE%B5-GDT"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">t&gt;7-代码段 GDT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#s-0-%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">s&#x3D;0-系统描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#t-c-%E8%B0%83%E7%94%A8%E9%97%A8-GDT"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">t&#x3D;c-调用门 GDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#t-6-%E4%B8%AD%E6%96%AD%E9%97%A8-IDT"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">t&#x3D;6 -中断门 IDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#t-5-%E4%BB%BB%E5%8A%A1%E9%97%A8-IDT"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">t&#x3D;5-任务门 IDT</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">段选择符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="toc-number">6.2.</span> <span class="toc-text">段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">练习代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-b"><span class="toc-number">6.2.2.</span> <span class="toc-text">d&#x2F;b</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E8%B7%B3%E8%BD%AC-%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">提权跳转-符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">系统段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8"><span class="toc-number">7.1.</span> <span class="toc-text">调用门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="toc-number">7.2.</span> <span class="toc-text">中断门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8"><span class="toc-number">7.3.</span> <span class="toc-text">陷阱门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="toc-number">7.4.</span> <span class="toc-text">任务门</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%AD%E6%96%AD%E9%97%A8%E7%9A%84hook-int-3-hook"><span class="toc-number">8.</span> <span class="toc-text">基于中断门的hook int 3 hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101012"><span class="toc-number">9.</span> <span class="toc-text">101012</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E3%81%AE%E5%89%8D%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">页の前章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">10.1.</span> <span class="toc-text">线性地址对应物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%B1%9E%E6%80%A7"><span class="toc-number">10.2.</span> <span class="toc-text">页属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P"><span class="toc-number">10.2.1.</span> <span class="toc-text">P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#US"><span class="toc-number">10.2.2.</span> <span class="toc-text">US</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A"><span class="toc-number">10.2.3.</span> <span class="toc-text">A</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G"><span class="toc-number">10.2.4.</span> <span class="toc-text">G</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E3%81%AE%E7%BB%88%E7%AB%A0"><span class="toc-number">11.</span> <span class="toc-text">页の终章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E9%A1%B5"><span class="toc-number">11.1.</span> <span class="toc-text">挂页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E4%B8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">页下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">11.3.</span> <span class="toc-text">TLB</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#f5b8d5;"><link itemprop="mainEntityOfPage" href="https://l1pmoluy.github.io/2025/04/06/WindowsStudy01-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&amp;%E6%AE%B5%E6%A3%80%E6%B5%8B/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="l1pmoluy,1392181761@qq.com"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="l1pmoluy"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">WindowsStudy01-保护机制&amp;段检测</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2025-4-6 19:12:42" itemprop="dateCreated datePublished" datetime="2025-04-06T19:12:42+08:00">2025-4-6</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2025-10-8 15:27:44" itemprop="dateModified" datetime="2025-10-08T15:27:44+08:00">2025-10-8</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">4.6k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">18m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/" style="--text-color:#FF0000" itemprop="url" rel="index"><span itemprop="text">逆向行驶</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="--text-color:#416482"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">windows深度学习</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><p>保护机制、段、页</p>
<span id="more"></span>

<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>首先铺垫，在前面学过pe文件格式，且写过反射型注入，有一定知识前置</p>
<p>我们知道，一个软件在运行的时候，会分配一个内存中的基地址（虚拟地址），很好，那么明明是在内存中实体存在的为什么叫虚拟地址？我们还知道，地址是线性的0 1 2 …… 0xffffffffh，线性排布，那么问题来了，我的程序加载到内存中，假如说是0x87654321，欸？此时我有一个指令是mov dword ptr [0] , 1，那么会把内存开始地方的东西改动掉，但是内存最开始的东西肯定是很内核的东西，什么对程序的调用啊，什么的之前在反调试有接触过</p>
<p>自然是不能让你随便动他的，那么怎么才能很安全的做到呢</p>
<p>目前我学到的是分段分页，相当于在原本的0x55555555h的地方一刀斩断，后面又开始0x0h（应该如此，后续回来补充）</p>
<p>嗯不是这样的，是分成一段一段然后通过代码段，数据段来区分，这是段保护机制</p>
<p>页保护估计就是进程线程的吧。。。</p>
<h2 id="windbg的一些指令"><a href="#windbg的一些指令" class="headerlink" title="windbg的一些指令"></a>windbg的一些指令</h2><p>r	查看一些寄存器(r eax | r al | r gdtr)</p>
<p>d	查看地址(byte(db) | word(dw) | … ) | (L limit 限制要看多长) | (s 竖着看)</p>
<p>e	写内存(用法和d一致)</p>
<h2 id="idt和gdt"><a href="#idt和gdt" class="headerlink" title="idt和gdt"></a>idt和gdt</h2><p>idt和gdt结构前两字节是limit大小，后四字节是地址</p>
<h2 id="idt和gdt的指令"><a href="#idt和gdt的指令" class="headerlink" title="idt和gdt的指令"></a>idt和gdt的指令</h2><p>sidt sgdt 用例就是把gdt表和idt表加载出来</p>
<p>lidt lgdt 赋值给他</p>
<h2 id="门符框架"><a href="#门符框架" class="headerlink" title="门符框架"></a>门符框架</h2><p>很好前面虽然很乱但是捋一下就清晰了，本篇文章只用来构造框架，具体的内容将在其他文章细记</p>
<h3 id="门符"><a href="#门符" class="headerlink" title="门符"></a>门符</h3><p>注意注意，门或符GDT表或IDT中每个单元的名称！！！</p>
<p>每个单元都有-P位 S位 Type位</p>
<p>P-决定该描述符有效</p>
<p>S-决定该描述符属于什么类型</p>
<p>T-决定改描述符更具体类型</p>
<p><strong>声明1</strong>：门和xx段描述符感觉差不多一个意思</p>
<h4 id="s-1-段描述符"><a href="#s-1-段描述符" class="headerlink" title="s&#x3D;1-段描述符"></a>s&#x3D;1-段描述符</h4><p>s&#x3D;1是段描述符，这时候的T遵循的图就是<img src="/.io//tool\blog\source\postpic\windows1\1.png" loading="lazy"></p>
<h5 id="t"><a href="#t" class="headerlink" title="t&lt;8-数据段 GDT"></a>t&lt;8-数据段 GDT</h5><h5 id="t-7-代码段-GDT"><a href="#t-7-代码段-GDT" class="headerlink" title="t&gt;7-代码段 GDT"></a>t&gt;7-代码段 GDT</h5><p>数据段或代码段，同时无论是数据段还是代码段都解析的都是如下图<img src="/.io//tool\blog\source\postpic\windows1\2.png" loading="lazy"></p>
<h4 id="s-0-系统描述符"><a href="#s-0-系统描述符" class="headerlink" title="s&#x3D;0-系统描述符"></a>s&#x3D;0-系统描述符</h4><p>s&#x3D;0是系统描述符，这时候的T遵循的图就是<img src="/.io//tool\blog\source\postpic\windows1\3.png" loading="lazy"></p>
<h5 id="t-c-调用门-GDT"><a href="#t-c-调用门-GDT" class="headerlink" title="t&#x3D;c-调用门 GDT"></a>t&#x3D;c-调用门 GDT</h5><p>调用门遵循下图<img src="/.io//tool\blog\source\postpic\windows1\4.png" loading="lazy"></p>
<h5 id="t-6-中断门-IDT"><a href="#t-6-中断门-IDT" class="headerlink" title="t&#x3D;6 -中断门 IDT"></a>t&#x3D;6 -中断门 IDT</h5><p>int 3 int 2 int 1…遵循下图<img src="/.io//tool\blog\source\postpic\windows1\5.png" loading="lazy"></p>
<h5 id="t-5-任务门-IDT"><a href="#t-5-任务门-IDT" class="headerlink" title="t&#x3D;5-任务门 IDT"></a>t&#x3D;5-任务门 IDT</h5><p><img src="/.io//tool\blog\source\postpic\windows1\6.png" loading="lazy"></p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><h3 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h3><p><img src="/.io//tool\blog\source\postpic\windows1\7.png" loading="lazy"></p>
<p>长度一字节，比如CS里的1B值就是段选择符（0x18是打印cs值会打印出来的）</p>
<p>1B：0000 0000 0001 1      0 		11</p>
<p>0011		       查找表	   请求权限</p>
<p>   3，在表中的第3位	  0&#x3D;GDT	  Global Decsrctor Table(全局描述表)</p>
<p> 1&#x3D;LDT	Local Decsrctor Table(本地描述表)</p>
<p>CS	1B 代码段</p>
<p>SS	23 栈段(栈，局部变量)</p>
<p>DS	23 数据段(堆，全局变量)</p>
<p>ES	23 扩展段(可以还原ds)</p>
<p>FS	上下文环境段	R3代表TEB R0代码是KPCR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// study02.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int val=0x100;</span><br><span class="line">int val2=0x1;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov dword ptr ds:[val2],eax;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%x\n&quot;,val2);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="段描述符-1"><a href="#段描述符-1" class="headerlink" title="段描述符"></a>段描述符</h3><p>也就是前面的GDT和LDT表的内容</p>
<p>举个例子：</p>
<blockquote>
<p>kd&gt; r gdtr</p>
<p>gdtr&#x3D;80b98800</p>
</blockquote>
<p>通过查找指令找到gdt表，gdt表是按照1字也就是两字节的形式为最小单位，所以查找的时候要用dq</p>
<blockquote>
<p>kd&gt; dq 80b98800</p>
<p>80b98800  00000000<code>00000000 00cf9b00</code>0000ffff</p>
<p>80b98810  00cf9300<code>0000ffff 00cffb00</code>0000ffff</p>
<p>80b98820  00cff300<code>0000ffff 80008bb9</code>8c0020ab</p>
<p>80b98830  804093b9<code>b0004fff 0040f300</code>00000fff</p>
<p>80b98840  0000f200<code>0400ffff 00000000</code>00000000</p>
<p>80b98850  800089b9<code>ad200067 800089b9</code>acb00067</p>
<p>80b98860  00000000<code>00000000 00000000</code>00000000</p>
<p>80b98870  800092b9<code>880003ff 00000000</code>00000000</p>
</blockquote>
<p>按照上面索引第三个(注意，从0开始数)  00cffb00&#96;0000ffff，和段选择符一样，要拆分分析</p>
<p><img src="/.io//tool\blog\source\postpic\windows1\8.png" loading="lazy"></p>
<p>对照上表，高字节部分和低字节部分</p>
<p>31    24   		   19     16            12     8     0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00  c       f   f       b   00</span><br></pre></td></tr></table></figure>

<p>   1100 		   1111</p>
<p>h: b   	gb0a	l  	 hd s	t	b</p>
<p>  0000	ffff</p>
<p>l: b  		l</p>
<p>limit:f+ffff&#x3D;0xfffff	段限制大小(sizeof(cs)):(h&amp;l)+(l&amp;l)</p>
<p>base:00+00+0000	基址大小(base):(h&amp;b)+(h&amp;b)+(l&amp;b)</p>
<p>type:(h&amp;t)b	tpye作用见下表</p>
<p>s:(h&amp;s)1</p>
<p>DPL:(h&amp;d)3</p>
<p>p:(h&amp;p)1		p用来证明该段是否有效，1有效，0无效</p>
<p>avl:(h&amp;a)0</p>
<p>0:(h&amp;0)0</p>
<p>D&#x2F;B:(h&amp;b)1</p>
<p>G:(h&amp;g)1		若为1，则以页为单位（影响的是段限制的单位）（一个页4096字节） 转换为hex-&gt;0x1000</p>
<p>故真正限制大小：(limit+1)*(g)		按照上面的计算也就是(0xfffff+1)*0x1000&#x3D;0x1 0000 0000，范围就是0-0xf ffff fff	也就是4个g</p>
<p>type作用：<img src="/.io//tool\blog\source\postpic\windows1\9.png" loading="lazy"></p>
<h4 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// study02.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int val=0x100;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int val2=0x1;</span><br><span class="line">    //段保护</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov ds,ax;</span><br><span class="line">        mov eax,dword ptr ds:[val]; //ds:[val]就是全局变量val</span><br><span class="line">        //mov dword ptr ds:[val2],eax;//直接这样会报错，因为cs给了ds，cs段是可读可执行不可写，这里相当于写入所以不可以</span><br><span class="line">        //恢复ds环境</span><br><span class="line">        mov ax,es;</span><br><span class="line">        mov ds,ax;</span><br><span class="line">        //可以赋值</span><br><span class="line">        mov [val2],eax;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;val2=%x\n&quot;,val2);</span><br><span class="line">    //0x100</span><br><span class="line"></span><br><span class="line">    //查看段选择符</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov [val2],eax;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;cs=0x%x\n&quot;,val2);</span><br><span class="line">    //0x1b</span><br><span class="line"></span><br><span class="line">    //对base的探测</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ax,0x4b;        //这里用windbg将对应gdt表动过，也就是让base+1了</span><br><span class="line">        mov ds,ax;</span><br><span class="line">        mov eax,dword ptr ds:[val];</span><br><span class="line">        mov dword ptr ss:[val2],eax;</span><br><span class="line">        //mov cx,es;</span><br><span class="line">        //mov ds,cx;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;0x%x\n&quot;,val2);</span><br><span class="line">    //正常来说这里是100，但是如果改变base基地址，那么赋值的时候eax给的就是base+offset val2+1，，没有改变val2地址的值，后面恢复了ds就正常了</span><br><span class="line">    //同理，将前面的恢复环境注释掉，后面再恢复</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov cx,es;</span><br><span class="line">        mov ds,cx;</span><br><span class="line">    &#125;</span><br><span class="line">    //若是这样子，应该是没有变化的</span><br><span class="line"></span><br><span class="line">    ////对段长度的探测</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        //limit</span><br><span class="line">        //mov eax,fs:[0x1000-4];//这里如果是0x1000-4 - 0x1000之内的都会出错，因为超出大小了</span><br><span class="line">        //mov val2,eax;</span><br><span class="line">        //p</span><br><span class="line">        //在gdt表中将p改成0就可以无效了，这里正常运行上面的那个代码就会报错</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;fs:[0]=0x%x\n&quot;,val2);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次总结一下，cs,ds这些段如果是cs:[x]，那么会调用代码段中的x地址，但是如果只是cs，也就是cs中的值，并不是基地址，而是段选择符，也就是可以拆解的，有时候就会去对照gdt表，然后查看gdt里的东西</p>
<h4 id="d-b"><a href="#d-b" class="headerlink" title="d&#x2F;b"></a>d&#x2F;b</h4><p>话解上题，通过windbg更改端段描述符cs,ds可以做到全局改变，d&#x2F;b的作用是用来规定操作符大小的，比如正常push指令push的是一字节，但是如果d&#x2F;b位改变，这里有可能只push一字等，也就是本来的push xx xx xx xx就会变成push xx xx</p>
<p>个人感觉就像是改变这个电脑是32位还是16位还是64位，存在用处也很明显，就是可以兼容低版本（这里注意改变的是段描述符里的d&#x2F;b也就是说，该段相关改变，比如ss(栈)改了的话，call指令就会有问题，因为call相当于pop jmp，但是操作字节变少了，原本是call 0x12345678，pop出来就只有0x1234，jmp 0x1234，所以就会出现问题<img src="/.io//tool\blog\source\postpic\windows1\10.png" loading="lazy"></p>
<p>win系统内部权限分化，R0和R3是内核层和应用层，这个倒是很好理解，去调用</p>
<p>判别当前代码是当前层的办法就是CS和SS</p>
<p>这里阐述一个观点，段的存在是划分硬件资源的，内存中是线性排列的一群1和0，是段来定位划分每一块的作用，最后cs，ss，ds诸如此类的段就是对这个划分块的描述</p>
<p>DPL: Descriptor Privilege Level 描述符特权级  </p>
<p>CPL: Current Privilege Level 当前特权级  	CS段描述符的DPL</p>
<p>RPL: Request Privilege Level  请求者特权级  	CS DS SS，在段描述符的后三位</p>
<p><img src="/.io//tool\blog\source\postpic\windows1\11.png" loading="lazy"></p>
<p>这里卡了有点久，起初我不是很理解gpt所说的</p>
<table>
<thead>
<tr>
<th><strong>段类型</strong></th>
<th><strong>DPL 规则</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码段</strong></td>
<td><strong>CPL ≤ DPL</strong></td>
</tr>
<tr>
<td><strong>数据段</strong></td>
<td><strong>max(CPL, RPL) ≤ DPL</strong></td>
</tr>
<tr>
<td><strong>栈段（SS）</strong></td>
<td><strong>RPL&#x3D;CPL &#x3D; DPL</strong></td>
</tr>
</tbody></table>
<p>上述表格，但是结合上图就会发现，0才是内核层，假如现在代码是内核代码，那么这段代码的DPL就是0，如果你自己写了一段代码，那么大概率在R3，应用层，此时你的代码描述符cs里的CPL就会是3（DPL应该也是3）</p>
<p>此时如果你要调用内核层的代码，则会访问失败(但我不知道这个怎么调用)</p>
<p>以此类推，后两个也不难理解</p>
<h3 id="提权跳转-符"><a href="#提权跳转-符" class="headerlink" title="提权跳转-符"></a>提权跳转-符</h3><p> 嗯后面的我好像也懂了，补刚刚的坑，那么众所周知cs在应用层是23，那么</p>
<p>call 23h:0040100h就是跳转到当前程序的0x401000地址，并且跳跃过去的段权限对应是3，那么在gdt表中把一个无用位置改成CPL值为2的cs，然后手动call 48h:4010000h，48就是改变的gdt表导向，也就是call提权</p>
<p>那么跳转指令还有jmp\ret\retf等等，这些的跳转可以不可以提权呢</p>
<p>jmp 在调用门 只能同权限跳转</p>
<p>retf 只能同权限或向低权限跳转</p>
<p>call 同权限或提权</p>
<p>本来换下一节课了，听到调用门一愣，调用门似乎他没说，我不清楚为什么感觉容易漏东西，所以自己补了一下，网上找了一篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/13264239.html#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E9%97%A8-%E8%B0%83%E7%94%A8%E9%97%A8">文章</a>讲的还不错</p>
<p>我一看这个调用门描述符，和段描述符十分相似</p>
<p>所以段又描述符，调用门也有？后面看来好像是这样的，而且构造和段描述符差不多</p>
<p>我去，，，误会了我没看到这节课，好吧回来接着学</p>
<p>那么前面说的和提权跳转差不多，当然也有可能是这两个本来就是一样的，所以我决定好好复现这个程序</p>
<p>那么首先我们要获得cs的值，并且分解分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov a,eax;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%x&quot;,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里获取的值是1b -&gt;0001 1011，也就是3的位置</p>
<p>r gdtr获取地址-80b98800</p>
<p>dp 80b98800后发现80b98848后的位置适合放更改DPL的位置</p>
<p>原值是0000ffff 00cffb00-f-1111-DPL-11</p>
<p>需要改成DPL-00-1001-9-0000ffff 00cf9b00</p>
<p>我突然发现有现成的1，其实可以改成0000 1011- b</p>
<p>那么接下来要获得函数的地址-0x0401000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">void __declspec(naked) test()&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        retf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%x\n&quot;,test);//0x0401000</span><br><span class="line">    </span><br><span class="line">    char bufcode[6]=&#123; 0x00, 0x0, 0x0, 0, 0x48, 0&#125;;</span><br><span class="line">    *(int *)&amp;bufcode[0]=(int )test;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        //push addr;</span><br><span class="line">        //jmp fword ptr bufcode;</span><br><span class="line">        jmp far bufcode;</span><br><span class="line">addr:</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int 3</p>
<p>哈哈中断一下，因为确实这里中断了好几次，我当时自己写的代码一直都不能跑，会中断，我复现课里的内容也还是不可以，最后发现他改的是 00cffb00&#96;0000ffff</p>
<p>欸？这不是没改嘛，对就是没改，那不对呀，没改怎么提权了，哎这里真的想了很久，因为RPL在段描述符中，他用的是48，0100 1000，RPL是0，R0层，哦对他也没说这个实验可以提权，而是申请对吧</p>
<p>。。所以这里就是这个啊。。。哎不记了接着看，反正也懂了，始终切记DPL在gdt里，RPL在段描述符里</p>
<h2 id="系统段描述符"><a href="#系统段描述符" class="headerlink" title="系统段描述符"></a>系统段描述符</h2><p>这里的门是系统段的门，也算是描述符，就像是指引路的传送门，比如调用门，门后的就是代码段，中断门，门后的是处理中断的代码段，任务门门后的是TSS任务段</p>
<p>还是看完再测试比较好</p>
<h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><p>调用门作用是跳转提供基地址等一系列参数的</p>
<p>具体框架在另一篇文章，这里只阐述注意点</p>
<p>1.调用门即地址前寻址的cs ds ss，但是并不是段选择符的那些cs ds ss，call jmp等指令使用到调用门时便遵循调用门解析跳转</p>
<p>2.jmp xx:aaaa 遵循xx的地址跳转</p>
<p>3.提权跳转，先解析需跳转地址，构造出对应的调用门</p>
<p>4.调用门结构中Segment Selector(段选择符)就是前面的符，以符来作为基地址跳转，所以在这里可以选择R0或R3层，进行提权</p>
<p>5.<code>jmp 在调用门 只能同权限跳转</code> | <code>retf 只能同权限或向低权限跳转</code> | <code>call 同权限或提权</code></p>
<h3 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h3><p>中断门作用是int系列或中断指令触发时，决定跳转到哪个地方来解决</p>
<p>具体框架在另一篇文章，这里只阐述注意点</p>
<p>1.中断门即int 1&#x2F;2&#x2F;3，当程序运行上述命令时，遵循中断门的跳转，类调用门</p>
<p>2.int xx 遵循xx的地址跳转</p>
<p>3.查看idt表，会发现，0 1 2 3会有对应可分析的中断门，每个单元都是int后对应的中断门，所以自己如果要增加中断门在32元素位置，那么中断门就是int 32</p>
<p>4.中断门的跳转极其类似调用门，所以不多记</p>
<h3 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h3><p>陷阱门≈中断门</p>
<p>陷阱门与中断门几乎一致，这里只阐述不同点</p>
<p>1.中断门清除eflag里的VM NT IF TF位</p>
<p>   陷阱门不清楚IF位，所以中断门会造成阻塞，需要iretd来返回，或者在进入中断门之前sti，陷阱门不必</p>
<h3 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h3><p>在不同段跳转的时候，比如R0跳R3这种跨段跳转的时候，栈(ss)环境和esp是会改变的，前面实验就能看出</p>
<p>所以任务门担任的就是承接作用						ps:框架越来越完善了</p>
<p>还是老规矩，这里只阐述注意点</p>
<ol>
<li></li>
</ol>
<h2 id="基于中断门的hook-int-3-hook"><a href="#基于中断门的hook-int-3-hook" class="headerlink" title="基于中断门的hook int 3 hook"></a>基于中断门的hook int 3 hook</h2><p>通过更改int 3对应cs段基地址然后触发int 3hook到自己的函数</p>
<h2 id="101012"><a href="#101012" class="headerlink" title="101012"></a>101012</h2><p>这里火哥的课就又开始”架空”起来了，很多新名词完全没有说过，看一下这篇文章-<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/102624243">101012部分</a>，火哥的课不行就跳过这一节，里面也说了”Cr3”</p>
<p>插个眼，这里<code>! process 0 0</code>这个指令还不太懂物理地址懂一半，之前搞项目那会学了一点，但是没太深入，我估计后面学页的时候可以相辅相成</p>
<p>前进一小步，文明一大步</p>
<p>——男厕</p>
<h2 id="页の前章"><a href="#页の前章" class="headerlink" title="页の前章"></a>页の前章</h2><h3 id="线性地址对应物理地址"><a href="#线性地址对应物理地址" class="headerlink" title="线性地址对应物理地址"></a>线性地址对应物理地址</h3><p>假如我在记事本中写了一串字符”helloworld”，然后用工具比如CE查找到该字符串在内存中的地址00484C58那么可以按照10-10-12的方式解析该虚拟地址的物理地址，所谓101012就是bit位排布，首先把000AE928换成二进制bit位形式0000 0000 0100 1000 0100 1100 0101 1000，然后划分</p>
<p>10	00 0000 0001		1	页目录	单位1*4byte	PDE</p>
<p>10	00 1000 0100		84	页表项	单位1*4byte	PTE</p>
<p>12	1100 0101 1000	C58	页内偏移	单位1byte</p>
<p>于是就可以找物理地址了，于是就弥补了前文的无知，cr3是什么？cr3就是改进程(书)地址的寄存器，代表了该书，用! process 0 0列举所有cr3的值找到notepad.exe，得到物理基地址03d75000  </p>
<p>! dd 03d75000来获取目录物理地址的值，目录中存放的是指针，也不难想到指针指向的地方就是书本内容的地方，比如这个要找的就是! dd 03d75000+1<em>4-&gt;3cbc7867，这里要去掉867，这个是页属性得到3cbc7000，这就是当前页的起始地址，再接着加上84</em>4，得到3d25b867，同理3d25b000，于是就可以看里面的内容了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !db 3d25b000+C58</span><br><span class="line">#3d25bc58 68 00 65 00 6c 00 6c 00-6f 00 77 00 6f 00 72 00 h.e.l.l.o.w.o.r.</span><br><span class="line">#3d25bc68 6c 00 64 00 31 00 31 00-00 00 00 00 00 00 00 00 l.d.1.1.........</span><br><span class="line">#3d25bc78 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................</span><br><span class="line">#3d25bc88 00 00 00 00 00 00 00 00-08 00 00 08 58 82 00 00 ............X...</span><br><span class="line">#3d25bc98 50 87 48 00 70 e9 47 00-06 00 00 06 5a 82 00 00 P.H.p.G.....Z...</span><br><span class="line">#3d25bca8 50 87 48 00 70 e9 47 00-00 00 00 00 04 00 3b 00 P.H.p.G.......;.</span><br><span class="line">#3d25bcb8 9b a1 37 7b 40 82 00 00-90 4a 48 00 68 09 48 00 ..7&#123;@....JH.h.H.</span><br><span class="line">#3d25bcc8 61 00 72 00 73 00 f6 ff-89 a1 36 68 4e 82 00 08 a.r.s.....6hN...</span><br></pre></td></tr></table></figure>



<h3 id="页属性"><a href="#页属性" class="headerlink" title="页属性"></a>页属性</h3><p>当直接查看CR3的时候，看到的后三位并不是0，其实这里代表的就是页属性<img src="/.io//tool\blog\source\postpic\windows1\12.png" loading="lazy"></p>
<p>可以对照该表</p>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>0代表无效</p>
<h4 id="US"><a href="#US" class="headerlink" title="US"></a>US</h4><p>1代表R3可访问，0代表R0才能访问</p>
<h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>是否被改变过，改变1</p>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>如果是1的话，是不会刷新缓存值的</p>
<p>没什么可记的，看完课就好 </p>
<h2 id="页の终章"><a href="#页の终章" class="headerlink" title="页の终章"></a>页の终章</h2><h3 id="挂页"><a href="#挂页" class="headerlink" title="挂页"></a>挂页</h3><p>VirtrualAlloc申请地址在赋值前是不会挂物理页的，在memset等操作进行之后才会赋值，又众所周知，0地址是不可赋值的，因为0地址没有挂物理页，那么就会有一种程序，给0地址挂页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// study05.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int *a = 0;</span><br><span class="line"></span><br><span class="line">    int * x = (int* )VirtualAlloc(NULL,0x100,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memset(x,0,0x100);</span><br><span class="line">    printf(&quot;%x\n&quot;,x);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    //手动挂页 </span><br><span class="line">    *a=100;</span><br><span class="line">    printf(&quot;%x\n&quot;,*x);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">这个还是很好玩的</span><br></pre></td></tr></table></figure>



<h3 id="页下"><a href="#页下" class="headerlink" title="页下"></a>页下</h3><p>这个感觉不太好记，比较散，应该也不容易忘就不急了，记脑子里</p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>虚拟页帧 物理页帧 attr属性 次数 PCID</p>
<p>本质是缓存，里面可以临时存储最近用过的联系？然后再次使用的时候可以先碰撞TLB，看看有没有现成的联系，没有再拆</p>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>l1pmoluy,1392181761@qq.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://l1pmoluy.github.io/2025/04/06/WindowsStudy01-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&amp;%E6%AE%B5%E6%A3%80%E6%B5%8B/" title="WindowsStudy01-保护机制&amp;段检测">https://l1pmoluy.github.io/2025/04/06/WindowsStudy01-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&%E6%AE%B5%E6%A3%80%E6%B5%8B/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2025/04/09/2025ghctf/" rel="prev" title="ghctf2025-re-wp"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">ghctf2025-re-wp</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2025/03/28/WindowsStudy00-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/" rel="next" title="WindowsStudy00-配置环境"><span class="post-nav-text">WindowsStudy00-配置环境</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2025 </span><a class="with-love" id="animate" href="https://l1pmoluy.github.io" title="l1pmoluy's blog"><span class="icon iconify" data-icon="ri:cloud-line"></span></a><span class="author"> l1pmoluy</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#f5b8d5" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://fastly.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://fastly.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js" type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></body></html>