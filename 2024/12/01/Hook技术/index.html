<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#f5b8d5"><meta name="author" content="l1pmoluy,1392181761@qq.com"><meta name="copyright" content="l1pmoluy"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>Hook技术 | l1pmoluy</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#f5b8d5"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"l1pmoluy.github.io","root":"/","title":"踏着梦走过时光","version":"1.10.11","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"hits":{"per_page":8}},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="l1pmoluy" type="application/atom+xml"><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="内核前置——Hook技术">
<meta property="og:type" content="article">
<meta property="og:title" content="Hook技术">
<meta property="og:url" content="https://l1pmoluy.github.io/2024/12/01/Hook%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="l1pmoluy">
<meta property="og:description" content="内核前置——Hook技术">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/l1pmoluy/l1pmoluy.github.io/master/postpic/Hook%E6%8A%80%E6%9C%AF/1.png">
<meta property="article:published_time" content="2024-12-01T12:01:05.000Z">
<meta property="article:modified_time" content="2025-10-08T13:43:31.797Z">
<meta property="article:author" content="l1pmoluy">
<meta property="article:tag" content="windows深度学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/l1pmoluy/l1pmoluy.github.io/master/postpic/Hook%E6%8A%80%E6%9C%AF/1.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="l1pmoluy"><img width="96" loading="lazy" src="/images/rika.jpg" alt="l1pmoluy"><span class="site-author-status" title="Looking for dawn.">🥰</span></a><div class="site-author-name"><a href="/about/">l1pmoluy</a></div><span class="site-name">l1pmoluy</span><sub class="site-subtitle">Dawing...</sub><div class="site-description">l1pmoluy's blog</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">17</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" title="1392181761" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://blog.csdn.net/dawn_ing_" title="csdn" target="_blank" style="color:#e83b07"><span class="icon iconify" data-icon="ri:terminal-box-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://bbs.kanxue.com/user-home-1012312.htm" title="看雪" target="_blank" style="color:#e83b07"><span class="icon iconify" data-icon="ri:snowflake-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="1392181761@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.yuque.com/l1pmpluy" title="语雀" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:yuque-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="友链" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:user-community-line"></span></a><a class="links-item hty-icon-button" href="/girl/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">总问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">地址问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Detour%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Detour函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TrampolineFun%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">TrampolineFun函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Hook分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%82%9F"><span class="toc-number">2.1.</span> <span class="toc-text">感悟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">为什么有问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">2.1.3.</span> <span class="toc-text">解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%88%B0%E7%9A%84%E5%A4%A7%E8%B7%B3%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">收集到的大跳字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inline-Hook"><span class="toc-number">2.2.</span> <span class="toc-text">Inline Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InlineHook-movjmp"><span class="toc-number">2.2.1.</span> <span class="toc-text">InlineHook-movjmp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">超详细解读程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AE%B5%E5%87%BD%E6%95%B0void-InlineHook"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text">第一段函数void InlineHook()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text">初始定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%89%8D14%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.1.3.3.</span> <span class="toc-text">读取前14字节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hook14%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.1.3.4.</span> <span class="toc-text">Hook14字节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%85%A5hook"><span class="toc-number">2.2.1.3.5.</span> <span class="toc-text">写入hook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InlineHook%E2%80%93HotPatch"><span class="toc-number">2.2.2.</span> <span class="toc-text">InlineHook–HotPatch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SetPrivilege"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text">SetPrivilege</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HOOKByHotpatch"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text">HOOKByHotpatch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InlineHook%E2%80%93call"><span class="toc-number">2.2.3.</span> <span class="toc-text">InlineHook–call</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84Hook"><span class="toc-number">2.3.</span> <span class="toc-text">基于异常处理的Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.3.</span> <span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">三种异常函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E9%83%A8%E5%88%86"><span class="toc-number">2.3.3.2.1.</span> <span class="toc-text">共同部分</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#VectoredHandler1"><span class="toc-number">2.3.3.2.2.</span> <span class="toc-text">VectoredHandler1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#VectoredHandler2"><span class="toc-number">2.3.3.2.3.</span> <span class="toc-text">VectoredHandler2</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#VectoredHandler3"><span class="toc-number">2.3.3.2.4.</span> <span class="toc-text">VectoredHandler3</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InstallVEHHook%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">InstallVEHHook函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Address-Hook%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89%EF%BC%88%E5%81%8F%E5%86%85%E6%A0%B8%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">Address Hook（待完善）（偏内核）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">各类表中的地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#DRIVER-OBJECT-%E7%9A%84-MajorFunction-%E5%8F%8AFasIo-%E6%B4%BE%E9%81%A3%E5%8E%86%E7%A8%8B%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.1.1.1.</span> <span class="toc-text">DRIVER_OBJECT 的 MajorFunction 及FasIo 派遣历程地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StartIo%E7%AD%89%E7%89%B9%E6%AE%8A%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.1.1.2.</span> <span class="toc-text">StartIo等特殊例程的地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#OBJECT-TYPE-%E4%B8%AD-OBJECT-TYPE-INITIALIZER%E5%8C%85%E5%90%AB%E7%9A%84%E5%90%84%E7%A7%8D%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.1.1.3.</span> <span class="toc-text">OBJECT_TYPE 中 _OBJECT_TYPE_INITIALIZER包含的各种处理过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">特殊寄存器中的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">特殊的函数指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IATHook"><span class="toc-number">2.4.2.</span> <span class="toc-text">IATHook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IAT"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">IAT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-3"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AE%B5"><span class="toc-number">2.4.2.4.1.</span> <span class="toc-text">第一段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AE%B5"><span class="toc-number">2.4.2.4.2.</span> <span class="toc-text">第二段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AE%B5"><span class="toc-number">2.4.2.4.3.</span> <span class="toc-text">第三段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0hook"><span class="toc-number">2.4.3.</span> <span class="toc-text">虚函数hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">虚函数表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-4"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-%E8%8E%B7%E5%8F%96%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E5%9C%B0%E5%9D%80"><span class="toc-number">2.4.3.4.1.</span> <span class="toc-text">步骤 1: 获取虚拟函数表地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">2.4.3.4.2.</span> <span class="toc-text">步骤 2: 修改虚拟函数表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3-%E6%81%A2%E5%A4%8D%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BF%AE%E6%94%B9"><span class="toc-number">2.4.3.4.3.</span> <span class="toc-text">步骤 3: 恢复虚拟函数表修改</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4-%E8%B0%83%E7%94%A8%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.4.4.</span> <span class="toc-text">步骤 4: 调用虚拟函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1hook%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">二次hook注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8DHook"><span class="toc-number">3.1.</span> <span class="toc-text">1.不Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%81%A2%E5%A4%8DHook%E5%89%8D%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">2.恢复Hook前的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8D%A2%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80Hook"><span class="toc-number">3.3.</span> <span class="toc-text">3.换个目标地址Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Hook%E4%B8%8A%E4%B8%80%E4%B8%AAHook%E8%BF%87%E7%A8%8B%E7%9A%84Detour%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">4.Hook上一个Hook过程的Detour函数</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#f5b8d5;"><link itemprop="mainEntityOfPage" href="https://l1pmoluy.github.io/2024/12/01/Hook%E6%8A%80%E6%9C%AF/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="l1pmoluy,1392181761@qq.com"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="l1pmoluy"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hook技术</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2024-12-1 20:01:05" itemprop="dateCreated datePublished" datetime="2024-12-01T20:01:05+08:00">2024-12-1</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2025-10-8 21:43:31" itemprop="dateModified" datetime="2025-10-08T21:43:31+08:00">2025-10-8</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">11.1k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">51m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/" style="--text-color:#FF0000" itemprop="url" rel="index"><span itemprop="text">逆向行驶</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="--text-color:#416482"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">windows深度学习</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><p>内核前置——Hook技术</p>
<span id="more"></span>


<h2 id="总问题"><a href="#总问题" class="headerlink" title="总问题"></a>总问题</h2><h3 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h3><p>这个我遇到过几次，首先：</p>
<p><strong>地址大小</strong>： 在 32 位系统中，指针的大小是 4 字节，而在 64 位系统中，指针的大小是 8 字节。因此，对于 64 位系统，函数的地址计算、指针运算需要使用 64 位大小的地址。  </p>
<p>所以网上的脚本有些是32位脚本，无法运行的话就要考虑这个</p>
<h3 id="Detour函数"><a href="#Detour函数" class="headerlink" title="Detour函数"></a>Detour函数</h3><p><code>Detour</code> 函数一般指的是在程序执行过程中，修改或替换某个函数的执行路径的技术，也叫做 <strong>函数钩子（Function Hooking）</strong> 或 <strong>函数劫持（Function Detouring）</strong>。这个过程允许我们在不改变原函数代码的情况下，插入自定义的逻辑或代码。  </p>
<h3 id="TrampolineFun函数"><a href="#TrampolineFun函数" class="headerlink" title="TrampolineFun函数"></a>TrampolineFun函数</h3><p>该函数不是一个完整的函数，是调用原函数的入口</p>
<h2 id="Hook分类"><a href="#Hook分类" class="headerlink" title="Hook分类"></a>Hook分类</h2><p>对于hook，我们不难发现，大致可以分为两种类型，一种是对引用函数的地址进行操作，另一种是对引用函数的地址的内容进行操作</p>
<p>举个例子，下面是一个c语言程序，目的是将原本打印的A换成B</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintChar</span><span class="params">(<span class="type">char</span>* pch)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address=0x%x  Char=%c\n&quot;</span>, pch, *pch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	<span class="type">char</span>* pChar;</span><br><span class="line">	pChar = &amp;ch;</span><br><span class="line">	PrintChar(pChar);					<span class="comment">//Address=0x84cff704  Char=A</span></span><br><span class="line">	<span class="comment">//Adress hook</span></span><br><span class="line">	pChar = &amp;ch2;</span><br><span class="line">	PrintChar(pChar);					<span class="comment">//Address=0x84cff724  Char=B</span></span><br><span class="line">	pChar = &amp;ch;</span><br><span class="line">	<span class="comment">//Inline hook</span></span><br><span class="line">	*pChar = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	PrintChar(pChar);					<span class="comment">//Address=0x84cff704  Char=B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过三种结果不难看出，第一种方法是通过改变地址，实现的打印改变，第二种不改变地址，但是改变指针指向的值</p>
<p>在这个简单的例子之后，去了解别的Hook方式就不难了。名目繁多的Hook，总结起来其实只有两种：</p>
<p><strong>Address Hook</strong> 和** Inline Hook**</p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>在InlineHook这里，学习的很多，感觉比之前悟了很多</p>
<p>hook原理就是跳跳跳</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>那么首先第一个我卡住的是HotPatch Hook</p>
<p>这个hook遇到的问题就是跳转的时候，距离太大了，源地址：<code>00007FFE556D61B6</code> ，跳转地址是<code>000000014001213B</code>，就是一个是APT函数，一个是自己写的hook函数，距离太远了所以跳转实现不了</p>
<p>第二个遇到问题是在InlineHook里面的InlineHook，其中本来应该，小跳到IAT表中地址然后对地址跳转，通过hook后变成小跳到申请的地址中，对地址中的地址挑战，但遇到的问题和上面一样</p>
<h4 id="为什么有问题"><a href="#为什么有问题" class="headerlink" title="为什么有问题"></a>为什么有问题</h4><p>对于一个64位程序来说，一个普普通通的程序开始的地方，都在<code>1 40 00 00 00</code>如此的高地址起步，IAT表一般都会在非常非常高的位置如<code>00007FFE556D61B6</code> ，然而自己申请的地址又在十分低的位置，这样想实现通过本来的小跳转实现hook就很艰难了</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>对于这些的解决，其实就是找64位程序的跳转方法，找实现远距离大跳的字节码，基本都是得通过修改字节码来实现跳转了（除非这两个很近）</p>
<h4 id="收集到的大跳字节码"><a href="#收集到的大跳字节码" class="headerlink" title="收集到的大跳字节码"></a>收集到的大跳字节码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x48</span>,<span class="number">0xB8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,  <span class="comment">//mov rax,xxx</span></span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xE0</span>			                                <span class="comment">//jmp rax </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x68</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span><span class="comment">//push 000000</span></span><br><span class="line"><span class="number">0xc7</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span><span class="comment">//mov dword ptr [rsp+4],00000000</span></span><br><span class="line"><span class="number">0xc3</span>					<span class="comment">//retn</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span>,<span class="number">0x25</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span><span class="comment">//jmp qword ptr [00000000 00000000]</span></span><br></pre></td></tr></table></figure>

<p>这个可以跳的很远，但是计算的是偏移</p>
<h3 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h3><p>Inline Hook是指直接修改指令的hook</p>
<p>因为其关键是转移程序的执行流程，所以一般是用jmp、call、retn之类的转移指令</p>
<p>那么根据不同场合会有不同的改变指令方式，如下是五种模式：</p>
<p>1.jmp xxxxxxxx（5字节）</p>
<p>直接跳转</p>
<p>2.push xxxxxxxx（6字节）</p>
<p>   retn</p>
<p>压栈返回实现跳转</p>
<p>3.mov eax,xxxxxxxx 	(7字节)</p>
<p>   jmp eax</p>
<p>先将转移地址放入寄存器，在实现跳转（注：这里使用eax寄存器是因为eax通常用于存储返回值，在函数开始时不会影响什么）</p>
<p>4.call Hook（更换指令或输入表）</p>
<p>5.HotPatch Hook</p>
<p>这个要细说，重新开一个hook</p>
<h4 id="InlineHook-movjmp"><a href="#InlineHook-movjmp" class="headerlink" title="InlineHook-movjmp"></a>InlineHook-movjmp</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/142621824">https://zhuanlan.zhihu.com/p/142621824</a></p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>原理大致是，在一个API函数开始前，会有一个call函数执行，我们通过改变API函数的构造，来做到hook</p>
<p>以<code>MessageBoxA</code>举例，这是API函数，所以在这个函数所在模块会记录这个函数如果被调用的话全过程是什么，这个函数正常执行流程是<code>call MessageBoxA</code>，那么在这个模块中，<code>MessageBoxAadress</code>部分第一项就会使<code>call MessageBoxA</code>，所以我们用过使用API函数所在模块的句柄，获得函数地址，再通过函数地址，使用  <code>WriteProcessMemory</code>函数写入准备好的同字节大小跳转函数，即可完成hook</p>
<p><img src="https://raw.githubusercontent.com/l1pmoluy/l1pmoluy.github.io/master/postpic/Hook%E6%8A%80%E6%9C%AF/1.png" loading="lazy"></p>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改API入口为 mov rax, JmpAddr;jmp rax 是程序能跳转到自己的函数</span></span><br><span class="line">BYTE __NewCode[<span class="number">14</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xB8</span> &#125;;  <span class="comment">// mov rax, JmpAddr 和 jmp rax</span></span><br><span class="line">BYTE __OldCode[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 存储MessageBoxA原始代码</span></span><br><span class="line"></span><br><span class="line">FARPROC __MessageBoxAddress;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,        <span class="comment">// handle to owner window</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpText,   <span class="comment">// text in message box</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption, <span class="comment">// message box title</span></span></span><br><span class="line"><span class="params">    UINT uType        <span class="comment">// message box style</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InlineHook</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InlineHook();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用MessageBoxA测试一下。</span></span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hModule_User32 = LoadLibrary(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    __MessageBoxAddress = GetProcAddress(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印MessageBoxA的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__MessageBoxAddress is %p\n&quot;</span>, __MessageBoxAddress);</span><br><span class="line">    <span class="comment">// MyMessageBoxA的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MyMessageBoxA Addr is %p\n&quot;</span>, MyMessageBoxA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读MessageBoxA函数的前6个字节</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, GetCurrentProcessId());</span><br><span class="line">    <span class="keyword">if</span> (ReadProcessMemory(hProcess, __MessageBoxAddress, __OldCode, <span class="number">14</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadProcessMemory error\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印原始MessageBoxA的代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__OldCode is &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, __OldCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DWORD64 JmpAddress = (DWORD64)MyMessageBoxA;  <span class="comment">// 64 位地址</span></span><br><span class="line">    <span class="comment">// 构造新头部代码</span></span><br><span class="line">    __NewCode[<span class="number">0</span>] = <span class="number">0x48</span>;  <span class="comment">// 64 位操作的前缀</span></span><br><span class="line">    __NewCode[<span class="number">1</span>] = <span class="number">0xB8</span>;  <span class="comment">// mov rax, [JmpAddr]</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;__NewCode[<span class="number">2</span>], &amp;JmpAddress, <span class="number">8</span>);   <span class="comment">// 将 64 位地址写入</span></span><br><span class="line">    __NewCode[<span class="number">10</span>] = <span class="number">0xFF</span>;  <span class="comment">// jmp rax</span></span><br><span class="line">    __NewCode[<span class="number">11</span>] = <span class="number">0xE0</span>;  <span class="comment">// jmp rax</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印新代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NewBytes are &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, __NewCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 去内存保护</span></span><br><span class="line">    VirtualProtectEx(hProcess, (LPVOID)__MessageBoxAddress, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入跳转，开始Hook</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess, __MessageBoxAddress, __NewCode, <span class="number">14</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory error\n&quot;</span>);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复内存保护</span></span><br><span class="line">    VirtualProtectEx(hProcess, (LPVOID)__MessageBoxAddress, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,        <span class="comment">// handle to owner window</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpText,   <span class="comment">// text in message box</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption, <span class="comment">// message box title</span></span></span><br><span class="line"><span class="params">    UINT uType        <span class="comment">// message box style</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA 已经被Hook\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始的API代码</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, GetCurrentProcessId());</span><br><span class="line">    DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">    VirtualProtectEx(hProcess, (LPVOID)__MessageBoxAddress, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    WriteProcessMemory(hProcess, (LPVOID)__MessageBoxAddress, (LPVOID)__OldCode, <span class="number">14</span>, <span class="literal">NULL</span>);</span><br><span class="line">    VirtualProtectEx(hProcess, (LPVOID)__MessageBoxAddress, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">// 调用正确的函数</span></span><br><span class="line">    <span class="type">int</span> ret = MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入跳转语句，继续Hook</span></span><br><span class="line">    WriteProcessMemory(hProcess, (LPVOID)__MessageBoxAddress, (LPVOID)__NewCode, <span class="number">14</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="超详细解读程序"><a href="#超详细解读程序" class="headerlink" title="超详细解读程序"></a>超详细解读程序</h5><h6 id="第一段函数void-InlineHook"><a href="#第一段函数void-InlineHook" class="headerlink" title="第一段函数void InlineHook()"></a>第一段函数<code>void InlineHook()</code></h6><h6 id="初始定义"><a href="#初始定义" class="headerlink" title="初始定义"></a>初始定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule_User32 = LoadLibrary(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">__MessageBoxAddress = GetProcAddress(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"><span class="comment">//打印MessageBoxA的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;__MessageBoxAddress is %x\n&quot;</span>, __MessageBoxAddress);</span><br><span class="line"><span class="comment">//MyMessageBoxA的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MyMessageBoxA Addr is %x\n&quot;</span>, MyMessageBoxA);</span><br></pre></td></tr></table></figure>

<p>先获得user32.dll模块的句柄，再用句柄获得模块中MessageBoxA函数的地址，同时打印MyMessageBox的地址和MessageBoxA的地址</p>
<h6 id="读取前14字节"><a href="#读取前14字节" class="headerlink" title="读取前14字节"></a>读取前14字节</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读MessageBoxA函数的前14个字节</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, GetCurrentProcessId());</span><br><span class="line"><span class="keyword">if</span> (ReadProcessMemory(hProcess, __MessageBoxAddress, __OldCode, <span class="number">14</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ReadProcessMemory error\n&quot;</span>);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印原始MessageBoxA的代码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;__OldCode is &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, __OldCode[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里先读取MessageBoxA函数里的前十四个字节，存储在_OldCode中，在打印前十四字节</p>
<p>解析一下<code>ReadProcessMemory</code>函数： 用于从指定进程的内存空间中读取数据。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,      <span class="comment">// 目标进程的句柄</span></span></span><br><span class="line"><span class="params">  LPCVOID lpBaseAddress, <span class="comment">// 目标内存的起始地址</span></span></span><br><span class="line"><span class="params">  LPVOID  lpBuffer,      <span class="comment">// 存储读取数据的缓冲区</span></span></span><br><span class="line"><span class="params">  SIZE_T  nSize,         <span class="comment">// 要读取的字节数</span></span></span><br><span class="line"><span class="params">  SIZE_T *lpNumberOfBytesRead <span class="comment">// 实际读取的字节数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="Hook14字节"><a href="#Hook14字节" class="headerlink" title="Hook14字节"></a>Hook14字节</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 JmpAddress = (DWORD64)MyMessageBoxA;  <span class="comment">// 64 位地址</span></span><br><span class="line"><span class="comment">// 构造新头部代码</span></span><br><span class="line">__NewCode[<span class="number">0</span>] = <span class="number">0x48</span>;  <span class="comment">// 64 位操作的前缀</span></span><br><span class="line">__NewCode[<span class="number">1</span>] = <span class="number">0xB8</span>;  <span class="comment">// mov rax, [JmpAddr]</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;__NewCode[<span class="number">2</span>], &amp;JmpAddress, <span class="number">8</span>);   <span class="comment">// 将 64 位地址写入</span></span><br><span class="line">__NewCode[<span class="number">10</span>] = <span class="number">0xFF</span>;  <span class="comment">// jmp rax</span></span><br><span class="line">__NewCode[<span class="number">11</span>] = <span class="number">0xE0</span>;  <span class="comment">// jmp rax</span></span><br><span class="line"><span class="comment">// 打印新代码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NewBytes are &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, __NewCode[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这些作用就是用十四字节实现，mov eax MyMessageBoxA  jmp eax，于是函数就被hook成自己的函数了，创造之后看看字节码对不对</p>
<h6 id="写入hook"><a href="#写入hook" class="headerlink" title="写入hook"></a>写入hook</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DWORD dwOldProtect = 0; //旧保护属性</span></span><br><span class="line"><span class="comment">// 去内存保护</span></span><br><span class="line">::VirtualProtect(__MessageBoxAddress, <span class="number">14</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"><span class="comment">//写入跳转，开始Hook</span></span><br><span class="line">WriteProcessMemory(INVALID_HANDLE_VALUE, __MessageBoxAddress, __NewCode, <span class="number">14</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 写内存保护</span></span><br><span class="line">::VirtualProtect(__MessageBoxAddress, <span class="number">14</span>, dwOldProtect, &amp;dwOldProtect);</span><br></pre></td></tr></table></figure>

<p>这个其实没啥好说的看注释就好，函数猜的话也猜出来了，于是这段函数就结束了</p>
<p>于是程序返回执行MessageBoxA，本来应该call MassageBoxA，变成了mov与jmp，hook成了进入自己的函数</p>
<h4 id="InlineHook–HotPatch"><a href="#InlineHook–HotPatch" class="headerlink" title="InlineHook–HotPatch"></a>InlineHook–HotPatch</h4><p>一般的hook需要5字节，lock 什么的，也最多同时操作4字节，如果要修改5字节，严格说来是要使用同步的，以防止其他CPU访问正被修改的指令。</p>
<p>hotpatch的技法则是首先在函数上方，一般会因为对齐，或者编译时使用&#x2F;hotpatch选项而预留出几字节的空间，首先在这些空间里写入一个5字节的远程跳转，然后再将函数的俩字节mov edi，edi指令换成一个近跳转，跳到上方的长跳转中，2字节的修改。此种技法完全不用考虑同步…</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xDragonx_/article/details/6241448">hotpatch 的hook 方式_hotpatch hook-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30384217/article/details/95490108">“热补丁”Hook，多线程下InlineHook解决方法-CSDN博客</a></p>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HotPatch.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;stdafx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pfnCreateprocessW)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFO lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">HOOKByHotpatch</span><span class="params">(LPWSTR wzDllName, LPCSTR szFuncName, PROC pfnNewFunc)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">UnhookByHotpatch</span><span class="params">(LPWSTR wzDllName, LPCSTR szFuncName)</span></span>;</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">NewCreateProcessW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFO lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetPrivilege</span>(SE_DEBUG_NAME, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hook</span></span><br><span class="line">    <span class="type">wchar_t</span> moduleName[] = <span class="string">L&quot;kernel32.dll&quot;</span>;  <span class="comment">// 创建一个非常量的数组</span></span><br><span class="line">    <span class="built_in">HOOKByHotpatch</span>(moduleName, <span class="string">&quot;CreateProcessW&quot;</span>, (PROC)NewCreateProcessW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_SHOW;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    TCHAR cmdLine[MAXBYTE] = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">    BOOL bOk = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, cmdLine,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> wzDllName[] = <span class="string">L&quot;kernel32.dll&quot;</span>;  <span class="comment">// 创建一个非常量宽字符数组</span></span><br><span class="line">    <span class="built_in">UnhookByHotpatch</span>(wzDllName, <span class="string">&quot;CreateProcessW&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES TokenPrivileges;<span class="comment">//权限令牌</span></span><br><span class="line">    HANDLE TokenHandle = <span class="literal">NULL</span>;       <span class="comment">//权限令牌句柄</span></span><br><span class="line">    LUID   Luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">        &amp;TokenHandle))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>,             <span class="comment">// lookup privilege on local system</span></span><br><span class="line">        lpszPrivilege,    <span class="comment">// privilege to lookup </span></span><br><span class="line">        &amp;Luid))           <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    TokenPrivileges.Privileges[<span class="number">0</span>].Luid = Luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        TokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TokenPrivileges.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="comment">//调整权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(TokenHandle,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;TokenPrivileges,</span><br><span class="line">        <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hootpatch，将函数首字节改为 short jmp（EB F9）</span></span><br><span class="line"><span class="function">BOOL <span class="title">HOOKByHotpatch</span><span class="params">(LPWSTR wzDllName, LPCSTR szFuncName, PROC pfnNewFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pOrgFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD   dwOldProtect, dwAddress;</span><br><span class="line">    BYTE    pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    BYTE    pBuf2[<span class="number">2</span>] = &#123; <span class="number">0xEB</span>, <span class="number">0xF9</span> &#125;;</span><br><span class="line">    PBYTE   pByte;</span><br><span class="line"></span><br><span class="line">    pOrgFuncAddr = (FARPROC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(wzDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pOrgFuncAddr;</span><br><span class="line">    <span class="comment">//判断是否被勾</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xEB</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将前五字节代码改为可读可写</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. NOP (0x90)</span></span><br><span class="line">    <span class="comment">//将前五字节改为E8 xxxxxxxx</span></span><br><span class="line">    dwAddress = (DWORD)pfnNewFunc - (DWORD)pOrgFuncAddr;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. MOV EDI, EDI (0x8BFF)</span></span><br><span class="line">    <span class="comment">//将函数前两个字节改为EB F9</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgFuncAddr, pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), <span class="number">7</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnhookByHotpatch</span><span class="params">(LPWSTR wzDllName, LPCSTR szFuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pHookFunc = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD   dwOldProtect;</span><br><span class="line">    PBYTE   pByte;</span><br><span class="line">    BYTE    pBuf[<span class="number">5</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;</span><br><span class="line">    BYTE    pBuf2[<span class="number">2</span>] = &#123; <span class="number">0x8B</span>, <span class="number">0xFF</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pHookFunc = (FARPROC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(wzDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pHookFunc;</span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xEB</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)pHookFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. NOP (0x90)</span></span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD)pHookFunc - <span class="number">5</span>), pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. MOV EDI, EDI (0x8BFF)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pHookFunc, pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)pHookFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">NewCreateProcessW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFO lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Hook&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>老规矩，按照主函数调用顺序分析</p>
<h6 id="SetPrivilege"><a href="#SetPrivilege" class="headerlink" title="SetPrivilege"></a>SetPrivilege</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TOKEN_PRIVILEGES TokenPrivileges;<span class="comment">//权限令牌</span></span><br><span class="line">    HANDLE TokenHandle = <span class="literal">NULL</span>;       <span class="comment">//权限令牌句柄</span></span><br><span class="line">    LUID   Luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">        &amp;TokenHandle))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>,             <span class="comment">// lookup privilege on local system</span></span><br><span class="line">        lpszPrivilege,    <span class="comment">// privilege to lookup </span></span><br><span class="line">        &amp;Luid))           <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    TokenPrivileges.Privileges[<span class="number">0</span>].Luid = Luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        TokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TokenPrivileges.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="comment">//调整权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(TokenHandle,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;TokenPrivileges,</span><br><span class="line">        <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置权限函数</p>
<h6 id="HOOKByHotpatch"><a href="#HOOKByHotpatch" class="headerlink" title="HOOKByHotpatch"></a>HOOKByHotpatch</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">HOOKByHotpatch</span><span class="params">(LPWSTR wzDllName, LPCSTR szFuncName, PROC pfnNewFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pOrgFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD   dwOldProtect, dwAddress;</span><br><span class="line">    BYTE    pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    BYTE    pBuf2[<span class="number">2</span>] = &#123; <span class="number">0xEB</span>, <span class="number">0xF9</span> &#125;;</span><br><span class="line">    PBYTE   pByte;</span><br><span class="line"></span><br><span class="line">    pOrgFuncAddr = (FARPROC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(wzDllName), szFuncName);</span><br><span class="line">    pByte = (PBYTE)pOrgFuncAddr;</span><br><span class="line">    <span class="comment">//判断是否被勾</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xEB</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将前五字节代码改为可读可写</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. NOP (0x90)</span></span><br><span class="line">    <span class="comment">//将前五字节改为E8 xxxxxxxx</span></span><br><span class="line">    dwAddress = (DWORD)pfnNewFunc - (DWORD)pOrgFuncAddr;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. MOV EDI, EDI (0x8BFF)</span></span><br><span class="line">    <span class="comment">//将函数前两个字节改为EB F9</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgFuncAddr, pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD)pOrgFuncAddr - <span class="number">5</span>), <span class="number">7</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里一直在报错一直搞不定，等开始写项目了回来修补，大致意思看两遍就知道了</p>
<h4 id="InlineHook–call"><a href="#InlineHook–call" class="headerlink" title="InlineHook–call"></a>InlineHook–call</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>这里分为两种，我们知道在运行一个函数之前，会<code>call &lt;你用的函数&gt;</code>，所以在这里改动，使其变成</p>
<p><code>call &lt;我的函数&gt;</code></p>
<p>如果调用的是IAT函数，将先使用 <code>FF 15 &lt;IAT表&gt;</code>，对IAT表中的函数地址，实现跳转，由此我们可以自己先申请一块地址，再把自己写的函数放在地址上，实现跳转，就相当于和上文一样实现了<code>FF 15 &lt;申请的地址表&gt;</code>，对自己申请的地址中存放的地址，实现跳转，不过这里会出现问题我都会在感悟中提到</p>
<p>如果用的是E8call跳转，那就直接换E8后面的值就好</p>
<h3 id="基于异常处理的Hook"><a href="#基于异常处理的Hook" class="headerlink" title="基于异常处理的Hook"></a>基于异常处理的Hook</h3><p>这个比我想象的好玩</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><strong>向量化异常处理（Vectored Exception Handling，VEH）</strong>：这是一个扩展的异常处理机制，允许注册异常处理程序，以便在程序发生异常时接管处理。  </p>
<p>手动的对你接下来要进行的函数设置断点（0xCC），在捕获异常后用自己的方法修复异常，在修复的时候就可以进项hook了</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">第13章  Hook技术</span></span><br><span class="line"><span class="comment">《加密与解密（第四版）》</span></span><br><span class="line"><span class="comment">(c)  看雪学院 www.kanxue.com 2000-2018</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VEHHook.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetBreakPoint</span><span class="params">(PVOID pFuncAddr)</span>;</span><br><span class="line">BOOL <span class="title function_">ClearBreakPoint</span><span class="params">(PVOID pFuncAddr)</span>;</span><br><span class="line">BOOL <span class="title function_">InstallVEHHook</span><span class="params">(PVECTORED_EXCEPTION_HANDLER Handler)</span>;</span><br><span class="line">VOID <span class="title function_">UnInstallVEHHook</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> </span><br><span class="line"><span class="params">(WINAPI *PFN_MessageBox)</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">My_MessageBox</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">LONG WINAPI <span class="title function_">VectoredHandler1</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo)</span>;</span><br><span class="line">LONG WINAPI <span class="title function_">VectoredHandler2</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo)</span>;</span><br><span class="line">LONG WINAPI <span class="title function_">VectoredHandler3</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo)</span>;</span><br><span class="line">VOID <span class="title function_">ShowMsgBox</span><span class="params">(LPCTSTR lpMsg)</span>;</span><br><span class="line">ULONG_PTR <span class="title function_">InitTrampolineFun</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">PFN_MessageBox g_OriginalMessageBoxA;</span><br><span class="line">PVOID g_AddrofMessageBoxA = <span class="number">0</span> ;</span><br><span class="line">PVOID g_hVector;</span><br><span class="line">BYTE  g_OldCode[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hUser32 = LoadLibrary(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	g_AddrofMessageBoxA =  (PVOID)GetProcAddress(hUser32,<span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address of MessageBoxA = 0x%p\n&quot;</span>,g_AddrofMessageBoxA);</span><br><span class="line">	g_OriginalMessageBoxA = (PFN_MessageBox)InitTrampolineFun();  <span class="comment">//跳过开头的Hook</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler1 = 0x%p\n&quot;</span>,VectoredHandler1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler2 = 0x%p\n&quot;</span>,VectoredHandler2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler3 = 0x%p\n&quot;</span>,VectoredHandler3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择安装一个进行测试</span></span><br><span class="line">	InstallVEHHook(VectoredHandler2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置断点</span></span><br><span class="line">	SetBreakPoint(g_AddrofMessageBoxA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//call</span></span><br><span class="line">	ShowMsgBox(<span class="string">&quot;VEH Hook Test.&quot;</span>);</span><br><span class="line">	<span class="comment">//ShowMsgBox(&quot;uihae&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;All Finished!\n&quot;</span>);</span><br><span class="line">	ClearBreakPoint(g_AddrofMessageBoxA);</span><br><span class="line">	UnInstallVEHHook();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	ShowMsgBox(<span class="string">&quot;Hook Cleared&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">ShowMsgBox</span><span class="params">(LPCTSTR lpMsg)</span></span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>,lpMsg,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG_PTR <span class="title function_">InitTrampolineFun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG_PTR uResult = <span class="number">0</span> ;</span><br><span class="line">	PBYTE pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">	<span class="comment">//x64需要申请shellcode</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	USER32!MessageBoxA:</span></span><br><span class="line"><span class="comment">	00000000`779412b8 4883ec38        sub     rsp,38h</span></span><br><span class="line"><span class="comment">	00000000`779412bc 4533db          xor     r11d,r11d</span></span><br><span class="line"><span class="comment">	00000000`779412bf 44391d760e0200  cmp     dword ptr [USER32!gapfnScSendMessage+0x927c (00000000`7796213c)],r11d</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pFun = (PBYTE)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">128</span>,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	uResult = (ULONG_PTR)pFun;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;uResult:%p\n&quot;</span>, uResult);</span><br><span class="line">	<span class="built_in">memset</span>(pFun,<span class="number">0</span>,<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(pFun,(PVOID)g_AddrofMessageBoxA,<span class="number">4</span>); <span class="comment">//拷贝第一条指令，4字节,推荐使用反汇编引擎来实际计算</span></span><br><span class="line">	pFun += <span class="number">4</span> ; <span class="comment">//下一条指令构造为jmp [xxxxxx]</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pFun:%p\n&quot;</span>, pFun);</span><br><span class="line">	pFun[<span class="number">0</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	pFun[<span class="number">1</span>] = <span class="number">0x25</span>;</span><br><span class="line">	<span class="comment">//这里相当于把原函数后面4个字节后面的内容给保存下来，好跳转。</span></span><br><span class="line">	*(ULONG_PTR*)(pFun + <span class="number">6</span>) = (ULONG_PTR)g_AddrofMessageBoxA + <span class="number">4</span> ; <span class="comment">//跳回到原函数加4的地方</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//x86,第一条指令是mov edi,edi,直接跳过即可</span></span><br><span class="line">	uResult = (ULONG_PTR)g_AddrofMessageBoxA + <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> uResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理方式，修改参数并返回原函数继续执行</span></span><br><span class="line">LONG WINAPI</span><br><span class="line"><span class="title function_">VectoredHandler1</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *szNewMsg =  <span class="string">&quot;[VectoredHandler1] Hacked by pediy.com&quot;</span>;</span><br><span class="line">	LONG lResult = EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">	PEXCEPTION_RECORD pExceptionRecord = ExceptionInfo-&gt;ExceptionRecord;</span><br><span class="line">	PCONTEXT pContextRecord = ExceptionInfo-&gt;ContextRecord;</span><br><span class="line">	ULONG_PTR* uESP = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Exception Address = %p\n&quot;</span>,pExceptionRecord-&gt;ExceptionAddress);</span><br><span class="line">	<span class="keyword">if</span> (pExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT</span><br><span class="line">		&amp;&amp; pExceptionRecord-&gt;ExceptionAddress == g_AddrofMessageBoxA)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">		<span class="comment">//x64上前四个参数依次为RCX,RDX,R8,R9</span></span><br><span class="line">		<span class="comment">//修改第二个参数，即LpMsg</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;lpText = 0x%p   %s\n&quot;</span>,pContextRecord-&gt;Rdx,(<span class="type">char</span>*)pContextRecord-&gt;Rdx);</span><br><span class="line">		pContextRecord-&gt;Rdx = (ULONG_PTR)szNewMsg;</span><br><span class="line">		pContextRecord-&gt;Rip = (ULONG_PTR)g_OriginalMessageBoxA ; <span class="comment">//跳到Trampoline继续执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		0012FF70   0040105A   /CALL 到 MessageBoxA 来自 VEHHook.00401054</span></span><br><span class="line"><span class="comment">		0012FF74   00000000   |hOwner = NULL</span></span><br><span class="line"><span class="comment">		0012FF78   00407030   |Text = &quot;VEH Hook&quot;</span></span><br><span class="line"><span class="comment">		0012FF7C   0040703C   |Title = &quot;Test&quot;</span></span><br><span class="line"><span class="comment">		0012FF80   00000000   \Style = MB_OK|MB_APPLMODAL</span></span><br><span class="line"><span class="comment">		0012FF84   00401225   返回到 VEHHook.&lt;ModuleEntryPoint&gt;+0B4 来自 VEHHook.00401000</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ESP = 0x%p\n&quot;</span>,pContextRecord-&gt;Esp) ;</span><br><span class="line">		uESP = (ULONG_PTR*)pContextRecord-&gt;Esp ; <span class="comment">//取中断时的ESP</span></span><br><span class="line">		uESP[<span class="number">2</span>] = (ULONG_PTR)szNewMsg; <span class="comment">//修改栈中的参数</span></span><br><span class="line">		pContextRecord-&gt;Eip = (ULONG_PTR)g_OriginalMessageBoxA ; <span class="comment">//跳过函数开头</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">		lResult = EXCEPTION_CONTINUE_EXECUTION ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> lResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理方式：直接调用原函数并替原函数返回</span></span><br><span class="line">LONG WINAPI</span><br><span class="line"><span class="title function_">VectoredHandler2</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *szNewMsg =  <span class="string">&quot;[VectoredHandler2] Hacked by pediy.com&quot;</span>;</span><br><span class="line">	LONG lResult = EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">	PEXCEPTION_RECORD pExceptionRecord = ExceptionInfo-&gt;ExceptionRecord;</span><br><span class="line">	PCONTEXT pContextRecord = ExceptionInfo-&gt;ContextRecord;</span><br><span class="line">	ULONG_PTR* uESP = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT</span><br><span class="line">		&amp;&amp; pExceptionRecord-&gt;ExceptionAddress == g_AddrofMessageBoxA)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">		<span class="comment">//x64上前四个参数依次为RCX,RDX,R8,R9</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RSP = 0x%p\n&quot;</span>,pContextRecord-&gt;Rsp) ;</span><br><span class="line">		uESP = (ULONG_PTR*)pContextRecord-&gt;Rsp ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Return Address = 0x%p\n&quot;</span>,uESP[<span class="number">0</span>]);</span><br><span class="line">		ret = g_OriginalMessageBoxA((HWND)pContextRecord-&gt;Rcx,szNewMsg,(LPCTSTR)pContextRecord-&gt;R8,(<span class="type">int</span>)pContextRecord-&gt;R9);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line">		<span class="comment">//修正RSP</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RSP(before) = 0x%p\n&quot;</span>, pContextRecord-&gt;Rsp);</span><br><span class="line">		pContextRecord-&gt;Rsp += <span class="keyword">sizeof</span>(ULONG_PTR);<span class="comment">//参数在寄存器中，栈中无参数，仅需跳过返回地址</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RSP(after) = 0x%p\n&quot;</span>, pContextRecord-&gt;Rsp);</span><br><span class="line">		<span class="comment">//直接返回到调用者处</span></span><br><span class="line">		pContextRecord-&gt;Rip = uESP[<span class="number">0</span>] ;<span class="comment">//设置EIP为返回地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		0012FF70   0040105A   /CALL 到 MessageBoxA 来自 VEHHook.00401054</span></span><br><span class="line"><span class="comment">		0012FF74   00000000   |hOwner = NULL</span></span><br><span class="line"><span class="comment">		0012FF78   00407030   |Text = &quot;VEH Hook&quot;</span></span><br><span class="line"><span class="comment">		0012FF7C   0040703C   |Title = &quot;Test&quot;</span></span><br><span class="line"><span class="comment">		0012FF80   00000000   \Style = MB_OK|MB_APPLMODAL</span></span><br><span class="line"><span class="comment">		0012FF84   00401225   返回到 VEHHook.&lt;ModuleEntryPoint&gt;+0B4 来自 VEHHook.00401000</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ESP = 0x%p\n&quot;</span>,pContextRecord-&gt;Esp) ;</span><br><span class="line">		uESP = (ULONG_PTR*)pContextRecord-&gt;Esp ;</span><br><span class="line">		ret = g_OriginalMessageBoxA((HWND)uESP[<span class="number">1</span>],szNewMsg,(LPCTSTR)uESP[<span class="number">3</span>],(<span class="type">int</span>)uESP[<span class="number">4</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//直接返回到调用者处</span></span><br><span class="line">		pContextRecord-&gt;Eip = uESP[<span class="number">0</span>] ;<span class="comment">//设置EIP为返回地址</span></span><br><span class="line">		pContextRecord-&gt;Esp += (<span class="number">4</span> + <span class="number">1</span>)*<span class="keyword">sizeof</span>(ULONG_PTR); <span class="comment">//4为参数个数,1为返回地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">		lResult = EXCEPTION_CONTINUE_EXECUTION ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> lResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理方式：直接返回,相当于过滤掉</span></span><br><span class="line">LONG WINAPI</span><br><span class="line"><span class="title function_">VectoredHandler3</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> _EXCEPTION_POINTERS *ExceptionInfo</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	LONG lResult = EXCEPTION_CONTINUE_SEARCH ;</span><br><span class="line">	PEXCEPTION_RECORD pExceptionRecord = ExceptionInfo-&gt;ExceptionRecord ;</span><br><span class="line">	PCONTEXT pContextRecord = ExceptionInfo-&gt;ContextRecord ;</span><br><span class="line">	ULONG_PTR* uESP = <span class="number">0</span> ;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT</span><br><span class="line">		&amp;&amp; pExceptionRecord-&gt;ExceptionAddress == g_AddrofMessageBoxA)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		0012FF70   0040105A   /CALL 到 MessageBoxA 来自 VEHHook.00401054</span></span><br><span class="line"><span class="comment">		0012FF74   00000000   |hOwner = NULL</span></span><br><span class="line"><span class="comment">		0012FF78   00407030   |Text = &quot;VEH Hook&quot;</span></span><br><span class="line"><span class="comment">		0012FF7C   0040703C   |Title = &quot;Test&quot;</span></span><br><span class="line"><span class="comment">		0012FF80   00000000   \Style = MB_OK|MB_APPLMODAL</span></span><br><span class="line"><span class="comment">		0012FF84   00401225   返回到 VEHHook.&lt;ModuleEntryPoint&gt;+0B4 来自 VEHHook.00401000</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//直接返回到调用者处</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RSP = 0x%p\n&quot;</span>,pContextRecord-&gt;Rsp) ;</span><br><span class="line">		uESP = (ULONG_PTR*)pContextRecord-&gt;Rsp ;</span><br><span class="line">		pContextRecord-&gt;Rip = uESP[<span class="number">0</span>] ;<span class="comment">//设置EIP为返回地址</span></span><br><span class="line">		pContextRecord-&gt;Rsp += <span class="keyword">sizeof</span>(ULONG_PTR); <span class="comment">//将压入栈内的参数和返回地址清理掉,4为参数个数,1为返回地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ESP = 0x%X\n&quot;</span>,pContextRecord-&gt;Esp) ;</span><br><span class="line">		uESP = (ULONG_PTR*)pContextRecord-&gt;Esp ;</span><br><span class="line">		pContextRecord-&gt;Eip = uESP[<span class="number">0</span>] ;<span class="comment">//设置EIP为返回地址</span></span><br><span class="line">		pContextRecord-&gt;Esp += (<span class="number">4</span> + <span class="number">1</span>)*<span class="keyword">sizeof</span>(ULONG_PTR); <span class="comment">//将压入栈内的参数和返回地址清理掉,4为参数个数,1为返回地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">		lResult = EXCEPTION_CONTINUE_EXECUTION ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> lResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InstallVEHHook</span><span class="params">(PVECTORED_EXCEPTION_HANDLER Handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Current Handler Address = 0x%p\n&quot;</span>,Handler);</span><br><span class="line">	g_hVector = AddVectoredExceptionHandler(<span class="number">1</span>,Handler);</span><br><span class="line">	<span class="keyword">return</span> g_hVector != <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">UnInstallVEHHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RemoveVectoredExceptionHandler(g_hVector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0:000&gt; u user32!messageboxA</span></span><br><span class="line"><span class="comment">USER32!MessageBoxA:</span></span><br><span class="line"><span class="comment">77d507ea 8bff            mov     edi,edi</span></span><br><span class="line"><span class="comment">77d507ec 55              push    ebp</span></span><br><span class="line"><span class="comment">77d507ed 8bec            mov     ebp,esp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BOOL <span class="title function_">SetBreakPoint</span><span class="params">(PVOID pFuncAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwCnt = <span class="number">0</span> ;</span><br><span class="line">	BYTE *pTarget = (BYTE*)pFuncAddr;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	g_OldCode[<span class="number">0</span>] = *pTarget;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original Fun Head Code = 0x%02X\n&quot;</span>,g_OldCode[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//修改内存页的属性</span></span><br><span class="line">	DWORD dwOLD;</span><br><span class="line">	MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line">	VirtualQuery(pTarget,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">	VirtualProtect(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOLD);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写入int3</span></span><br><span class="line">	*pTarget  = <span class="number">0xCC</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//恢复内存页的属性</span></span><br><span class="line">	VirtualProtect(mbi.BaseAddress,mbi.RegionSize,dwOLD,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">ClearBreakPoint</span><span class="params">(PVOID pFuncAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	BYTE *pTarget = (BYTE*)pFuncAddr;</span><br><span class="line">	<span class="comment">//修改内存页的属性</span></span><br><span class="line">	DWORD dwOLD;</span><br><span class="line">	MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line">	VirtualQuery(pTarget,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">	VirtualProtect(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOLD);</span><br><span class="line">	</span><br><span class="line">	*pTarget  = g_OldCode[<span class="number">0</span>] ;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//恢复内存页的属性</span></span><br><span class="line">	VirtualProtect(mbi.BaseAddress,mbi.RegionSize,dwOLD,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">My_MessageBox</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">char</span> newMsg[<span class="number">400</span>];</span><br><span class="line">	<span class="type">char</span> newCation[]=<span class="string">&quot;标题被我改了!&quot;</span>;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span> (lpText)</span><br><span class="line">	&#123;</span><br><span class="line">		ZeroMemory(newMsg,<span class="number">400</span>);</span><br><span class="line">		lstrcpy(newMsg,lpText);</span><br><span class="line">		lstrcat(newMsg,<span class="string">&quot;\n\tMessage Box hacked by pediy.com&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;有人调用MessageBox...\n&quot;</span>);</span><br><span class="line">	result = g_OriginalMessageBoxA(hWnd,newMsg,newCation,uType);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>实现流程，先获得先获得地址，获得之后安装一个解决方案，然后设置接下来进行函数的断点，然后调用即可</p>
<h5 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hUser32 = LoadLibrary(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	g_AddrofMessageBoxA =  (PVOID)GetProcAddress(hUser32,<span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address of MessageBoxA = 0x%p\n&quot;</span>,g_AddrofMessageBoxA);</span><br><span class="line">	g_OriginalMessageBoxA = (PFN_MessageBox)InitTrampolineFun();  <span class="comment">//跳过开头的Hook</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler1 = 0x%p\n&quot;</span>,VectoredHandler1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler2 = 0x%p\n&quot;</span>,VectoredHandler2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Addr of VectoredHandler3 = 0x%p\n&quot;</span>,VectoredHandler3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择安装一个进行测试</span></span><br><span class="line">	InstallVEHHook(VectoredHandler2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置断点</span></span><br><span class="line">	SetBreakPoint(g_AddrofMessageBoxA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//call</span></span><br><span class="line">	ShowMsgBox(<span class="string">&quot;VEH Hook Test.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;All Finished!\n&quot;</span>);</span><br><span class="line">	ClearBreakPoint(g_AddrofMessageBoxA);</span><br><span class="line">	UnInstallVEHHook();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	ShowMsgBox(<span class="string">&quot;Hook Cleared&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在printf(“All Finished!\n”)之前是对异常的准备工作，后面的是清理工作，这里需要重点研究的是，三种异常处理方法函数和安装函数</p>
<h5 id="三种异常函数"><a href="#三种异常函数" class="headerlink" title="三种异常函数"></a>三种异常函数</h5><h6 id="共同部分"><a href="#共同部分" class="headerlink" title="共同部分"></a>共同部分</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LONG lResult = EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">PEXCEPTION_RECORD pExceptionRecord = ExceptionInfo-&gt;ExceptionRecord;</span><br><span class="line">PCONTEXT pContextRecord = ExceptionInfo-&gt;ContextRecord;</span><br><span class="line">ULONG_PTR* uESP = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (pExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT</span><br><span class="line">	&amp;&amp; pExceptionRecord-&gt;ExceptionAddress == g_AddrofMessageBoxA)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p><code>EXCEPTION_RECORD</code> 结构体</p>
<p><code>EXCEPTION_RECORD</code> 结构体包含了异常的基本信息，主要字段有：</p>
<ul>
<li><code>ExceptionCode</code>：异常的代码，表示异常类型，例如 <code>EXCEPTION_ACCESS_VIOLATION</code>、<code>EXCEPTION_BREAKPOINT</code> 等。</li>
<li><code>ExceptionAddress</code>：异常发生时的地址（通常是程序崩溃的指令地址）。</li>
<li><code>ExceptionFlags</code>：异常的标志位，用来表示异常的特殊类型或处理方式。</li>
<li><code>NumberParameters</code>：异常的参数数量。</li>
<li><code>ExceptionInformation[]</code>：包含异常相关的附加信息，具体信息取决于异常类型。</li>
</ul>
<p><code>CONTEXT</code> 结构体</p>
<p><code>CONTEXT</code> 结构体保存了线程的寄存器状态。对于 x86 和 x64 平台，结构体的成员有所不同。</p>
<ul>
<li>在 <strong>x64</strong> 系统中，<code>CONTEXT</code> 结构体包含以下寄存器：<ul>
<li><code>Rax, Rbx, Rcx, Rdx</code> 等通用寄存器。</li>
<li><code>Rip</code>：指令指针，表示当前执行的指令地址。</li>
<li><code>Rsp</code>：堆栈指针，指向栈的当前位置。</li>
<li><code>Rbp</code>：基址指针。</li>
<li><code>Rdi, Rsi</code> 等其他寄存器</li>
</ul>
</li>
</ul>
<p>先设置一个默认的返回值，没有完全处理异常</p>
<p>初始化了两个指针，一个指向异常的详细信息，一个指向保存当前CPU寄存器状况的环境</p>
<ul>
<li><code>**EXCEPTION_BREAKPOINT**</code>：这是一个常量，值为 <code>0x80000003</code>，表示这是一个<strong>断点异常</strong>。通常是由调试器或某些程序内的显式 <code>int 3</code> 指令（触发断点）引发的。断点异常一般在调试程序时用来暂停程序的执行。</li>
</ul>
<p>这里检测断点是不是自己设置的<code>0xCC</code>，并且检测是不是在<code>MessageBoxA</code>里的</p>
<h6 id="VectoredHandler1"><a href="#VectoredHandler1" class="headerlink" title="VectoredHandler1"></a>VectoredHandler1</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64上前四个参数依次为RCX,RDX,R8,R9</span></span><br><span class="line"><span class="comment">//修改第二个参数，即LpMsg</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpText = 0x%p   %s\n&quot;</span>,pContextRecord-&gt;Rdx,(<span class="type">char</span>*)pContextRecord-&gt;Rdx);</span><br><span class="line">pContextRecord-&gt;Rdx = (ULONG_PTR)szNewMsg;</span><br><span class="line">pContextRecord-&gt;Rip = (ULONG_PTR)g_OriginalMessageBoxA ; <span class="comment">//跳到Trampoline继续执行</span></span><br></pre></td></tr></table></figure>

<p>这个比较好理解，把函数调用进去的寄存器改成需要的值，然后将rip回正</p>
<h6 id="VectoredHandler2"><a href="#VectoredHandler2" class="headerlink" title="VectoredHandler2"></a>VectoredHandler2</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64上前四个参数依次为RCX,RDX,R8,R9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RSP = 0x%p\n&quot;</span>,pContextRecord-&gt;Rsp) ;</span><br><span class="line">uESP = (ULONG_PTR*)pContextRecord-&gt;Rsp ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Return Address = 0x%p\n&quot;</span>,uESP[<span class="number">0</span>]);</span><br><span class="line">ret = g_OriginalMessageBoxA((HWND)pContextRecord-&gt;Rcx,szNewMsg,(LPCTSTR)pContextRecord-&gt;R8,(<span class="type">int</span>)pContextRecord-&gt;R9);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line"><span class="comment">//修正RSP</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RSP(before) = 0x%p\n&quot;</span>, pContextRecord-&gt;Rsp);<span class="comment">//RSP(before) = 0x000000000014FD98</span></span><br><span class="line">pContextRecord-&gt;Rsp += <span class="keyword">sizeof</span>(ULONG_PTR);<span class="comment">//参数在寄存器中，栈中无参数，仅需跳过返回地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RSP(after) = 0x%p\n&quot;</span>, pContextRecord-&gt;Rsp);<span class="comment">//RSP(after) = 0x000000000014FDA0</span></span><br></pre></td></tr></table></figure>

<p>直接先调用一个你需要的函数，传参在保存上下文中有，然后传入需要不同的地方</p>
<p>因为这里是刚进入函数的时候报错的，所以栈中只保存了返回地址，所以<code>uESP</code>中保存的是返回地址，后面调用完函数之后，将Rip回正，Rsp跳过返回地址</p>
<h6 id="VectoredHandler3"><a href="#VectoredHandler3" class="headerlink" title="VectoredHandler3"></a>VectoredHandler3</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RSP = 0x%p\n&quot;</span>,pContextRecord-&gt;Rsp) ;</span><br><span class="line">uESP = (ULONG_PTR*)pContextRecord-&gt;Rsp ;</span><br><span class="line">pContextRecord-&gt;Rip = uESP[<span class="number">0</span>] ;<span class="comment">//设置EIP为返回地址</span></span><br><span class="line">pContextRecord-&gt;Rsp += <span class="keyword">sizeof</span>(ULONG_PTR); <span class="comment">//将压入栈内的参数和返回地址清理掉,4为参数个数,1为返回地址</span></span><br></pre></td></tr></table></figure>

<p>这里直接将保存环境中的Rip改回返回值，栈跳过返回值，然后返回</p>
<h5 id="InstallVEHHook函数"><a href="#InstallVEHHook函数" class="headerlink" title="InstallVEHHook函数"></a>InstallVEHHook函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InstallVEHHook</span><span class="params">(PVECTORED_EXCEPTION_HANDLER Handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Current Handler Address = 0x%p\n&quot;</span>,Handler);</span><br><span class="line">	g_hVector = AddVectoredExceptionHandler(<span class="number">1</span>,Handler);</span><br><span class="line">	<span class="keyword">return</span> g_hVector != <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很好分析，首先确定你使用的是哪个处理方案，然后通过<code>AddVectoredExceptionHandler</code>函数来将解决方案加入到VEH中，于是就hook了</p>
<h3 id="Address-Hook（待完善）（偏内核）"><a href="#Address-Hook（待完善）（偏内核）" class="headerlink" title="Address Hook（待完善）（偏内核）"></a>Address Hook（待完善）（偏内核）</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过改变函数的地址（函数在各类表或结构中，或者某个指定的地址处），但他们共同点就是调用函数了，就会成为eip，因此把本来的地址换成我们自己的就实现hook了</p>
<p>这里先看一眼这个文章预备一下前置知识</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/diamond_biu/article/details/110691568">《逆向工程核心原理》第13章——PE文件格式（2）：IAT与EAT_od查看iat-CSDN博客</a></p>
<h5 id="各类表中的地址"><a href="#各类表中的地址" class="headerlink" title="各类表中的地址"></a>各类表中的地址</h5><p>PE中的IAT</p>
<p><font style="color:rgb(77, 77, 77);">导入地址表（Import Adress Table）。简而言之IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。</font></p>
<p><font style="color:rgb(77, 77, 77);">PE中的EAT</font></p>
<p><font style="color:rgb(28, 31, 33);">EAT是一种核心机制，使不同的应用程序可以调用库文件中提供的函数，只有通过EAT才能准确求得从相应库中到处函数的起始地址。</font></p>
<p><font style="color:rgb(28, 31, 33);">user32.dll的回调函数表</font></p>
<p>存储系统回调函数的表</p>
<p>IDT</p>
<p>SSDT和Shadow SSDT</p>
<p>C++类的虚函数表–这里的虚函数hook需要注意</p>
<p>注意的地方是，子类函数中重载函数的地址会被替换成虚函数表中对应的地址（其继承函数）</p>
<p>COM借口的功能函数表</p>
<p>处理历程地址</p>
<p>书上所说，这部分内容常用于内核中</p>
<p>这里补习一下例程的概念</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/scyatcs/article/details/77452336">什么是例程？_例程是什么意思-CSDN博客</a></p>
<p><code>例程≈ 函数？</code>或者说<code>例程&gt;=函数？</code></p>
<h6 id="DRIVER-OBJECT-的-MajorFunction-及FasIo-派遣历程地址"><a href="#DRIVER-OBJECT-的-MajorFunction-及FasIo-派遣历程地址" class="headerlink" title="DRIVER_OBJECT 的 MajorFunction 及FasIo 派遣历程地址"></a>DRIVER_OBJECT 的 MajorFunction 及FasIo 派遣历程地址</h6><p>在这本书的这里，我还没有学习他说的例子，并且有很多生名词，我先把不知道的自己简单搜索的标注在这里</p>
<p>什么是 ntfs.sys</p>
<p>该过程的Ntfs.sys也被称为NT文件系统驱动程序，它是由微软公司所拥有。该的Ntfs.sys过程用于创建和存储<br>与使用NTFS的消防处的应用程序。在Windows操作系统检验机构（因为只有合法的用户才能运行此），其次是I<br>&#x2F; O管理，将所述文件句柄到一个文件对象的指标。这个过程之后，得到的NTFS文件在磁盘使用的文件对象指标。 NTFS的收集与使用文件对象指针的文件属性的渣打银行（流控制块）。流控制块是由单一的属性文件表示，并包含有关如何获取文件点的国有商业银行的数据建设FCB（文件控制块）指定的属性信息。该FCB具有指定MFT（主文件表）的文件记录的指标</p>
<p>书中的例子也没太看懂，以后懂了回来解释补充，总之看到了，FSD Hook 是修改的FileSystem Driver</p>
<h6 id="StartIo等特殊例程的地址"><a href="#StartIo等特殊例程的地址" class="headerlink" title="StartIo等特殊例程的地址"></a>StartIo等特殊例程的地址</h6><p>这个例程主要用于IRP的串行处理，在nt!IoStartPacket中被调用</p>
<h6 id="OBJECT-TYPE-中-OBJECT-TYPE-INITIALIZER包含的各种处理过程"><a href="#OBJECT-TYPE-中-OBJECT-TYPE-INITIALIZER包含的各种处理过程" class="headerlink" title="OBJECT_TYPE 中 _OBJECT_TYPE_INITIALIZER包含的各种处理过程"></a>OBJECT_TYPE 中 _OBJECT_TYPE_INITIALIZER包含的各种处理过程</h6><p>看不懂思密达，以后再说吧</p>
<h5 id="特殊寄存器中的地址"><a href="#特殊寄存器中的地址" class="headerlink" title="特殊寄存器中的地址"></a>特殊寄存器中的地址</h5><p>好像还是内核</p>
<h5 id="特殊的函数指针"><a href="#特殊的函数指针" class="headerlink" title="特殊的函数指针"></a>特殊的函数指针</h5><p>前面说的还正常后面又是内核</p>
<p>好像是结束了，那么综上所看，addresshook多用于内核，以后回来看</p>
<h4 id="IATHook"><a href="#IATHook" class="headerlink" title="IATHook"></a>IATHook</h4><h5 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a><font style="color:rgb(79, 79, 79);">IAT</font></h5><p><font style="color:rgb(77, 77, 77);">IAT：导入地址表（Import Adress Table）。简而言之IAT是一种表格，用来</font><strong><font style="color:rgb(77, 77, 77);">记录程序正在使用哪些库中的哪些函数</font></strong><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><font style="color:rgb(68, 68, 68);">每个调用的 API 函数地址都保存在 IAT 表中。 API 函数调用时，每个输入节（ IMPORT SECTION ）所指向的 IAT结构如下图所示。</font></p>
<p><font style="color:rgb(68, 68, 68);">程序中每个调用 API 函数的 CALL 指令所使用的地址都是相应函数登记在 IAT 表的地址。所以为了截获 API 函数，我们将 IAT 表中的地址换成用户自己的 API PROXY 函数地址，这样每个 API 调用都是先调用用户自己的 API PROXY 函数。在这个函数中我们可以完成函数名称的记录、参数的记录、调用原来的过程，并在返回时记录结果。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bIsWow64 = IsWow64();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IsWow64 = %d\n&quot;</span>,bIsWow64);</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;Before IAT Hook&quot;</span>);</span><br><span class="line">	IAT_InstallHook();</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;After  IAT Hook&quot;</span>);</span><br><span class="line">	IAT_UnInstallHook();</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;After  IAT Hook UnHooked&quot;</span>);       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">ShowMsgBox</span><span class="params">(<span class="type">char</span> *szMsg)</span></span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>,szMsg,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上操作，如果按照正常输出的话，只会有三个框，但是经过<code>IAT_InstallHook</code>函数之后，box表就会改变，使用了修改IAT的方法拦截了API的调用，所以称为IAT hook，调用地址欺骗</p>
<h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//         第13章  Hook技术 《加密与解密（第四版）》           //</span></span><br><span class="line"><span class="comment">//                                                             //</span></span><br><span class="line"><span class="comment">//         Author: achillis(黑月教主)                          //</span></span><br><span class="line"><span class="comment">//         Blog  : http://www.cnblogs.com/achillis/            //</span></span><br><span class="line"><span class="comment">//         QQ    : 344132161                                   //</span></span><br><span class="line"><span class="comment">//         Email : achillis@126.com                            //</span></span><br><span class="line"><span class="comment">//         转载请保留作者信息                                  //</span></span><br><span class="line"><span class="comment">//         (c)  看雪学院 www.kanxue.com 2000-2018              //</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//程序功能:为本进程的exe模块安装IAT Hook，目标函数是MessageBoxA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;imagehlp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;imagehlp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以MessageBoxA的原型定义一个函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> </span><br><span class="line"><span class="params">(WINAPI *PFN_MessageBoxA)</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以MessageBoxA的原型定义一个函数来替代原始的MessageBoxA</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">My_MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在以下关系</span></span><br><span class="line"><span class="comment">//*(*pThunkPointer) == *pOriginalFuncAddr ;</span></span><br><span class="line">BOOL <span class="title function_">InstallModuleIATHook</span><span class="params">(</span></span><br><span class="line"><span class="params">	HMODULE hModToHook,</span></span><br><span class="line"><span class="params">	<span class="type">char</span> *szModuleName, </span></span><br><span class="line"><span class="params">	<span class="type">char</span> *szFuncName,</span></span><br><span class="line"><span class="params">	PVOID ProxyFunc,</span></span><br><span class="line"><span class="params">	PULONG_PTR *pThunkPointer,</span></span><br><span class="line"><span class="params">	ULONG_PTR *pOriginalFuncAddr</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">ShowMsgBox</span><span class="params">(<span class="type">char</span> *szMsg)</span>;</span><br><span class="line">BOOL <span class="title function_">IAT_InstallHook</span><span class="params">()</span>;</span><br><span class="line">VOID <span class="title function_">IAT_UnInstallHook</span><span class="params">()</span>;</span><br><span class="line">BOOL <span class="title function_">IsWow64</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//保存原始MessageBoxA的地址</span></span><br><span class="line">PFN_MessageBoxA OldMessageBox=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//指向IAT中pThunk的地址</span></span><br><span class="line">PULONG_PTR g_PointerToIATThunk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bIsWow64 = IsWow64();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IsWow64 = %d\n&quot;</span>,bIsWow64);</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;Before IAT Hook&quot;</span>);</span><br><span class="line">	IAT_InstallHook();</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;After  IAT Hook&quot;</span>);</span><br><span class="line">	IAT_UnInstallHook();</span><br><span class="line">	ShowMsgBox(<span class="string">&quot;After  IAT Hook UnHooked&quot;</span>);       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//之所以把这个调用单独放在一个函数中，是因为Release模式下对调用进行了优化,第二次调用时直接采用了寄存器寻址而不是导入表</span></span><br><span class="line"><span class="comment">//因此，单独放在一个函数中可以避免这个情况。</span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">ShowMsgBox</span><span class="params">(<span class="type">char</span> *szMsg)</span></span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>,szMsg,<span class="string">&quot;Test&quot;</span>,MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">My_MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">	HWND hWnd,          <span class="comment">// handle of owner window</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpText,     <span class="comment">// address of text in message box</span></span></span><br><span class="line"><span class="params">	LPCTSTR lpCaption,  <span class="comment">// address of title of message box</span></span></span><br><span class="line"><span class="params">	UINT uType          <span class="comment">// style of message box</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//在这里，你可以对原始参数进行任意操作</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> newText[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> newCaption[<span class="number">256</span>]=<span class="string">&quot;pediy.com&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;有人调用MessageBox!\n&quot;</span>);</span><br><span class="line">	<span class="comment">//在调用原函数之前，可以对IN(输入类)参数进行干涉</span></span><br><span class="line">	lstrcpy(newText,lpText);<span class="comment">//为防止原函数提供的缓冲区不够，这里复制到我们自己的一个缓冲区中再进行操作</span></span><br><span class="line">	lstrcat(newText,<span class="string">&quot;\n\tMessageBox Hacked by pediy.com!&quot;</span>);<span class="comment">//篡改消息框内容</span></span><br><span class="line">	uType|=MB_ICONERROR;<span class="comment">//增加一个错误图标</span></span><br><span class="line">	ret = OldMessageBox(hWnd,newText,newCaption,uType);<span class="comment">//调用原MessageBox，并保存返回值</span></span><br><span class="line">	<span class="comment">//调用原函数之后，可以继续对OUT(输出类)参数进行干涉,比如网络函数的recv，可以干涉返回的内容</span></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//这里你还可以干涉原始函数的返回值</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">IAT_InstallHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bResult = FALSE ;</span><br><span class="line">	HMODULE hCurExe = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	PULONG_PTR pt ;</span><br><span class="line">	ULONG_PTR OrginalAddr;</span><br><span class="line">	bResult = InstallModuleIATHook(hCurExe,<span class="string">&quot;user32.dll&quot;</span>,<span class="string">&quot;MessageBoxA&quot;</span>,(PVOID)My_MessageBoxA,&amp;pt,&amp;OrginalAddr);</span><br><span class="line">	<span class="keyword">if</span> (bResult)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Hook安装完毕! pThunk=0x%p  OriginalAddr = 0x%p\n&quot;</span>,pt,OrginalAddr);</span><br><span class="line">		g_PointerToIATThunk = pt ;</span><br><span class="line">		OldMessageBox = (PFN_MessageBoxA)OrginalAddr ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">IAT_UnInstallHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD dwOLD;</span><br><span class="line">	MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line">	<span class="keyword">if</span> (g_PointerToIATThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查询并修改内存页的属性</span></span><br><span class="line">		VirtualQuery((LPCVOID)g_PointerToIATThunk,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">		VirtualProtect(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOLD);</span><br><span class="line">		<span class="comment">//将原始的MessageBoxA地址填入IAT中</span></span><br><span class="line">		*g_PointerToIATThunk = (ULONG)OldMessageBox;</span><br><span class="line">		<span class="comment">//恢复内存页的属性</span></span><br><span class="line">		VirtualProtect(mbi.BaseAddress,mbi.RegionSize,dwOLD,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// FullName:    InstallModuleIATHook</span></span><br><span class="line"><span class="comment">// Description: 为指定模块安装IAT Hook</span></span><br><span class="line"><span class="comment">// Access:      public </span></span><br><span class="line"><span class="comment">// Returns:     BOOL</span></span><br><span class="line"><span class="comment">// Parameter:   HMODULE hModToHook , 待Hook的模块基址</span></span><br><span class="line"><span class="comment">// Parameter:   char * szModuleName , 目标函数所在模块的名字</span></span><br><span class="line"><span class="comment">// Parameter:   char * szFuncName , 目标函数的名字</span></span><br><span class="line"><span class="comment">// Parameter:   PVOID DetourFunc , Detour函数地址</span></span><br><span class="line"><span class="comment">// Parameter:   PULONG * pThunkPointer , 用以接收指向修改的位置的指针</span></span><br><span class="line"><span class="comment">// Parameter:   ULONG * pOriginalFuncAddr , 用以接收原始函数地址</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line">BOOL <span class="title function_">InstallModuleIATHook</span><span class="params">(</span></span><br><span class="line"><span class="params">	HMODULE hModToHook,<span class="comment">// IN</span></span></span><br><span class="line"><span class="params">	<span class="type">char</span> *szModuleName,<span class="comment">// IN</span></span></span><br><span class="line"><span class="params">	<span class="type">char</span> *szFuncName,<span class="comment">// IN</span></span></span><br><span class="line"><span class="params">	PVOID DetourFunc,<span class="comment">// IN</span></span></span><br><span class="line"><span class="params">	PULONG_PTR *pThunkPointer,<span class="comment">//OUT</span></span></span><br><span class="line"><span class="params">	ULONG_PTR *pOriginalFuncAddr<span class="comment">//OUT</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">&#123;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR  pImportDescriptor;</span><br><span class="line">	PIMAGE_THUNK_DATA         pThunkData;</span><br><span class="line">	ULONG ulSize;</span><br><span class="line">	HMODULE hModule=<span class="number">0</span>;</span><br><span class="line">	ULONG_PTR TargetFunAddr;</span><br><span class="line">	PULONG_PTR lpAddr;</span><br><span class="line">	<span class="type">char</span> *szModName;</span><br><span class="line">	BOOL result = FALSE ;</span><br><span class="line">	BOOL bRetn = FALSE;</span><br><span class="line"></span><br><span class="line">	hModule = LoadLibrary(szModuleName);</span><br><span class="line">	TargetFunAddr = (ULONG_PTR)GetProcAddress(hModule,szFuncName);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Address of %s:0x%p\n&quot;</span>,szFuncName,TargetFunAddr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Module To Hook at Base:0x%p\n&quot;</span>,hModToHook);</span><br><span class="line">	pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(hModToHook, TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize);;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Find ImportTable,Address:0x%p\n&quot;</span>,pImportDescriptor);</span><br><span class="line">	<span class="keyword">while</span> (pImportDescriptor-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		szModName = (<span class="type">char</span>*)((PBYTE)hModToHook+pImportDescriptor-&gt;Name) ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Cur Module Name:%s\n&quot;</span>,szModName);</span><br><span class="line">		<span class="keyword">if</span> (stricmp(szModName,szModuleName) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[*]Module Name does not match, search next...\n&quot;</span>);</span><br><span class="line">			pImportDescriptor++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//程序的导入表处理完毕后OriginalFirstThunk可能是无效的，不能再根据名称来查找，而是遍历FirstThunk直接根据地址判断</span></span><br><span class="line">		pThunkData = (PIMAGE_THUNK_DATA)((BYTE *)hModToHook + pImportDescriptor-&gt;FirstThunk);</span><br><span class="line">		<span class="keyword">while</span>(pThunkData-&gt;u1.Function)</span><br><span class="line">		&#123;</span><br><span class="line">			lpAddr = (ULONG_PTR*)pThunkData;</span><br><span class="line">			<span class="comment">//找到了地址</span></span><br><span class="line">			<span class="keyword">if</span>((*lpAddr) == TargetFunAddr)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;[*]Find target address!\n&quot;</span>);</span><br><span class="line">				<span class="comment">//通常情况下导入表所在内存页都是只读的，因此需要先修改内存页的属性为可写</span></span><br><span class="line">				DWORD dwOldProtect;</span><br><span class="line">				MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line">				VirtualQuery(lpAddr,&amp;mbi,<span class="keyword">sizeof</span>(mbi));</span><br><span class="line">				bRetn = VirtualProtect(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOldProtect);</span><br><span class="line">				<span class="keyword">if</span> (bRetn)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//内存页属性修改成功,继续下一步操作,先保存原始数据</span></span><br><span class="line">					<span class="keyword">if</span> (pThunkPointer != <span class="literal">NULL</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						*pThunkPointer = lpAddr ;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (pOriginalFuncAddr != <span class="literal">NULL</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						*pOriginalFuncAddr = *lpAddr ;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//修改地址</span></span><br><span class="line">					*lpAddr = (ULONG_PTR)DetourFunc;</span><br><span class="line">					result = TRUE ;</span><br><span class="line">					<span class="comment">//恢复内存页的属性</span></span><br><span class="line">					VirtualProtect(mbi.BaseAddress,mbi.RegionSize,dwOldProtect,<span class="number">0</span>);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;[*]Hook ok.\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//---------</span></span><br><span class="line">			pThunkData++;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDescriptor++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FreeLibrary(hModule);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span> <span class="params">(WINAPI *LPFN_ISWOW64PROCESS)</span> <span class="params">(HANDLE, PBOOL)</span>;</span><br><span class="line"></span><br><span class="line">LPFN_ISWOW64PROCESS fnIsWow64Process;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">IsWow64</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bIsWow64 = FALSE;</span><br><span class="line"></span><br><span class="line">	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(</span><br><span class="line">		GetModuleHandle(TEXT(<span class="string">&quot;kernel32&quot;</span>)),<span class="string">&quot;IsWow64Process&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != fnIsWow64Process)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!fnIsWow64Process(GetCurrentProcess(),&amp;bIsWow64))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// handle error</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bIsWow64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h5><p>这里只解析这个关键函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">IAT_InstallHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bResult = FALSE ;</span><br><span class="line">	HMODULE hCurExe = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">	PULONG_PTR pt ;</span><br><span class="line">	ULONG_PTR OrginalAddr;</span><br><span class="line">	bResult = InstallModuleIATHook(hCurExe,<span class="string">&quot;user32.dll&quot;</span>,<span class="string">&quot;MessageBoxA&quot;</span>,(PVOID)My_MessageBoxA,&amp;pt,&amp;OrginalAddr);</span><br><span class="line">	<span class="keyword">if</span> (bResult)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Hook安装完毕! pThunk=0x%p  OriginalAddr = 0x%p\n&quot;</span>,pt,OrginalAddr);</span><br><span class="line">		g_PointerToIATThunk = pt ;</span><br><span class="line">		OldMessageBox = (PFN_MessageBoxA)OrginalAddr ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h6><p><code>BOOL bResult = FALSE ;</code></p>
<p><code>HMODULE hCurExe = GetModuleHandle(NULL);</code></p>
<p>定义两个初始值，一个是返回是否成功，一个是获取当前线程的句柄</p>
<p>其中函数解析<code>GetMouduleHandle</code></p>
<p>是一个win32API函数，用于获取句柄，当传入参数为NULL的时候代表获取当前进程中主模块的句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PULONG_PTR pt;</span><br><span class="line">ULONG_PTR OrginalAddr;</span><br><span class="line">bResult = InstallModuleIATHook(</span><br><span class="line">    hCurExe,              <span class="comment">// 模块句柄</span></span><br><span class="line">    <span class="string">&quot;user32.dll&quot;</span>,         <span class="comment">// 被钩子的模块</span></span><br><span class="line">    <span class="string">&quot;MessageBoxA&quot;</span>,        <span class="comment">// 目标函数名称</span></span><br><span class="line">    (PVOID)My_MessageBoxA,<span class="comment">// 替换的新函数</span></span><br><span class="line">    &amp;pt,                  <span class="comment">// 原函数地址指针</span></span><br><span class="line">    &amp;OrginalAddr          <span class="comment">// 存储目标函数的原始地址</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h6><p>定义了pt(原函数地址），OrginalAddr（存储目标函数地址）</p>
<p>其中的函数解析<code>InstallModuleIATHook</code>，函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">InstallModuleIATHook</span><span class="params">(</span></span><br><span class="line"><span class="params">	HMODULE hModToHook,       <span class="comment">// [IN] 要修改的目标模块句柄。</span></span></span><br><span class="line"><span class="params">	<span class="type">char</span>* szModuleName,       <span class="comment">// [IN] 被钩取的目标模块名称（例如 &quot;user32.dll&quot;）。</span></span></span><br><span class="line"><span class="params">	<span class="type">char</span>* szFuncName,         <span class="comment">// [IN] 要拦截的目标函数名称（例如 &quot;MessageBoxA&quot;）。</span></span></span><br><span class="line"><span class="params">	PVOID DetourFunc,         <span class="comment">// [IN] 替换函数地址（钩子函数地址）。</span></span></span><br><span class="line"><span class="params">	PULONG_PTR* pThunkPointer,<span class="comment">// [OUT] 保存导入表中目标函数地址的指针。</span></span></span><br><span class="line"><span class="params">	ULONG_PTR* pOriginalFuncAddr<span class="comment">// [OUT] 保存目标函数的原始地址。</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 定义所需的变量。</span></span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR  pImportDescriptor; <span class="comment">// 导入表描述符，用于定位导入表。</span></span><br><span class="line">	PIMAGE_THUNK_DATA         pThunkData;        <span class="comment">// 用于遍历导入表的函数指针。</span></span><br><span class="line">	ULONG ulSize;                                 <span class="comment">// 存储导入表大小。</span></span><br><span class="line">	HMODULE hModule = <span class="number">0</span>;                          <span class="comment">// 存储被钩取模块的句柄。</span></span><br><span class="line">	ULONG_PTR TargetFunAddr;                      <span class="comment">// 存储目标函数的真实地址。</span></span><br><span class="line">	PULONG_PTR lpAddr;                            <span class="comment">// 指向导入表中的目标地址。</span></span><br><span class="line">	<span class="type">char</span>* szModName;                              <span class="comment">// 保存当前模块的名称。</span></span><br><span class="line">	BOOL result = FALSE;                          <span class="comment">// 返回值，表示是否钩子成功。</span></span><br><span class="line">	BOOL bRetn = FALSE;                           <span class="comment">// 临时变量，用于存储内存权限修改的结果。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载目标模块并获取目标函数的地址。</span></span><br><span class="line">	hModule = LoadLibrary(szModuleName);           <span class="comment">// 加载被钩取的模块（例如 &quot;user32.dll&quot;）。</span></span><br><span class="line">	TargetFunAddr = (ULONG_PTR)GetProcAddress(hModule, szFuncName); <span class="comment">// 获取目标函数地址。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Address of %s:0x%p\n&quot;</span>, szFuncName, TargetFunAddr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Module To Hook at Base:0x%p\n&quot;</span>, hModToHook);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找目标模块的导入表地址。</span></span><br><span class="line">	pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(</span><br><span class="line">		hModToHook, </span><br><span class="line">		TRUE, </span><br><span class="line">		IMAGE_DIRECTORY_ENTRY_IMPORT, </span><br><span class="line">		&amp;ulSize); <span class="comment">// 获取导入表的起始地址及大小。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]Find ImportTable,Address:0x%p\n&quot;</span>, pImportDescriptor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历导入表中的每个模块。</span></span><br><span class="line">	<span class="keyword">while</span> (pImportDescriptor-&gt;FirstThunk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取当前模块的名称。</span></span><br><span class="line">		szModName = (<span class="type">char</span>*)((PBYTE)hModToHook + pImportDescriptor-&gt;Name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Cur Module Name:%s\n&quot;</span>, szModName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果模块名称与目标模块不匹配，继续查找下一个。</span></span><br><span class="line">		<span class="keyword">if</span> (stricmp(szModName, szModuleName) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[*]Module Name does not match, search next...\n&quot;</span>);</span><br><span class="line">			pImportDescriptor++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始遍历导入表中的函数地址。</span></span><br><span class="line">		pThunkData = (PIMAGE_THUNK_DATA)((BYTE*)hModToHook + pImportDescriptor-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pThunkData-&gt;u1.Function)</span><br><span class="line">		&#123;</span><br><span class="line">			lpAddr = (ULONG_PTR*)pThunkData; <span class="comment">// 获取当前函数的地址指针。</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果找到目标函数地址。</span></span><br><span class="line">			<span class="keyword">if</span> ((*lpAddr) == TargetFunAddr)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;[*]Find target address!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取当前地址所在内存页信息并尝试修改权限。</span></span><br><span class="line">				DWORD dwOldProtect; <span class="comment">// 保存原内存保护属性。</span></span><br><span class="line">				MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line">				VirtualQuery(lpAddr, &amp;mbi, <span class="keyword">sizeof</span>(mbi)); <span class="comment">// 查询内存页属性。</span></span><br><span class="line">				bRetn = VirtualProtect(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (bRetn)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 修改内存页属性成功。</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 保存导入表中目标函数地址指针和原始函数地址。</span></span><br><span class="line">					<span class="keyword">if</span> (pThunkPointer != <span class="literal">NULL</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						*pThunkPointer = lpAddr; <span class="comment">// 保存导入表中的地址。</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (pOriginalFuncAddr != <span class="literal">NULL</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						*pOriginalFuncAddr = *lpAddr; <span class="comment">// 保存目标函数的原始地址。</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 替换导入表中的目标函数地址为自定义函数地址。</span></span><br><span class="line">					*lpAddr = (ULONG_PTR)DetourFunc;</span><br><span class="line"></span><br><span class="line">					result = TRUE; <span class="comment">// 钩子安装成功。</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 恢复内存页的原始权限。</span></span><br><span class="line">					VirtualProtect(mbi.BaseAddress, mbi.RegionSize, dwOldProtect, <span class="number">0</span>);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;[*]Hook ok.\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 跳出循环。</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pThunkData++; <span class="comment">// 检查下一个函数地址。</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pImportDescriptor++; <span class="comment">// 检查下一个模块的导入表。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放加载的模块句柄。</span></span><br><span class="line">	FreeLibrary(hModule);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result; <span class="comment">// 返回钩子安装结果。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单来说就是传入要修改的模块句柄和名称以及具体的函数，然后在传入要替换的函数的地址，最后保存源函数地址的指针和目标函数的地址</p>
<h6 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bResult)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Hook安装完毕! pThunk=0x%p  OriginalAddr = 0x%p\n&quot;</span>,pt,OrginalAddr);</span><br><span class="line">		g_PointerToIATThunk = pt ;</span><br><span class="line">		OldMessageBox = (PFN_MessageBoxA)OrginalAddr ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据上一个函数的返回值也就是TRUE或FULL来判断是否成功，并打印结果，最后保存一下原函数地址与指针就结束了</p>
<h4 id="虚函数hook"><a href="#虚函数hook" class="headerlink" title="虚函数hook"></a>虚函数hook</h4><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Primeprime/article/details/80776625">虚函数表详解-CSDN博客</a></p>
<h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p>十分符合Address Hook的原理，将虚函数表中的函数地址换成自己的函数地址</p>
<h5 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">第13章  Hook技术</span></span><br><span class="line"><span class="comment">《加密与解密（第四版）》</span></span><br><span class="line"><span class="comment">(c)  看雪学院 www.kanxue.com 2000-2018</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CClassHook.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//  // 包含 AfxWinInit 所在的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CClassHook.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> THIS_FILE</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> THIS_FILE[] = __FILE__;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要解决两个问题</span></span><br><span class="line"><span class="comment">1.如何获取类成员函数的地址</span></span><br><span class="line"><span class="comment">2.如何使用普通函数替换类成员函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// The one and only application object</span></span><br><span class="line"></span><br><span class="line">CWinApp theApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base::g&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base::h&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">novirtual</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base::not virtual&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base::Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;base::Add\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DetourClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">DetourFun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrampolineClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">TrampolineFun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;TrampolineClass\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span> ;&#125;;<span class="comment">//原型与被Hook函数相同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DetourClass Detour;</span><br><span class="line">TrampolineClass Trampoline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DetourClass::DetourFun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//TrampolineFun();  //由于这里的类实际上是base,所以调用TrampolineFun即调用第二个虚函数，相当于调用pbase-&gt;g()</span></span><br><span class="line">    TrampolineClass *pTrampoline = <span class="keyword">new</span> TrampolineClass;</span><br><span class="line">    <span class="type">int</span> result = pTrampoline-&gt;<span class="built_in">TrampolineFun</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DetourClass:: OriginalFun returned %d\n&quot;</span>,result);</span><br><span class="line">    result += <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">delete</span> pTrampoline;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">LPVOID <span class="title">GetClassVirtualFnAddress</span><span class="params">(LPVOID pthis,<span class="type">int</span> Index)</span></span>;</span><br><span class="line"><span class="function">VOID <span class="title">HookClassMemberByAnotherClassMember</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[], TCHAR* envp[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nRetCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize MFC and print and error on failure</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AfxWinInit</span>(::<span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, ::<span class="built_in">GetCommandLine</span>(), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> change error code to suit your needs</span></span><br><span class="line">        cerr &lt;&lt; _T(<span class="string">&quot;Fatal Error: MFC initialization failed&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        nRetCode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> code your application&#x27;s behavior here.</span></span><br><span class="line">        <span class="built_in">HookClassMemberByAnotherClassMember</span>();</span><br><span class="line">        <span class="built_in">getchar</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nRetCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookClassMemberByAnotherClassMember</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base b;</span><br><span class="line">    base *pbase=&amp;b;</span><br><span class="line"></span><br><span class="line">    DWORD dwOLD;</span><br><span class="line">    MEMORY_BASIC_INFORMATION  mbi;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pbase = 0x%X\n&quot;</span>,pbase);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR *vfTableToHook = (ULONG_PTR*)*(ULONG_PTR*)pbase;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vfTable = 0x%x\n&quot;</span>,vfTableToHook);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR *vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)&amp;Trampoline;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先将原函数的地址保存到当前类的表中，作为调用原函数的入口</span></span><br><span class="line">    <span class="built_in">VirtualQuery</span>(vfTableTrampoline,&amp;mbi,<span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOLD);</span><br><span class="line">    <span class="comment">//保存原始数据</span></span><br><span class="line">    <span class="comment">//原函数位于第几个这里就是第几个，必须保证位置一样</span></span><br><span class="line">    vfTableTrampoline[<span class="number">0</span>] = (ULONG_PTR)<span class="built_in">GetClassVirtualFnAddress</span>(pbase,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base::Add()  %p\n&quot;</span>,vfTableTrampoline[<span class="number">0</span>]);</span><br><span class="line">    TrampolineClass *p = &amp;Trampoline;</span><br><span class="line">    <span class="comment">//恢复内存页的属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress,mbi.RegionSize,dwOLD,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//修改内存页的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualQuery</span>(vfTableToHook,&amp;mbi,<span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress,mbi.RegionSize,PAGE_EXECUTE_READWRITE,&amp;dwOLD);</span><br><span class="line">    <span class="comment">//保存原始数据</span></span><br><span class="line">    vfTableToHook[<span class="number">0</span>] = (ULONG_PTR)<span class="built_in">GetClassVirtualFnAddress</span>(&amp;Detour,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Detour::Add()  %p\n&quot;</span>,vfTableToHook[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//恢复内存页的属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress,mbi.RegionSize,dwOLD,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> result = pbase-&gt;<span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//调用第3个虚函数，实际调用的是HookClass::DetourFun()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d  \nafter call member fun.\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类虚拟成员函数指针</span></span><br><span class="line"><span class="function">LPVOID <span class="title">GetClassVirtualFnAddress</span><span class="params">(LPVOID pthis,<span class="type">int</span> Index)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG_PTR *vfTable = (ULONG_PTR*)*(ULONG_PTR*)pthis;</span><br><span class="line">    <span class="keyword">return</span> (LPVOID)vfTable[Index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h5><p>这里主要分析hook函数，也是这个函数的核心</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookClassMemberByAnotherClassMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base b;</span><br><span class="line">    base *pbase = &amp;b;</span><br><span class="line"></span><br><span class="line">    DWORD dwOLD;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pbase = 0x%X\n&quot;</span>, pbase);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR *vfTableToHook = (ULONG_PTR*)*(ULONG_PTR*)pbase;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vfTable = 0x%x\n&quot;</span>, vfTableToHook);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR *vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)&amp;Trampoline;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualQuery</span>(vfTableTrampoline, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &amp;dwOLD);</span><br><span class="line"></span><br><span class="line">    vfTableTrampoline[<span class="number">0</span>] = (ULONG_PTR)<span class="built_in">GetClassVirtualFnAddress</span>(pbase, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base::Add()  %p\n&quot;</span>, vfTableTrampoline[<span class="number">0</span>]);</span><br><span class="line">    TrampolineClass *p = &amp;Trampoline;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, dwOLD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualQuery</span>(vfTableToHook, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &amp;dwOLD);</span><br><span class="line"></span><br><span class="line">    vfTableToHook[<span class="number">0</span>] = (ULONG_PTR)<span class="built_in">GetClassVirtualFnAddress</span>(&amp;Detour, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Detour::Add()  %p\n&quot;</span>, vfTableToHook[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, dwOLD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = pbase-&gt;<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d  \nafter call member fun.\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="步骤-1-获取虚拟函数表地址"><a href="#步骤-1-获取虚拟函数表地址" class="headerlink" title="步骤 1: 获取虚拟函数表地址"></a>步骤 1: 获取虚拟函数表地址</h6><ul>
<li><code>vfTableToHook = (ULONG_PTR*)*(ULONG_PTR*)pbase</code> 获取到 <code>base</code> 类实例的虚拟函数表指针。</li>
<li><code>vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)&amp;Trampoline</code> 获取到 <code>TrampolineClass</code> 的虚拟函数表指针。</li>
</ul>
<h6 id="步骤-2-修改虚拟函数表"><a href="#步骤-2-修改虚拟函数表" class="headerlink" title="步骤 2: 修改虚拟函数表"></a>步骤 2: 修改虚拟函数表</h6><ul>
<li><strong>保存原始函数地址</strong>：通过 <code>VirtualQuery</code> 和 <code>VirtualProtect</code> 修改内存权限，使得可以修改虚拟函数表。在 <code>vfTableTrampoline[0]</code> 中保存原来 <code>base::Add</code> 函数的地址。</li>
<li><strong>替换为 Detour 函数</strong>：将 <code>vfTableToHook[0]</code> 替换为 <code>DetourClass::DetourFun</code> 的地址，从而使得 <code>base::Add</code> 函数被替换为 <code>DetourClass::DetourFun</code>。</li>
</ul>
<h6 id="步骤-3-恢复虚拟函数表修改"><a href="#步骤-3-恢复虚拟函数表修改" class="headerlink" title="步骤 3: 恢复虚拟函数表修改"></a>步骤 3: 恢复虚拟函数表修改</h6><ul>
<li>通过 <code>VirtualProtect</code> 恢复内存页的保护，以保证修改后的内存区域可以正常访问。</li>
</ul>
<h6 id="步骤-4-调用虚拟函数"><a href="#步骤-4-调用虚拟函数" class="headerlink" title="步骤 4: 调用虚拟函数"></a>步骤 4: 调用虚拟函数</h6><ul>
<li><code>int result = pbase-&gt;Add(1, 2)</code> 调用了被 Hook 的 <code>base::Add</code> 函数，但由于我们替换了虚拟函数表中的地址，实际上调用的是 <code>DetourClass::DetourFun</code>，最终输出和返回的值是通过 <code>DetourClass::DetourFun</code> 处理后的。</li>
</ul>
<h2 id="二次hook注意事项"><a href="#二次hook注意事项" class="headerlink" title="二次hook注意事项"></a>二次hook注意事项</h2><h3 id="1-不Hook"><a href="#1-不Hook" class="headerlink" title="1.不Hook"></a>1.不Hook</h3><p><code>Hook</code>更改稍有不慎就可能造成程序错误的后果（蓝屏警告），尤其是偏向内核的东西<code>AddressHook</code>，在早期病毒查杀市场，各大病毒查杀软件，就是在各个风险的点添加<code>Hook</code>，但是病毒查杀软件之间添加<code>Hook</code>，并且这些<code>Hook</code>并不兼容，谁也不能保准哪个<code>Hook</code>刚好会覆盖掉另一个的<code>Hook</code>，这样的问题也持续至今，所以到如今这个时代病毒查杀软件也最好只安装一种	</p>
<p>所以有时候<code>Hook</code>随意更改会带来风险</p>
<h3 id="2-恢复Hook前的指令"><a href="#2-恢复Hook前的指令" class="headerlink" title="2.恢复Hook前的指令"></a>2.恢复Hook前的指令</h3><p>这种方法的缺点是，该段的<code>Hook</code>会是唯一性的，一个程序里只能有一个<code>Hook</code></p>
<h3 id="3-换个目标地址Hook"><a href="#3-换个目标地址Hook" class="headerlink" title="3.换个目标地址Hook"></a>3.换个目标地址Hook</h3><p>就跟题目一样，换个地方</p>
<h3 id="4-Hook上一个Hook过程的Detour函数"><a href="#4-Hook上一个Hook过程的Detour函数" class="headerlink" title="4.Hook上一个Hook过程的Detour函数"></a>4.Hook上一个Hook过程的Detour函数</h3><p>这个也和题目一样理解就可以</p>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>l1pmoluy,1392181761@qq.com</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://l1pmoluy.github.io/2024/12/01/Hook%E6%8A%80%E6%9C%AF/" title="Hook技术">https://l1pmoluy.github.io/2024/12/01/Hook%E6%8A%80%E6%9C%AF/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/12/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" rel="prev" title="PE文件格式"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">PE文件格式</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/11/09/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/" rel="next" title="注入技术"><span class="post-nav-text">注入技术</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2025 </span><a class="with-love" id="animate" href="https://l1pmoluy.github.io" title="l1pmoluy's blog"><span class="icon iconify" data-icon="ri:cloud-line"></span></a><span class="author"> l1pmoluy</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#f5b8d5" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://fastly.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://fastly.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js" type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></body></html>