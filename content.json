{"meta":{"title":"l1pmoluy's Blog","subtitle":"Dawing","description":"welcome to my blog","author":"l1pmoluy","url":"https://l1pmoluy.github.io","root":"/"},"posts":[{"title":"'语雀'","date":"2025-03-26T08:08:05.000Z","path":"2025/03/26/语雀/","text":"l1pmoluy · 语雀，我的语雀","updated":"2025-03-26T08:10:10.101Z","categories":[],"tags":[]},{"title":"'main'","date":"2025-03-26T07:55:14.000Z","path":"2025/03/26/main/","text":"前言这篇文章是在第一学期快结束补充的，我不断地思索，哪个文章可以作为逆向启程呢，是ida的熟悉流程？是遇到最简单题目的题解？是c语言的小知识？亦或是其他，但我总认为，这些不足以为我的逆向开一个好头，思来想去最后决定以main函数来作为逆向的启蒙 start开始，也意味着程序的开始，一个用c语言写好了main的程序并不是直接从main开始的，而是start，start紧接着去调用很多函数，他最终的目的也是位main铺路 以一个最简单的程序为例： 12345#include&lt;stdio.h&gt;int main() &#123; printf(&quot;hallo re&quot;); return 0;&#125; 将这个程序生成的文件拖入ida hello re12345// attributes: thunk__int64 start()&#123; return start_0();&#125; 反编译出的第一条是他，start，什么都没有，不过别急，点进去，连着点进去两个函数出现了第一个岔路 12345__int64 sub_140011E30()&#123; road1(); return road2();&#125; 这两个函数原本不叫这个，是我将其随意命名的，他在你的ida中可能会叫sub_地址，是ida给这个函数起的名字，选择road2点进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 sub_140011E50()&#123; __int64 v1; // rcx char v2; // [rsp+20h] [rbp-48h] unsigned __int8 v3; // [rsp+21h] [rbp-47h] unsigned int Code; // [rsp+28h] [rbp-40h] void (__fastcall **v5)(_QWORD, __int64, _QWORD); // [rsp+30h] [rbp-38h] _tls_callback_type *v6; // [rsp+38h] [rbp-30h] if ( !(unsigned __int8)sub_140011393(1i64) ) sub_140011311(7i64); v2 = 0; v3 = sub_140011325(); if ( dword_14001D1F8 == 1 ) &#123; sub_140011311(7i64); &#125; else if ( dword_14001D1F8 ) &#123; v2 = 1; &#125; else &#123; dword_14001D1F8 = 1; if ( j__initterm_e((_PIFV *)&amp;First, (_PIFV *)&amp;Last) ) return 255i64; j__initterm((_PVFV *)&amp;qword_14001A000, (_PVFV *)&amp;qword_14001A220); dword_14001D1F8 = 2; &#125; sub_1400112FD(v3); v5 = (void (__fastcall **)(_QWORD, __int64, _QWORD))sub_140011299(); if ( *v5 &amp;&amp; (unsigned __int8)sub_14001114F(v5) ) (*v5)(0i64, 2i64, 0i64); v6 = (_tls_callback_type *)sub_1400112CB(); if ( *v6 &amp;&amp; (unsigned __int8)sub_14001114F(v6) ) j__register_thread_local_exe_atexit_callback(*v6); Code = sub_1400120A0(); if ( !(unsigned __int8)sub_140011276() ) j_exit(Code); if ( !v2 ) j__cexit(); LOBYTE(v1) = 1; sub_140011140(v1, 0i64); return Code;&#125; 看到最后return Code了吗，记得一个main函数的基本框架有return 0吗，当时说0是返回值，返回程序是否正确运行，那么如果想要返回值0，返回到start那里，这一步返回的Code里面的值就应该是return的0，我们要去看Code在这个程序里那里被定义了——sub_1400120A0，在37行，所以说这个函数往里延伸的就是main函数，点进去 1234567891011__int64 sub_1400120A0()&#123; unsigned int v1; // [rsp+20h] [rbp-28h] char **initial_narrow_environment; // [rsp+28h] [rbp-20h] char **v3; // [rsp+30h] [rbp-18h] initial_narrow_environment = j__get_initial_narrow_environment(); v3 = *j___p___argv(); v1 = *j___p___argc(); return sub_14001126C(v1, v3, initial_narrow_environment);&#125; 还是刚刚的原理，return返回的要是main里面返回的0，所以点开return后跟着的函数，一路到底 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; sub_14001136B(&amp;unk_140022008); printf(&quot;hallo re&quot;); return 0;&#125; 获得了主函数，如果到这里不是很明白的话，从最后一段代码的return 0，回到最初的start，观察一下，0是不是一直作为返回值被返回 终逆向就是这样，总会有很多东西混淆你，谨记自己的初心，静下来，慢慢观察，最终你也可以从空白的的start抵达目标main","updated":"2025-03-26T07:58:50.592Z","categories":[],"tags":[]}],"categories":[],"tags":[]}